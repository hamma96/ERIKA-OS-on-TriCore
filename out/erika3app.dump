
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x0000dfe0 memsz 0x0000dfe0 flags r-x
    LOAD off    0x00014000 vaddr 0x70000000 paddr 0x8000e000 align 2**14
         filesz 0x00000010 memsz 0x00000010 flags rw-
    LOAD off    0x00018000 vaddr 0x50000000 paddr 0x8000e010 align 2**14
         filesz 0x000000f8 memsz 0x000000f8 flags rw-
    LOAD off    0x0001c010 vaddr 0x70000010 paddr 0x8000e010 align 2**14
         filesz 0x00000000 memsz 0x00000010 flags rw-
    LOAD off    0x000180f8 vaddr 0x500000f8 paddr 0x8000e108 align 2**14
         filesz 0x00000000 memsz 0x0000002c flags rw-
    LOAD off    0x0001a600 vaddr 0x5001a600 paddr 0x8000e108 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x0001b700 vaddr 0x5001b700 paddr 0x8000e108 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0001c000 vaddr 0x60000000 paddr 0x8000e108 align 2**14
         filesz 0x00000088 memsz 0x00000088 flags rw-
    LOAD off    0x0001fc00 vaddr 0x5001bc00 paddr 0x8000e140 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x0001c088 vaddr 0x60000088 paddr 0x8000e190 align 2**14
         filesz 0x00000000 memsz 0x0000001c flags rw-
    LOAD off    0x0001e600 vaddr 0x6001a600 paddr 0x8000e190 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x0001f700 vaddr 0x6001b700 paddr 0x8000e190 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00020020 vaddr 0x70000020 paddr 0x8000e190 align 2**14
         filesz 0x00000088 memsz 0x00000088 flags rw-
    LOAD off    0x00023c00 vaddr 0x6001bc00 paddr 0x8000e1c0 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x000200a8 vaddr 0x700000a8 paddr 0x8000e218 align 2**14
         filesz 0x00000000 memsz 0x0000001c flags rw-
    LOAD off    0x00020600 vaddr 0x70018600 paddr 0x8000e218 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00021700 vaddr 0x70019700 paddr 0x8000e218 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00024000 vaddr 0xb0000000 paddr 0x8000e218 align 2**14
         filesz 0x00000000 memsz 0x00000008 flags rw-
    LOAD off    0x00021c00 vaddr 0x70019c00 paddr 0x8000e240 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00004020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000006b0  80000028  80000028  00004028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .CPU2.bss     0000002c  500000f8  8000e108  000180f8  2**2
                  ALLOC, CPU2
  3 .CPU1.bss     0000001c  60000088  8000e190  0001c088  2**2
                  ALLOC, CPU1
  4 .CPU0.bss     0000001c  700000a8  8000e218  000200a8  2**2
                  ALLOC, CPU0
  5 .bss          00000010  70000010  8000e010  0001c010  2**3
                  ALLOC
  6 .lmu_bss      00000008  b0000000  8000e218  00024000  2**2
                  ALLOC
  7 .CPU2.data    000000f8  50000000  8000e010  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, CPU2
  8 .CPU1.data    00000088  60000000  8000e108  0001c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, CPU1
  9 .CPU0.data    00000088  70000020  8000e190  00020020  2**2
                  CONTENTS, ALLOC, LOAD, DATA, CPU0
 10 .data         00000010  70000000  8000e000  00014000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 11 .traptab      00000100  80000700  80000700  00004700  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .ctors        00000008  80000800  80000800  00004800  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .dtors        00000008  80000808  80000808  00004808  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .inttab_cpu0  00002000  80002000  80002000  00006000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text         000046a8  80004000  80004000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .inttab_cpu1  00002000  8000a000  8000a000  0000e000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .inttab_cpu2  00002000  8000c000  8000c000  00010000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .CPU2.ustack  00001000  5001a600  8000e108  0001a600  2**3
                  ALLOC, CPU2
 19 .CPU2.istack  00000400  5001b700  8000e108  0001b700  2**3
                  ALLOC, CPU2
 20 .CPU2.csa     00002000  5001bc00  8000e140  0001fc00  2**6
                  ALLOC, CPU2
 21 .CPU1.ustack  00001000  6001a600  8000e190  0001e600  2**3
                  ALLOC, CPU1
 22 .CPU1.istack  00000400  6001b700  8000e190  0001f700  2**3
                  ALLOC, CPU1
 23 .CPU1.csa     00002000  6001bc00  8000e1c0  00023c00  2**6
                  ALLOC, CPU1
 24 .CPU0.ustack  00001000  70018600  8000e218  00020600  2**3
                  ALLOC, CPU0
 25 .CPU0.istack  00000400  70019700  8000e218  00021700  2**3
                  ALLOC, CPU0
 26 .CPU0.csa     00002000  70019c00  8000e240  00021c00  2**6
                  ALLOC, CPU0
 27 .comment      00000053  00000000  00000000  000200a8  2**0
                  CONTENTS, READONLY
 28 .debug_aranges 00000298  00000000  00000000  000200fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_info   000369d1  00000000  00000000  00020393  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_abbrev 00003b17  00000000  00000000  00056d64  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .debug_line   000049dc  00000000  00000000  0005a87b  2**0
                  CONTENTS, READONLY, DEBUGGING
 32 .debug_frame  00000cf8  00000000  00000000  0005f258  2**2
                  CONTENTS, READONLY, DEBUGGING
 33 .debug_str    00000874  00000000  00000000  0005ff50  2**0
                  CONTENTS, READONLY, DEBUGGING
 34 .debug_loc    00008d53  00000000  00000000  000607c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 35 .debug_ranges 000009f0  00000000  00000000  00069517  2**0
                  CONTENTS, READONLY, DEBUGGING
 36 .version_info 00001333  00000000  00000000  00069f07  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
500000f8 l    d  .CPU2.bss	00000000 .CPU2.bss
60000088 l    d  .CPU1.bss	00000000 .CPU1.bss
700000a8 l    d  .CPU0.bss	00000000 .CPU0.bss
70000010 l    d  .bss	00000000 .bss
b0000000 l    d  .lmu_bss	00000000 .lmu_bss
50000000 l    d  .CPU2.data	00000000 .CPU2.data
60000000 l    d  .CPU1.data	00000000 .CPU1.data
70000020 l    d  .CPU0.data	00000000 .CPU0.data
70000000 l    d  .data	00000000 .data
80000700 l    d  .traptab	00000000 .traptab
80000800 l    d  .ctors	00000000 .ctors
80000808 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
8000a000 l    d  .inttab_cpu1	00000000 .inttab_cpu1
8000c000 l    d  .inttab_cpu2	00000000 .inttab_cpu2
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
800046a2 l     F .text	000000b2 osEE_tc_C_init
00000000 l    df *ABS*	00000000 ee_applcfg.c
b0000004 l     O .lmu_bss	00000004 osEE_kernel_lock
b0000000 l     O .lmu_bss	00000004 osEE_kernel_barrier
80000304 l     O .rodata	00000040 osEE_tdb_ptr_array
800002a0 l     O .rodata	0000000c osEE_counter_db_ptr_array
80000120 l     O .rodata	00000008 osEE_alarm_db_ptr_array
8000011c l     O .rodata	00000004 osEE_st_db_ptr_array
80000544 l     O .rodata	00000038 osEE_sdb_array_core2
500000dc l     O .CPU2.data	0000001c 0x60 osEE_scb_array_core2
500000f8 l     O .CPU2.bss	00000004 0x60 osEE_lock_core2
80000344 l     O .rodata	00000100 osEE_tdb_array_core2
800002ac l     O .rodata	00000014 osEE_counter_db_array_core2
800002e8 l     O .rodata	00000008 osEE_autostart_tdb_array_core2
800000e4 l     O .rodata	00000008 osEE_autostart_trigger_db_core2
50000024 l     O .CPU2.data	00000038 0x60 osEE_sn_array_core2
8000057c l     O .rodata	00000018 osEE_sdb_array_core1
6000007c l     O .CPU1.data	0000000c 0x40 osEE_scb_array_core1
60000088 l     O .CPU1.bss	00000004 0x40 osEE_lock_core1
80000444 l     O .rodata	00000080 osEE_tdb_array_core1
800002c0 l     O .rodata	00000014 osEE_counter_db_array_core1
800002f0 l     O .rodata	00000008 osEE_autostart_tdb_array_core1
800000fc l     O .rodata	00000008 osEE_autostart_trigger_db_core1
60000024 l     O .CPU1.data	00000018 0x40 osEE_sn_array_core1
80000594 l     O .rodata	00000018 osEE_sdb_array_core0
7000009c l     O .CPU0.data	0000000c 0x20 osEE_scb_array_core0
700000a8 l     O .CPU0.bss	00000004 0x20 osEE_lock_core0
800004c4 l     O .rodata	00000080 osEE_tdb_array_core0
800002d4 l     O .rodata	00000014 osEE_counter_db_array_core0
800002fc l     O .rodata	00000008 osEE_autostart_tdb_array_core0
80000104 l     O .rodata	00000008 osEE_autostart_trigger_db_core0
70000044 l     O .CPU0.data	00000018 0x20 osEE_sn_array_core0
800000ec l     O .rodata	00000010 osEE_trigger_autostart_info_core2_OSDEFAULTAPPMODE
80000238 l     O .rodata	00000010 osEE_trigger_db_array_core2
80000104 l     O .rodata	00000000 osEE_trigger_autostart_info_core1_OSDEFAULTAPPMODE
8000010c l     O .rodata	00000010 osEE_trigger_autostart_info_core0_OSDEFAULTAPPMODE
80000290 l     O .rodata	00000010 osEE_trigger_db_array_core0
80000128 l     O .rodata	00000020 osEE_st_db_array_core2
80000274 l     O .rodata	0000001c osEE_alarm_db_array_core0
80000248 l     O .rodata	0000001c osEE_alarm_db_array_core1
500000fc l     O .CPU2.bss	0000000c 0x60 osEE_trigger_cb_array_core2
50000108 l     O .CPU2.bss	00000014 0x60 osEE_st_cb_array_core2
80000148 l     O .rodata	00000078 osEE_expiry_point_array_st_SchedTab1
80000224 l     O .rodata	00000014 osEE_expiry_point_st_SchedTab1_1_action_array
80000210 l     O .rodata	00000014 osEE_expiry_point_st_SchedTab1_2_action_array
800001fc l     O .rodata	00000014 osEE_expiry_point_st_SchedTab1_3_action_array
800001e8 l     O .rodata	00000014 osEE_expiry_point_st_SchedTab1_4_action_array
800001d4 l     O .rodata	00000014 osEE_expiry_point_st_SchedTab1_5_action_array
800001c0 l     O .rodata	00000014 osEE_expiry_point_st_SchedTab1_6_action_array
6000008c l     O .CPU1.bss	0000000c 0x40 osEE_trigger_cb_array_core1
60000098 l     O .CPU1.bss	00000004 0x40 osEE_alarm_cb_array_core1
80000264 l     O .rodata	00000010 osEE_trigger_db_array_core1
700000ac l     O .CPU0.bss	0000000c 0x20 osEE_trigger_cb_array_core0
700000b8 l     O .CPU0.bss	00000004 0x20 osEE_alarm_cb_array_core0
5000011c l     O .CPU2.bss	00000008 0x60 osEE_counter_cb_array_core2
6000009c l     O .CPU1.bss	00000008 0x40 osEE_counter_cb_array_core1
700000bc l     O .CPU0.bss	00000008 0x20 osEE_counter_cb_array_core0
800002f8 l     O .rodata	00000004 osEE_tdb_ptr_autostart_core1_OSDEFAULTAPPMODE
5000005c l     O .CPU2.data	00000080 0x60 osEE_tcb_array_core2
6000003c l     O .CPU1.data	00000040 0x40 osEE_tcb_array_core1
7000005c l     O .CPU0.data	00000040 0x20 osEE_tcb_array_core0
5001a8a8 l     O .CPU2.ustack	00000084 0x60 osEE_task_stack_7
5001a820 l     O .CPU2.ustack	00000084 0x60 osEE_task_stack_8
5001a798 l     O .CPU2.ustack	00000084 0x60 osEE_task_stack_9
5001a710 l     O .CPU2.ustack	00000084 0x60 osEE_task_stack_10
5001a688 l     O .CPU2.ustack	00000084 0x60 osEE_task_stack_11
5001a600 l     O .CPU2.ustack	00000084 0x60 osEE_task_stack_12
6001a708 l     O .CPU1.ustack	00000104 0x40 osEE_task_stack_4
6001a600 l     O .CPU1.ustack	00000104 0x40 osEE_task_stack_5
70018708 l     O .CPU0.ustack	00000104 0x20 osEE_task_stack_1
70018600 l     O .CPU0.ustack	00000104 0x20 osEE_task_stack_2
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
800056ce l     F .text	000000ae osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 Core0.c
80004000 l     F .text	00000208 led_blink
00000000 l    df *ABS*	00000000 Core1.c
00000000 l    df *ABS*	00000000 Core2.c
80004458 l     F .text	00000208 led_blink
00000000 l    df *ABS*	00000000 ee_tc_system.c
80005190 l     F .text	00000054 osEE_tc_stm_us_ticks
70000018 l     O .bss	00000004 osEE_tc_stm_freq_khz
800051e4 l     F .text	0000001c osEE_tc_stm_set_sr0_next_match
80005200 l     F .text	0000007e osEE_tc_stm_set_sr0
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
8000577c l     F .text	0000001e osEE_shutdown_os
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
80007714 l     F .text	00000026 osEE_scheduler_task_insert_rq
00000000 l    df *ABS*	00000000 ee_oo_counter.c
80007e0a l     F .text	000000d4 osEE_handle_action
00000000 l    df *ABS*	00000000 ee_oo_alarm.c
00000000 l    df *ABS*	00000000 ee_ar_sched_table.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_hal_mc.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
80008560 l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 libos_exit.c
8000dbc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_222
8000c000 g     F .inttab_cpu2	00002000 __INTTAB2
8000b820 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_193
80003260 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_147
800021c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_14
8000cfa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_125
8000a3a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_29
80002200 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_16
8000bae0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_215
8000b460 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_163
8000ac40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_98
8000a6a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_53
800028e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_71
80005e96 g     F .text	000000c0 TerminateTask
8000ad00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_104
8000b380 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_156
70000000 g     O .data	00000010 osEE_kcb_var
8000b560 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_171
80003000 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_128
8000ae00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_112
8000b6e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_183
800038e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_199
8000b180 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_140
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_127
80004232 g     F .text	00000012 Func11
80002e80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_116
800037c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_190
8000a2a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_21
8000d320 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_153
8000ce80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_116
8000b280 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_148
8000d6c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_182
00000000 g       *ABS*	00000000 __HEAP_SIZE
80008038 g     F .text	00000066 osEE_alarm_get
800035e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_175
800074e6 g     F .text	0000004c osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
8000a220 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_17
80004754 g     F .text	000003dc osEE_tc_core0_start
800027e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_63
8000c5c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_46
800042aa g     F .text	00000008 Func311
80002380 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_28
8000c600 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_48
8000c560 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_43
80003320 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_153
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
8000cac0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_86
8000a800 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_64
70000000 g       *ABS*	00000000 __DSPR0_START
80007f6a g     F .text	0000006e osEE_alarm_set_abs
8000cb20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_89
80003920 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_201
800085c0 g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
8000c100 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_8
8000a740 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_58
80003f80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_252
800082e8 g     F .text	00000028 osEE_change_context_from_running
80003b00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_216
80003c80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_228
80002080 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_4
70000020 g     O .CPU0.data	00000024 0x20 osEE_ccb_var_core0
8000d140 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_138
80003580 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_172
8000b5a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_173
8000ab60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_91
8000df00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_248
8000b540 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_170
80002840 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_66
8000dae0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_215
8000d600 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_176
8000432e g     F .text	0000000c FuncTaskCpu0
80006254 g     F .text	000000ea SetRelAlarm
80002280 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_20
8000be20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_241
8000421e g     F .text	0000000a Func111
8000df60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_251
8000c940 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_74
8000d2c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_150
8000ce20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_113
80006756 g     F .text	00000110 SetEvent
8000a240 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_18
80002d00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_104
8000d0c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_134
800071bc g     F .text	0000000e GetNumberOfActivatedCores
8000a600 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_48
80002800 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_64
50000000 g     O .CPU2.data	00000024 0x60 osEE_ccb_var_core2
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_221
800030c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_134
800073ec g     F .text	00000048 osEE_scheduler_task_wrapper_restore
80003e60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_243
70019600 g     O .CPU0.ustack	00000000 __USTACK0
800023a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_29
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_125
80002e60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_115
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
8000dc20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_225
8000a000 g     F .inttab_cpu1	00002000 __INTTAB1
8000d9c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_206
8000ccc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_102
8000b400 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_160
8000ad40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_106
8000d8e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_199
80002980 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_76
8000ab80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_92
80003040 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_130
8000a0a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_5
80002700 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_56
800022a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_21
800057ee g     F .text	00000056 SuspendAllInterrupts
8000b600 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_176
00001000 g       *ABS*	00000000 __USTACK0_SIZE
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_93
8000bca0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_229
8000bc80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_228
8000bbe0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_223
8000862e g     F .text	00000066 osEE_hal_terminate_ctx
800075a4 g     F .text	00000048 osEE_sn_priority_insert
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_229
8000c920 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_73
8000616c g     F .text	000000e8 GetTaskState
80003120 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_137
80007680 g     F .text	00000072 osEE_task_event_set_mask
8000c6a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_53
8000d4c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_166
8000c700 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_56
8000cc40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_98
8000cba0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_93
8000c260 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_19
8000d260 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_147
80003440 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_162
8000aa80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_84
8000a520 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_41
5001dc00 g     O .CPU2.csa	00000000 __CSA2_END
80004208 g     F .text	00000006 Func121
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
8000af20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_121
80003400 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_160
8000427a g     F .text	00000006 Func212
800064e2 g     F .text	000000cc GetAlarm
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
8000b2c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_150
80000760 g       .traptab	00000000 osEE_tc_trap_context
8000c4a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_37
8000d6e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_183
8000d700 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_184
8000a300 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_24
8000b140 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_138
80003f60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_251
8000c7a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_61
8000433a g     F .text	00000016 ErrorHook
800029a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_77
8000ac20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_97
8000a680 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_52
80003d40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_234
8000cda0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_109
80002420 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_33
80002f40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_122
80002460 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_35
800071ca g     F .text	000000a2 StartCore
8000dd00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_232
8000d200 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_144
8000d5c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_174
800039a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_205
80006936 g     F .text	000000a2 ClearEvent
80002c40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_98
8000a860 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_67
8000bb40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_218
800035c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_174
80007434 g     F .text	000000b2 osEE_scheduler_task_wrapper_run
800042e4 g     F .text	0000000e Func32
8000bb20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_217
8000ace0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_103
800034e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_167
8000d280 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_148
8000cd80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_108
8000d1e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_143
80003e40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_242
8000d5a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_173
8000d0a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_133
8000a480 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_36
8000a140 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_10
8000b640 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_178
80003380 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_156
80007a10 g     F .text	0000003e osEE_scheduler_task_preemption_point
8000b680 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_180
80002b00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_88
80003240 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_146
8000bd20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_233
8000d6a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_181
80002560 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_43
8000b220 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_145
8000b0e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_135
800069d8 g     F .text	000000ba GetCounterValue
8000dc60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_227
80002480 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_36
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_222
800075ec g     F .text	0000000e osEE_scheduler_rq_insert
80003020 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_129
8000466a g     F .text	0000000a FuncTASK_5MS
80000810 g       .dtors	00000000 __DTOR_END__
80008330 g     F .text	00000026 osEE_idle_task_terminate
8000ad60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_107
80004280 g     F .text	0000000e Func21
8000bda0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_237
8000c340 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_26
8000c060 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_3
8000ac80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_100
80003620 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_177
8000c8a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_69
8000c860 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_67
80003c60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_227
8000c300 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_24
8000d0e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_135
8000c3a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_29
800035a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_173
8000a5e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_47
8000b0c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_134
8000b4c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_166
8000a920 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_73
800078ce g     F .text	000000a0 osEE_scheduler_task_unblocked
8000bfe0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_255
8000da60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_211
8000825a g     F .text	0000008e osEE_st_syncronize
80003700 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_184
80002340 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_26
8000a4a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_37
00000000 g       *ABS*	00000000 NULL
800052ae g     F .text	0000004a osEE_tc_initialize_system_timer
800036c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_182
80002a60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_83
80002600 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_48
80002b20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_89
800031a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_141
80000740 g       .traptab	00000000 osEE_tc_trap_instruction
80002d80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_108
80002580 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_44
80003280 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_148
8000d8c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_198
800042ba g     F .text	0000000e Func31
80002120 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_9
8000ce00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_112
80004306 g     F .text	00000008 Func3
80003da0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_237
8000db00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_216
8000b940 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_202
8000db60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_219
80006f04 g     F .text	000000aa GetScheduleTableStatus
8000dd20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_233
80003780 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_188
800084e6 g     F .text	0000002c osEE_get_core
8000c020 g       .inttab_cpu2	00000000 osEE_tc_core2_isr2_entry_1
8000d300 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_152
8000ce60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_115
800085e4 g     F .text	0000002c osEE_hal_ready2stacked
80002de0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_111
8000b200 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_144
8000d160 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_139
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_103
80004434 g     F .text	00000014 FuncTask2
80005f56 g     F .text	000000d6 Schedule
80002060 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_3
8000c660 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_51
8000b720 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_185
8000a940 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_74
8000b1c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_142
8000b4a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_165
8000cc00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_96
80002740 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_58
8000b860 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_195
8000da20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_209
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_118
80003800 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_192
8000bea0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_245
80004696 g     F .text	0000000c FuncTASK_100MS
8000dc80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_228
8000ad80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_108
80002be0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_95
8000c4e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_39
8000a2e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_23
8000d680 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_180
8000b3c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_158
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
8000d220 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_145
8000de60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_243
8000a100 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_8
8000ba20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_209
8000dde0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_239
8000b6a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_181
8000d620 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_177
80003e80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_244
80002020 g       .inttab_cpu0	00000000 osEE_tc_core0_isr2_entry_1
80003f20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_249
800007a0 g       .traptab	00000000 osEE_tc_trap_assertion
80003360 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_155
8000a840 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_66
8000c440 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_34
8000c3e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_31
80002260 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_19
8000b040 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_130
80008000 g       *ABS*	00000000 __A1_MEM
8000c980 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_76
8000c9e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_79
8000b240 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_146
80002940 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_74
80005c68 g     F .text	00000022 GetActiveApplicationMode
80002d20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_105
80006c6e g     F .text	000000f2 StartScheduleTableRel
80005844 g     F .text	00000040 ResumeAllInterrupts
8000b9a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_205
8000c740 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_58
8000c640 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_50
8000c1e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_15
80003860 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_195
8000cbe0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_95
70019c00 g     O .CPU0.csa	00000000 __CSA0
80008144 g     F .text	0000008c osEE_st_start_abs
80002760 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_59
80002c00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_96
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_254
8000d020 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_129
8000dfa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_253
8000d880 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_196
8000ba60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_211
8000dee0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_247
70008000 g       *ABS*	00000000 __A0_MEM
80003c00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_224
80007532 g     F .text	00000072 osEE_scheduler_core_rq_preempt_stk
8000d420 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_161
6001dc00 g     O .CPU1.csa	00000000 __CSA1_END
8000d440 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_162
8000cf20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_121
8000c500 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_40
800037a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_189
80005c8a g     F .text	000000dc ActivateTask
8000b8a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_197
8000ca60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_83
8000ca20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_81
80002140 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_10
8000cfc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_126
80002180 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_12
8000bd80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_236
8000df40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_250
8000b160 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_139
8000bf80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_252
8000bd60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_235
8000d8a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_197
8000abc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_94
8000ae20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_113
800028a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_69
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
800072fa g     F .text	000000f0 ShutdownAllCores
80003080 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_132
800060aa g     F .text	000000c2 GetTaskID
8000aaa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_85
8000a540 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_42
8000af00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_120
8000a060 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_3
80002f80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_124
80003980 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_204
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_110
8000afa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_125
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
800020c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_6
80003140 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_138
80005884 g     F .text	0000006a SuspendOSInterrupts
8000d520 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_169
800055ca g     F .text	00000034 osEE_tc_stm_set_clockpersec
8000db40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_218
800027a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_61
80007a4e g     F .text	00000058 osEE_scheduler_task_set_running
8000c5a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_45
b0008000 g       *ABS*	00000000 _SMALL_DATA4_
800055fe g     F .text	0000008a osEE_tc_stm_set_sr1
8000cb00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_88
8000ca00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_80
80003a20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_209
800032e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_151
80003720 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_185
8000dea0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_245
80007b5c g     F .text	000002ae osEE_counter_increment
80003a60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_211
8000a340 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_26
8000bd00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_232
8000ac60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_99
8000a6c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_54
8000773a g     F .text	000000d2 osEE_scheduler_task_activated
8000c0c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_6
8000bb60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_219
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
80003b20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_217
6001a810 g     O .CPU1.ustack	00000000 __USTACK1_END
80006d60 g     F .text	000000e6 StartScheduleTableAbs
8000d580 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_172
8000b660 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_179
8000a8a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_69
8000b020 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_129
80003e20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_241
80004228 g     F .text	0000000a Func112
8000d180 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_140
8000d740 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_186
8000bb80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_220
8000cd20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_105
8000af40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_122
8000d100 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_136
8000a1c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_14
8000c140 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_10
8000b980 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_204
80003be0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_223
8000cb40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_90
8000c200 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_16
8000468a g     F .text	0000000c FuncTASK_50MS
8000dce0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_231
800027c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_62
8000b6c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_182
80002360 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_27
800033c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_158
800039c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_206
8000d3a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_157
80004266 g     F .text	0000000e Func13
80003340 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_154
8000b840 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_194
8000be40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_242
8000d060 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_131
8000db80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_220
8000be80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_244
8000b7a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_189
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_255
80002d60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_107
8000a7a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_61
800036a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_181
8000b440 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_162
8000b260 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_147
8000a6e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_55
8000b3a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_157
80003640 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_178
80003160 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_139
8000aca0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_101
8000d7e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_191
8000796e g     F .text	000000a2 osEE_scheduler_task_terminated
800034c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_166
800026c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_54
80006424 g     F .text	000000be CancelAlarm
80002b60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_91
8000b120 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_137
8000c3c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_30
800031c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_142
8000bc60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_227
8000c960 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_75
80004e60 g     F .text	00000330 osEE_tc_core2_start
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
8000a260 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_19
80004448 g     F .text	00000010 FuncTask3
80004b30 g     F .text	00000330 osEE_tc_core1_start
8000a620 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_49
8000dec0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_246
800024e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_39
80003c20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_225
80000800 g       .ctors	00000000 __CTOR_LIST__
8000c6e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_55
8000b500 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_168
80005526 g     F .text	000000a4 osEE_tc_get_fsource
8000b1e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_143
8000a4e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_39
8000d980 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_204
8000c480 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_36
8000bf20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_249
80008610 g     F .text	0000001e osEE_tc_change_context_from_isr2_end
8000d940 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_202
8000a760 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_59
8000cfe0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_127
8000b480 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_164
8000c7e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_63
8000c280 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_20
800071a8 g     F .text	00000014 GetISRID
8000b8e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_199
80002960 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_75
80008582 g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
80004674 g     F .text	0000000a FuncTASK_10MS
8000aba0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_93
80003d80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_236
80007ee0 g     F .text	0000008a osEE_alarm_set_rel
8000de40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_242
800023e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_31
8000a3e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_31
800026e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_55
80000780 g       .traptab	00000000 osEE_tc_trap_bus
8000430e g     F .text	00000020 FuncTaskM
8000dd60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_235
80002040 g       .inttab_cpu0	00000000 osEE_tc_core0_isr2_entry_2
80002f60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_123
80002f00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_120
8000dca0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_229
80008512 g     F .text	0000004e osEE_hal_start_core
80000020 g     F .startup	00000006 _start
80002b80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_92
8000dba0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_221
800032a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_149
80002e20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_113
80002d40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_106
8000cd00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_104
80003680 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_180
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800007e0 g       .traptab	00000000 osEE_tc_trap_nmi
80003a80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_212
80003d00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_232
8000aea0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_117
8000d2a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_149
80004256 g     F .text	00000008 Func131
8000c040 g       .inttab_cpu2	00000000 osEE_tc_core2_isr2_entry_2
8000a980 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_76
8000b920 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_201
8000aa20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_81
00002000 g       *ABS*	00000000 __CSA_SIZE
8000d660 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_179
8000d040 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_130
5001bc00 g     O .CPU2.csa	00000000 __CSA2
80002a40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_82
8000a1a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_13
80008470 g     F .text	00000076 osEE_hal_sync_barrier
800025e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_47
800032c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_150
80000084 g     O .rodata	00000030 osEE_cdb_var_core1
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_86
80002520 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_41
8000a320 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_25
8000c7c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_62
8000c780 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_60
80002400 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_32
80003540 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_170
8000a0c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_6
80002440 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_34
00000001 g       *ABS*	00000000 _.
80003a00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_208
8000d5e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_175
8000a880 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_68
8000ad20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_105
8000d920 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_201
8000bde0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_239
8000cca0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_101
8000c380 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_28
8000c840 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_66
8000c2e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_23
8000d800 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_192
80003560 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_171
8000b080 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_132
80000800 g       .ctors	00000000 __EH_FRAME_END__
6001bb00 g     O .CPU1.istack	00000000 __ISTACK1
8000a420 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_33
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_245
800039e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_207
80003760 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_187
80002300 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_24
8000d360 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_155
8000cec0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_118
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_87
800075fa g     F .text	00000028 osEE_scheduler_core_pop_running
8000a780 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_60
8000c8c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_70
80002540 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_42
80008356 g     F .text	0000011a osEE_cpu_startos
8000bac0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_214
800020e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_7
8000d840 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_194
8000b8c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_198
800030a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_133
8000df20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_249
80003460 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_163
800042f2 g     F .text	0000000c Func1
80003de0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_239
8000d4a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_165
80006866 g     F .text	000000d0 GetEvent
80003d60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_235
8000a9c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_78
8000b9c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_206
8000dac0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_214
70000010 g     O .bss	00000004 myErrorCounter
6001b600 g     O .CPU1.ustack	00000000 __USTACK1
80004274 g     F .text	00000006 Func211
8000d340 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_154
8000cea0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_117
8000780c g     F .text	00000080 osEE_scheduler_task_insert
8000bbc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_222
800042d6 g     F .text	0000000e Func322
8000602c g     F .text	0000007e ShutdownOS
70018810 g     O .CPU0.ustack	00000000 __USTACK0_END
8000aae0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_87
8000a580 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_44
8000d7c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_190
8000b580 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_172
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_231
8000c180 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_12
8000ae60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_115
8000d480 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_164
8000cf40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_122
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_126
8000a4c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_38
800033a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_157
8000a8c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_70
80002320 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_25
80002680 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_52
80000000 g       .startup	00000000 BootModeHeader0
8000c0e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_7
800007c0 g       .traptab	00000000 osEE_tc_trap_system
8000af80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_124
8000aec0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_118
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_213
8000b5e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_175
00002000 g       *ABS*	00000000 __CSA0_SIZE
8000a040 g       .inttab_cpu1	00000000 osEE_tc_core1_isr2_entry_2
8000ade0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_111
80003500 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_168
8000cd60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_107
8000d1c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_142
8000a3c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_30
8000c420 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_33
8000bec0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_246
80003900 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_200
80004350 g     F .text	000000e4 main
8000a380 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_28
8000c9c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_78
800021e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_15
80002220 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_17
8000af60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_123
80002900 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_72
80000054 g     O .rodata	00000030 osEE_cdb_var_core2
00000400 g       *ABS*	00000000 __ISTACK_SIZE
8000c680 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_52
8000c720 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_57
80003820 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_193
8000a960 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_75
8000aa00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_80
8000cc20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_97
80007622 g     F .text	00000040 osEE_task_activated
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_119
8000420e g     F .text	00000008 Func122
80002720 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_57
5001bb00 g     O .CPU2.istack	00000000 __ISTACK2
80000028 g     O .rodata	0000002c osEE_kdb_var
800033e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_159
8000d9a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_205
8000a280 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_20
8000dc00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_224
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_94
80003b60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_219
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
8000cce0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_103
8000b420 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_161
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000bf40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_250
8000a200 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_16
8000baa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_213
8000bee0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_247
80007aa8 g     F .text	00000062 osEE_counter_insert_abs_trigger
8000d4e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_167
80008000 g       *ABS*	00000000 __A8_MEM
b0008000 g       *ABS*	00000000 __A9_MEM
8000c540 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_42
80004660 g     F .text	0000000a FuncTASK_1MS
8000b880 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_196
8000caa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_85
8000b2e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_151
8000a7e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_63
80002240 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_18
80002e00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_112
8000d000 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_128
8000cf60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_123
80002da0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_109
800036e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_183
8000a720 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_57
80002920 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_73
8000aee0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_119
80000808 g       .ctors	00000000 __CTOR_END__
8000cde0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_111
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
8000ab40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_90
50000000 g       *ABS*	00000000 __DSPR2_START
80003100 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_136
80002860 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_67
8000db20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_217
8000dda0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_237
8000bfc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_254
8000b3e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_159
8000dd40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_234
80000808 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
00001000 g       *ABS*	00000000 __USTACK1_SIZE
800081d0 g     F .text	0000008a osEE_st_stop
80003200 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_144
800042c8 g     F .text	0000000e Func321
8000cc80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_100
60000000 g     O .CPU1.data	00000024 0x40 osEE_ccb_var_core1
80002820 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_65
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_238
8000b4e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_167
800042b2 g     F .text	00000008 Func312
8000c580 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_44
8000adc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_110
8000c5e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_47
8000c620 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_49
8000c520 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_41
8000d3c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_158
8000cae0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_87
8000ca80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_84
8000ca40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_82
80002e40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_114
8000bd40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_234
8000d820 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_193
8000abe0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_95
8000a640 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_50
80003480 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_164
800042fe g     F .text	00000008 Func2
8000425e g     F .text	00000008 Func132
8000de80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_244
8000a120 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_9
80002880 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_68
8000aac0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_86
8000a560 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_43
8000b1a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_141
8000bcc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_230
800022c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_22
8000d540 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_170
8000dbe0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_223
8000afe0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_127
8000d760 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_187
80006a92 g     F .text	000000e4 GetElapsedValue
8000bc00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_224
8000c900 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_72
80002100 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_8
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_215
8000d120 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_137
800070ca g     F .text	000000de SyncScheduleTable
800034a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_165
8000b9e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_207
8000cb80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_92
8000c240 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_18
8000ae40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_114
80002780 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_60
8000aa60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_83
8000a500 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_40
800065ae g     F .text	000000be GetAlarmBase
8000d3e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_159
00002000 g       *ABS*	00000000 __CSA1_SIZE
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_253
80003f40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_250
8000579a g     F .text	0000001e DisableAllInterrupts
8000a360 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_27
5001a930 g     O .CPU2.ustack	00000000 __USTACK2_END
80003220 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_145
00001000 g       *ABS*	00000000 __USTACK_SIZE
8000b7e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_191
80003600 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_176
8000809e g     F .text	000000a6 osEE_st_start_rel
8000acc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_102
80005d66 g     F .text	00000130 ChainTask
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_101
800029c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_78
8000ac00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_96
8000a660 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_51
8000b340 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_154
8000b060 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_131
8000b520 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_169
8000da40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_210
8000788c g     F .text	00000042 osEE_scheduler_task_block_current
8000d640 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_178
80006fae g     F .text	0000011c NextScheduleTable
80002c60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_99
8000bba0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_221
8000c080 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_4
8000bc40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_226
80006e46 g     F .text	000000be StopScheduleTable
8000527e g     F .text	00000030 osEE_tricore_system_timer_handler
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
8000ba40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_210
8000dd80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_236
8000a1e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_15
80003b80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_220
800028c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_70
8000c6c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_54
8000d900 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_200
80003c40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_226
8000c160 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_11
8000cc60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_99
80000700 g       .traptab	00000000 osEE_tc_trap_mmu
8000cb60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_91
8000c220 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_17
80003840 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_194
8000726c g     F .text	0000008e StartNonAutosarCore
800056a6 g     F .text	00000028 osEE_tc_delay
80004244 g     F .text	00000012 Func12
80004216 g     F .text	00000008 Func123
800005ac g     O .rodata	00000000 __clear_table
8000a460 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_35
8000c460 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_35
8000a7c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_62
80007662 g     F .text	0000001e osEE_task_end
8000467e g     F .text	0000000c FuncTASK_20MS
8000c4c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_38
80003b40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_218
8000428e g     F .text	00000006 Func221
8000cf80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_124
8000a700 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_56
80003660 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_179
80000800 g       .ctors	00000000 __EH_FRAME_BEGIN__
800024a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_37
8000b0a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_133
80007b0a g     F .text	00000022 osEE_counter_insert_rel_trigger
8000d460 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_163
80003f00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_248
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_230
800026a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_53
80008310 g     F .text	00000020 osEE_change_context_from_task_end
800037e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_191
8000bce0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_231
80003300 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_152
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_117
8000666c g     F .text	000000ea WaitEvent
8000da00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_208
8000b7c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_190
80002b40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_90
8000d7a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_189
8000429c g     F .text	0000000e Func22
800031e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_143
8000bf60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_251
80003a40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_210
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_214
8000bfa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_253
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_102
8000de00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_240
80003520 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_169
8000b320 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_153
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
8000b5c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_174
8000ab20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_89
8000a5c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_46
80006b76 g     F .text	000000f8 IncrementCounter
800024c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_38
800038a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_197
8000d1a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_141
8000cf00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_120
5001b600 g     O .CPU2.ustack	00000000 __USTACK2
8000d240 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_146
8000cd40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_106
80007fd8 g     F .text	00000060 osEE_alarm_cancel
8000a900 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_72
80005688 g     F .text	0000001e osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80000020 g       .startup	00000000 BootModeIndex
8000a160 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_11
800025a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_45
8000a180 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_12
800000b4 g     O .rodata	00000030 osEE_cdb_var_core0
80002a80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_84
80002620 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_49
80002a00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_80
8000afc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_126
8000c800 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_64
80007b2c g     F .text	00000030 osEE_counter_cancel_trigger
8000c2a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_21
8000a0e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_7
800076f2 g     F .text	00000022 osEE_activate_isr2
800023c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_30
8000b700 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_184
8000d400 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_160
8000a400 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_32
8000b620 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_177
8000d380 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_156
8000cee0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_119
8000b300 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_152
80020000 g       .startup	00000000 BootModeHeader1
800052f8 g     F .text	0000022e osEE_tc_set_pll_fsource
8000b800 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_192
8000b2a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_149
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
8000dfe0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_255
8000c820 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_65
8000df80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_252
8000c360 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_27
8000c320 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_25
8000c0a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_5
8000c2c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_22
8000c880 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_68
8000b360 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_155
8000d500 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_168
80000614 g     O .rodata	00000000 __copy_table
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
80003d20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_233
8000bdc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_238
8000a9a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_77
8000a080 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_4
8000daa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_213
8000aa40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_82
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_247
80003740 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_186
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
8000dc40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_226
800025c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_46
8000a2c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_22
80003960 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_203
80008694 g     F .text	00000010 _exit
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_85
8000b780 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_188
80000720 g       .traptab	00000000 osEE_tc_trap_protection
80000700 g     F .traptab	00000000 __TRAPTAB
80002500 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_40
80002a20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_81
00002000 g       *ABS*	00000000 __CSA2_SIZE
800020a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_5
80002c80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_100
8000bb00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_216
80003060 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_131
8000b900 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_200
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
8000ddc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_238
8000dcc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_230
8000d560 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_171
8000d080 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_132
8000a820 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_65
80003e00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_240
8000bc20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_225
8000ada0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_109
8000ba80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_212
8000de20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_241
70000020 g       .inttab_cpu2	00000000 __HEAP_END
8000c1c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_14
800038c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_198
8000cbc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_94
8000b740 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_186
80002f20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_121
6001bc00 g     O .CPU1.csa	00000000 __CSA1
80003420 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_161
800057b8 g     F .text	00000036 EnableAllInterrupts
800022e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_23
8000a440 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_34
80002c20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_97
8000cdc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_110
80002640 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_50
8000be60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_243
8000d780 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_188
8000c8e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_71
8000c120 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_9
8000ae80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_116
800085a6 g     F .text	0000001a osEE_hal_restore_ctx
8000b000 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_128
8000b100 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_136
8000a020 g       .inttab_cpu1	00000000 osEE_tc_core1_isr2_entry_1
800030e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_135
70008000 g     O *ABS*	00000000 _SMALL_DATA_
8000a9e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_79
8000da80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_212
8000d9e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_207
8000bf00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_248
8000c400 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_32
80003940 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_202
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
80002160 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_11
8000c9a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_77
800021a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_13
80003180 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_140
8000b960 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_203
800058ee g     F .text	00000046 ResumeOSInterrupts
8000ba00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_208
8000ab00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_88
8000a5a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_45
8000c760 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_59
8000be00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_240
8000c1a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_13
80003880 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_196
8000a8e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_71
8000dfc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_254
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_246
80002660 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_51
8000d960 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_203
8000633e g     F .text	000000e6 SetAbsAlarm
8000d720 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_185
80005934 g     F .text	00000334 StartOS
80004294 g     F .text	00000008 Func222
8000b760 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_187
800029e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_79
8000d860 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_195
8000d2e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_151
8000ce40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_114
80008000 g     O *ABS*	00000000 _SMALL_DATA3_



Disassembly of section .startup:

80000020 <_start>:
#if defined(__DCC__)
#pragma section CODE ".startup" X
#endif

void _start(void)
{
80000020:	9d 80 aa 23 	ja 80004754 <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80000700 <__TRAPTAB>:
80000700:	00 a0       	debug 
80000702:	1d ff ff ff 	j 80000700 <__TRAPTAB>
	...

80000720 <osEE_tc_trap_protection>:
80000720:	00 a0       	debug 
80000722:	1d ff ff ff 	j 80000720 <osEE_tc_trap_protection>
	...

80000740 <osEE_tc_trap_instruction>:
80000740:	00 a0       	debug 
80000742:	1d ff ff ff 	j 80000740 <osEE_tc_trap_instruction>
	...

80000760 <osEE_tc_trap_context>:
80000760:	00 a0       	debug 
80000762:	1d ff ff ff 	j 80000760 <osEE_tc_trap_context>
	...

80000780 <osEE_tc_trap_bus>:
80000780:	00 a0       	debug 
80000782:	1d ff ff ff 	j 80000780 <osEE_tc_trap_bus>
	...

800007a0 <osEE_tc_trap_assertion>:
800007a0:	00 a0       	debug 
800007a2:	1d ff ff ff 	j 800007a0 <osEE_tc_trap_assertion>
	...

800007c0 <osEE_tc_trap_system>:
800007c0:	00 a0       	debug 
800007c2:	1d ff ff ff 	j 800007c0 <osEE_tc_trap_system>
	...

800007e0 <osEE_tc_trap_nmi>:
800007e0:	00 a0       	debug 
800007e2:	1d ff ff ff 	j 800007e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80000800 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80000808 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_core0_isr2_entry_1>:
80002020:	0d 00 00 02 	svlcx 
80002024:	82 f4       	mov %d4,-1
80002026:	1d 00 54 1b 	j 800056ce <osEE_tc_isr2_wrapper>
	...

80002040 <osEE_tc_core0_isr2_entry_2>:
80002040:	0d 00 00 02 	svlcx 
80002044:	82 04       	mov %d4,0
80002046:	1d 00 44 1b 	j 800056ce <osEE_tc_isr2_wrapper>
	...

80002060 <osEE_tc_core0_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_core0_isr_dummy_entry_3>
	...

80002080 <osEE_tc_core0_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_core0_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_core0_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_core0_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_core0_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_core0_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_core0_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_core0_isr_dummy_entry_7>
	...

80002100 <osEE_tc_core0_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_core0_isr_dummy_entry_8>
	...

80002120 <osEE_tc_core0_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_core0_isr_dummy_entry_9>
	...

80002140 <osEE_tc_core0_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_core0_isr_dummy_entry_10>
	...

80002160 <osEE_tc_core0_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_core0_isr_dummy_entry_11>
	...

80002180 <osEE_tc_core0_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_core0_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_core0_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_core0_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_core0_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_core0_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_core0_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_core0_isr_dummy_entry_15>
	...

80002200 <osEE_tc_core0_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_core0_isr_dummy_entry_16>
	...

80002220 <osEE_tc_core0_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_core0_isr_dummy_entry_17>
	...

80002240 <osEE_tc_core0_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_core0_isr_dummy_entry_18>
	...

80002260 <osEE_tc_core0_isr_dummy_entry_19>:
80002260:	3c 00       	j 80002260 <osEE_tc_core0_isr_dummy_entry_19>
	...

80002280 <osEE_tc_core0_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_core0_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_core0_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_core0_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_core0_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_core0_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_core0_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_core0_isr_dummy_entry_23>
	...

80002300 <osEE_tc_core0_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_core0_isr_dummy_entry_24>
	...

80002320 <osEE_tc_core0_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_core0_isr_dummy_entry_25>
	...

80002340 <osEE_tc_core0_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_core0_isr_dummy_entry_26>
	...

80002360 <osEE_tc_core0_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_core0_isr_dummy_entry_27>
	...

80002380 <osEE_tc_core0_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_core0_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_core0_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_core0_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_core0_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_core0_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_core0_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_core0_isr_dummy_entry_31>
	...

80002400 <osEE_tc_core0_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_core0_isr_dummy_entry_32>
	...

80002420 <osEE_tc_core0_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_core0_isr_dummy_entry_33>
	...

80002440 <osEE_tc_core0_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_core0_isr_dummy_entry_34>
	...

80002460 <osEE_tc_core0_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_core0_isr_dummy_entry_35>
	...

80002480 <osEE_tc_core0_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_core0_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_core0_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_core0_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_core0_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_core0_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_core0_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_core0_isr_dummy_entry_39>
	...

80002500 <osEE_tc_core0_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_core0_isr_dummy_entry_40>
	...

80002520 <osEE_tc_core0_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_core0_isr_dummy_entry_41>
	...

80002540 <osEE_tc_core0_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_core0_isr_dummy_entry_42>
	...

80002560 <osEE_tc_core0_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_core0_isr_dummy_entry_43>
	...

80002580 <osEE_tc_core0_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_core0_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_core0_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_core0_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_core0_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_core0_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_core0_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_core0_isr_dummy_entry_47>
	...

80002600 <osEE_tc_core0_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_core0_isr_dummy_entry_48>
	...

80002620 <osEE_tc_core0_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_core0_isr_dummy_entry_49>
	...

80002640 <osEE_tc_core0_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_core0_isr_dummy_entry_50>
	...

80002660 <osEE_tc_core0_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_core0_isr_dummy_entry_51>
	...

80002680 <osEE_tc_core0_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_core0_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_core0_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_core0_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_core0_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_core0_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_core0_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_core0_isr_dummy_entry_55>
	...

80002700 <osEE_tc_core0_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_core0_isr_dummy_entry_56>
	...

80002720 <osEE_tc_core0_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_core0_isr_dummy_entry_57>
	...

80002740 <osEE_tc_core0_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_core0_isr_dummy_entry_58>
	...

80002760 <osEE_tc_core0_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_core0_isr_dummy_entry_59>
	...

80002780 <osEE_tc_core0_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_core0_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_core0_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_core0_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_core0_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_core0_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_core0_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_core0_isr_dummy_entry_63>
	...

80002800 <osEE_tc_core0_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_core0_isr_dummy_entry_64>
	...

80002820 <osEE_tc_core0_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_core0_isr_dummy_entry_65>
	...

80002840 <osEE_tc_core0_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_core0_isr_dummy_entry_66>
	...

80002860 <osEE_tc_core0_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_core0_isr_dummy_entry_67>
	...

80002880 <osEE_tc_core0_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_core0_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_core0_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_core0_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_core0_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_core0_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_core0_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_core0_isr_dummy_entry_71>
	...

80002900 <osEE_tc_core0_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_core0_isr_dummy_entry_72>
	...

80002920 <osEE_tc_core0_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_core0_isr_dummy_entry_73>
	...

80002940 <osEE_tc_core0_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_core0_isr_dummy_entry_74>
	...

80002960 <osEE_tc_core0_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_core0_isr_dummy_entry_75>
	...

80002980 <osEE_tc_core0_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_core0_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_core0_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_core0_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_core0_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_core0_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_core0_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_core0_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_core0_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_core0_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_core0_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_core0_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_core0_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_core0_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_core0_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_core0_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_core0_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_core0_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_core0_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_core0_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_core0_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_core0_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_core0_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_core0_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_core0_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_core0_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_core0_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_core0_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_core0_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_core0_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_core0_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_core0_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_core0_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_core0_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_core0_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_core0_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_core0_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_core0_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_core0_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_core0_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_core0_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_core0_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_core0_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_core0_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_core0_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_core0_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_core0_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_core0_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_core0_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_core0_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_core0_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_core0_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_core0_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_core0_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_core0_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_core0_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_core0_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_core0_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_core0_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_core0_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_core0_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_core0_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_core0_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_core0_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_core0_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_core0_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_core0_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_core0_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_core0_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_core0_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_core0_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_core0_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_core0_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_core0_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_core0_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_core0_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_core0_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_core0_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_core0_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_core0_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_core0_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_core0_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_core0_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_core0_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_core0_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_core0_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_core0_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_core0_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_core0_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_core0_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_core0_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_core0_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_core0_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_core0_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_core0_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_core0_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_core0_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_core0_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_core0_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_core0_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_core0_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_core0_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_core0_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_core0_isr_dummy_entry_127>
	...

80003000 <osEE_tc_core0_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_core0_isr_dummy_entry_128>
	...

80003020 <osEE_tc_core0_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_core0_isr_dummy_entry_129>
	...

80003040 <osEE_tc_core0_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_core0_isr_dummy_entry_130>
	...

80003060 <osEE_tc_core0_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_core0_isr_dummy_entry_131>
	...

80003080 <osEE_tc_core0_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_core0_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_core0_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_core0_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_core0_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_core0_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_core0_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_core0_isr_dummy_entry_135>
	...

80003100 <osEE_tc_core0_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_core0_isr_dummy_entry_136>
	...

80003120 <osEE_tc_core0_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_core0_isr_dummy_entry_137>
	...

80003140 <osEE_tc_core0_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_core0_isr_dummy_entry_138>
	...

80003160 <osEE_tc_core0_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_core0_isr_dummy_entry_139>
	...

80003180 <osEE_tc_core0_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_core0_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_core0_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_core0_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_core0_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_core0_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_core0_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_core0_isr_dummy_entry_143>
	...

80003200 <osEE_tc_core0_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_core0_isr_dummy_entry_144>
	...

80003220 <osEE_tc_core0_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_core0_isr_dummy_entry_145>
	...

80003240 <osEE_tc_core0_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_core0_isr_dummy_entry_146>
	...

80003260 <osEE_tc_core0_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_core0_isr_dummy_entry_147>
	...

80003280 <osEE_tc_core0_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_core0_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_core0_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_core0_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_core0_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_core0_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_core0_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_core0_isr_dummy_entry_151>
	...

80003300 <osEE_tc_core0_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_core0_isr_dummy_entry_152>
	...

80003320 <osEE_tc_core0_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_core0_isr_dummy_entry_153>
	...

80003340 <osEE_tc_core0_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_core0_isr_dummy_entry_154>
	...

80003360 <osEE_tc_core0_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_core0_isr_dummy_entry_155>
	...

80003380 <osEE_tc_core0_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_core0_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_core0_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_core0_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_core0_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_core0_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_core0_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_core0_isr_dummy_entry_159>
	...

80003400 <osEE_tc_core0_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_core0_isr_dummy_entry_160>
	...

80003420 <osEE_tc_core0_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_core0_isr_dummy_entry_161>
	...

80003440 <osEE_tc_core0_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_core0_isr_dummy_entry_162>
	...

80003460 <osEE_tc_core0_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_core0_isr_dummy_entry_163>
	...

80003480 <osEE_tc_core0_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_core0_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_core0_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_core0_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_core0_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_core0_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_core0_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_core0_isr_dummy_entry_167>
	...

80003500 <osEE_tc_core0_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_core0_isr_dummy_entry_168>
	...

80003520 <osEE_tc_core0_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_core0_isr_dummy_entry_169>
	...

80003540 <osEE_tc_core0_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_core0_isr_dummy_entry_170>
	...

80003560 <osEE_tc_core0_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_core0_isr_dummy_entry_171>
	...

80003580 <osEE_tc_core0_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_core0_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_core0_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_core0_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_core0_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_core0_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_core0_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_core0_isr_dummy_entry_175>
	...

80003600 <osEE_tc_core0_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_core0_isr_dummy_entry_176>
	...

80003620 <osEE_tc_core0_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_core0_isr_dummy_entry_177>
	...

80003640 <osEE_tc_core0_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_core0_isr_dummy_entry_178>
	...

80003660 <osEE_tc_core0_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_core0_isr_dummy_entry_179>
	...

80003680 <osEE_tc_core0_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_core0_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_core0_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_core0_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_core0_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_core0_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_core0_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_core0_isr_dummy_entry_183>
	...

80003700 <osEE_tc_core0_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_core0_isr_dummy_entry_184>
	...

80003720 <osEE_tc_core0_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_core0_isr_dummy_entry_185>
	...

80003740 <osEE_tc_core0_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_core0_isr_dummy_entry_186>
	...

80003760 <osEE_tc_core0_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_core0_isr_dummy_entry_187>
	...

80003780 <osEE_tc_core0_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_core0_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_core0_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_core0_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_core0_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_core0_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_core0_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_core0_isr_dummy_entry_191>
	...

80003800 <osEE_tc_core0_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_core0_isr_dummy_entry_192>
	...

80003820 <osEE_tc_core0_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_core0_isr_dummy_entry_193>
	...

80003840 <osEE_tc_core0_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_core0_isr_dummy_entry_194>
	...

80003860 <osEE_tc_core0_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_core0_isr_dummy_entry_195>
	...

80003880 <osEE_tc_core0_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_core0_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_core0_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_core0_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_core0_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_core0_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_core0_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_core0_isr_dummy_entry_199>
	...

80003900 <osEE_tc_core0_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_core0_isr_dummy_entry_200>
	...

80003920 <osEE_tc_core0_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_core0_isr_dummy_entry_201>
	...

80003940 <osEE_tc_core0_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_core0_isr_dummy_entry_202>
	...

80003960 <osEE_tc_core0_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_core0_isr_dummy_entry_203>
	...

80003980 <osEE_tc_core0_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_core0_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_core0_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_core0_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_core0_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_core0_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_core0_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_core0_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_core0_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_core0_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_core0_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_core0_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_core0_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_core0_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_core0_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_core0_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_core0_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_core0_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_core0_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_core0_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_core0_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_core0_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_core0_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_core0_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_core0_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_core0_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_core0_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_core0_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_core0_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_core0_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_core0_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_core0_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_core0_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_core0_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_core0_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_core0_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_core0_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_core0_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_core0_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_core0_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_core0_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_core0_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_core0_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_core0_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_core0_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_core0_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_core0_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_core0_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_core0_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_core0_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_core0_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_core0_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_core0_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_core0_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_core0_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_core0_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_core0_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_core0_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_core0_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_core0_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_core0_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_core0_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_core0_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_core0_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_core0_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_core0_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_core0_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_core0_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_core0_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_core0_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_core0_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_core0_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_core0_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_core0_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_core0_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_core0_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_core0_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_core0_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_core0_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_core0_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_core0_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_core0_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_core0_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_core0_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_core0_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_core0_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_core0_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_core0_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_core0_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_core0_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_core0_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_core0_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_core0_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_core0_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_core0_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_core0_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_core0_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_core0_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_core0_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_core0_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_core0_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_core0_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_core0_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_core0_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <led_blink>:
#include "ee.h"
#include "ee_tc2x5_board.h"

#define US_LED_ON (400000U)
static void led_blink(enum OsEE_tc2x5_led_id theled)
{
80004000:	02 48       	mov %d8,%d4
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004002:	8b 88 00 92 	eq %d9,%d8,8
  DisableAllInterrupts();
80004006:	6d 00 ca 0b 	call 8000579a <DisableAllInterrupts>
8000400a:	df 09 3e 80 	jne %d9,0,80004086 <led_blink+0x86>
8000400e:	ff 98 0d 80 	jge.u %d8,9,80004028 <led_blink+0x28>
80004012:	df 28 4a 00 	jeq %d8,2,800040a6 <led_blink+0xa6>
80004016:	df 48 40 00 	jeq %d8,4,80004096 <led_blink+0x96>
8000401a:	df 18 4e 80 	jne %d8,1,800040b6 <led_blink+0xb6>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
8000401e:	91 40 00 ff 	movh.a %a15,61444
80004022:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004026:	3c 68       	j 800040f6 <led_blink+0xf6>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004028:	8b 08 02 f2 	eq %d15,%d8,32
8000402c:	ee 25       	jnz %d15,80004076 <led_blink+0x76>
8000402e:	8b 18 a2 f2 	ge.u %d15,%d8,33
80004032:	ee 0c       	jnz %d15,8000404a <led_blink+0x4a>
80004034:	8b 08 01 f2 	eq %d15,%d8,16
80004038:	6e 3f       	jz %d15,800040b6 <led_blink+0xb6>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
8000403a:	91 40 00 ff 	movh.a %a15,61444
8000403e:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004042:	4c f0       	ld.w %d15,[%a15]0
80004044:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80004048:	3c 5a       	j 800040fc <led_blink+0xfc>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
8000404a:	8b 08 04 f2 	eq %d15,%d8,64
8000404e:	ee 0c       	jnz %d15,80004066 <led_blink+0x66>
80004050:	8b 08 08 f2 	eq %d15,%d8,128
80004054:	6e 31       	jz %d15,800040b6 <led_blink+0xb6>
    case OSEE_TRIBOARD_2X5_LED_8:
      P33_OUT.B.P13 = (uint8_t)onoff;
80004056:	91 40 00 ff 	movh.a %a15,61444
8000405a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000405e:	4c f0       	ld.w %d15,[%a15]0
80004060:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80004064:	3c 4c       	j 800040fc <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_7:
      P33_OUT.B.P12 = (uint8_t)onoff;
80004066:	91 40 00 ff 	movh.a %a15,61444
8000406a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000406e:	4c f0       	ld.w %d15,[%a15]0
80004070:	b7 0f 01 f6 	insert %d15,%d15,0,12,1
80004074:	3c 44       	j 800040fc <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
80004076:	91 40 00 ff 	movh.a %a15,61444
8000407a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000407e:	4c f0       	ld.w %d15,[%a15]0
80004080:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80004084:	3c 3c       	j 800040fc <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_4:
      P33_OUT.B.P9 = (uint8_t)onoff;
80004086:	91 40 00 ff 	movh.a %a15,61444
8000408a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000408e:	4c f0       	ld.w %d15,[%a15]0
80004090:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80004094:	3c 34       	j 800040fc <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_3:
      P33_OUT.B.P8 = (uint8_t)onoff;
80004096:	91 40 00 ff 	movh.a %a15,61444
8000409a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000409e:	4c f0       	ld.w %d15,[%a15]0
800040a0:	8f 0f d0 f1 	andn %d15,%d15,256
800040a4:	3c 2c       	j 800040fc <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
800040a6:	91 40 00 ff 	movh.a %a15,61444
800040aa:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800040ae:	4c f0       	ld.w %d15,[%a15]0
800040b0:	8f 0f c8 f1 	andn %d15,%d15,128
800040b4:	3c 24       	j 800040fc <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
    break;
    default:
      P33_OUT.B.P13 = (uint8_t)onoff;
800040b6:	91 40 00 ff 	movh.a %a15,61444
800040ba:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800040be:	4c f0       	ld.w %d15,[%a15]0
800040c0:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
800040c4:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P12 = (uint8_t)onoff;
800040c6:	4c f0       	ld.w %d15,[%a15]0
800040c8:	b7 0f 01 f6 	insert %d15,%d15,0,12,1
800040cc:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P11 = (uint8_t)onoff;
800040ce:	4c f0       	ld.w %d15,[%a15]0
800040d0:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
800040d4:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P10 = (uint8_t)onoff;
800040d6:	4c f0       	ld.w %d15,[%a15]0
800040d8:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
800040dc:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P9 = (uint8_t)onoff;
800040de:	4c f0       	ld.w %d15,[%a15]0
800040e0:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
800040e4:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P8 = (uint8_t)onoff;
800040e6:	4c f0       	ld.w %d15,[%a15]0
800040e8:	8f 0f d0 f1 	andn %d15,%d15,256
800040ec:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P7 = (uint8_t)onoff;
800040ee:	4c f0       	ld.w %d15,[%a15]0
800040f0:	8f 0f c8 f1 	andn %d15,%d15,128
800040f4:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P6 = (uint8_t)onoff;
800040f6:	4c f0       	ld.w %d15,[%a15]0
800040f8:	8f 0f c4 f1 	andn %d15,%d15,64
800040fc:	68 0f       	st.w [%a15]0,%d15
  osEE_tc2x5_turn_led(theled, OSEE_TRIBOARD_2X5_LED_ON);
  EnableAllInterrupts();
800040fe:	6d 00 5d 0b 	call 800057b8 <EnableAllInterrupts>

  osEE_tc_delay(US_LED_ON);
80004102:	7b 60 00 40 	movh %d4,6
80004106:	1b 04 a8 41 	addi %d4,%d4,6784
8000410a:	6d 00 ce 0a 	call 800056a6 <osEE_tc_delay>

  DisableAllInterrupts();
8000410e:	6d 00 46 0b 	call 8000579a <DisableAllInterrupts>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004112:	df 09 40 80 	jne %d9,0,80004192 <led_blink+0x192>
80004116:	ff 98 0d 80 	jge.u %d8,9,80004130 <led_blink+0x130>
8000411a:	df 28 4c 00 	jeq %d8,2,800041b2 <led_blink+0x1b2>
8000411e:	df 48 42 00 	jeq %d8,4,800041a2 <led_blink+0x1a2>
80004122:	df 18 4f 80 	jne %d8,1,800041c0 <led_blink+0x1c0>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
80004126:	91 40 00 ff 	movh.a %a15,61444
8000412a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000412e:	3c 68       	j 800041fe <led_blink+0x1fe>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004130:	8b 08 02 f2 	eq %d15,%d8,32
80004134:	ee 27       	jnz %d15,80004182 <led_blink+0x182>
80004136:	8b 18 a2 f2 	ge.u %d15,%d8,33
8000413a:	ee 0d       	jnz %d15,80004154 <led_blink+0x154>
8000413c:	8b 08 01 82 	eq %d8,%d8,16
80004140:	df 08 40 00 	jeq %d8,0,800041c0 <led_blink+0x1c0>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
80004144:	91 40 00 ff 	movh.a %a15,61444
80004148:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000414c:	4c f0       	ld.w %d15,[%a15]0
8000414e:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80004152:	3c 58       	j 80004202 <led_blink+0x202>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004154:	8b 08 04 f2 	eq %d15,%d8,64
80004158:	ee 0d       	jnz %d15,80004172 <led_blink+0x172>
8000415a:	8b 08 08 82 	eq %d8,%d8,128
8000415e:	df 08 31 00 	jeq %d8,0,800041c0 <led_blink+0x1c0>
    case OSEE_TRIBOARD_2X5_LED_8:
      P33_OUT.B.P13 = (uint8_t)onoff;
80004162:	91 40 00 ff 	movh.a %a15,61444
80004166:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000416a:	4c f0       	ld.w %d15,[%a15]0
8000416c:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80004170:	3c 49       	j 80004202 <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_7:
      P33_OUT.B.P12 = (uint8_t)onoff;
80004172:	91 40 00 ff 	movh.a %a15,61444
80004176:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000417a:	4c f0       	ld.w %d15,[%a15]0
8000417c:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
80004180:	3c 41       	j 80004202 <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
80004182:	91 40 00 ff 	movh.a %a15,61444
80004186:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000418a:	4c f0       	ld.w %d15,[%a15]0
8000418c:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80004190:	3c 39       	j 80004202 <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_4:
      P33_OUT.B.P9 = (uint8_t)onoff;
80004192:	91 40 00 ff 	movh.a %a15,61444
80004196:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000419a:	4c f0       	ld.w %d15,[%a15]0
8000419c:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
800041a0:	3c 31       	j 80004202 <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_3:
      P33_OUT.B.P8 = (uint8_t)onoff;
800041a2:	91 40 00 ff 	movh.a %a15,61444
800041a6:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800041aa:	4c f0       	ld.w %d15,[%a15]0
800041ac:	8f 0f 50 f1 	or %d15,%d15,256
800041b0:	3c 29       	j 80004202 <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
800041b2:	91 40 00 ff 	movh.a %a15,61444
800041b6:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800041ba:	4c f0       	ld.w %d15,[%a15]0
800041bc:	96 80       	or %d15,128
800041be:	3c 22       	j 80004202 <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
    break;
    default:
      P33_OUT.B.P13 = (uint8_t)onoff;
800041c0:	91 40 00 ff 	movh.a %a15,61444
800041c4:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800041c8:	4c f0       	ld.w %d15,[%a15]0
800041ca:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
800041ce:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P12 = (uint8_t)onoff;
800041d0:	4c f0       	ld.w %d15,[%a15]0
800041d2:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
800041d6:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P11 = (uint8_t)onoff;
800041d8:	4c f0       	ld.w %d15,[%a15]0
800041da:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
800041de:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P10 = (uint8_t)onoff;
800041e0:	4c f0       	ld.w %d15,[%a15]0
800041e2:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800041e6:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P9 = (uint8_t)onoff;
800041e8:	4c f0       	ld.w %d15,[%a15]0
800041ea:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
800041ee:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P8 = (uint8_t)onoff;
800041f0:	4c f0       	ld.w %d15,[%a15]0
800041f2:	8f 0f 50 f1 	or %d15,%d15,256
800041f6:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P7 = (uint8_t)onoff;
800041f8:	4c f0       	ld.w %d15,[%a15]0
800041fa:	96 80       	or %d15,128
800041fc:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P6 = (uint8_t)onoff;
800041fe:	4c f0       	ld.w %d15,[%a15]0
80004200:	96 40       	or %d15,64
80004202:	68 0f       	st.w [%a15]0,%d15
  osEE_tc2x5_turn_led(theled, OSEE_TRIBOARD_2X5_LED_OFF);
  EnableAllInterrupts();
80004204:	1d 00 da 0a 	j 800057b8 <EnableAllInterrupts>

80004208 <Func121>:
/************************************************************************/
/************************************************************************/

 void Func121(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_3);
80004208:	82 44       	mov %d4,4
8000420a:	1d ff fb fe 	j 80004000 <led_blink>

8000420e <Func122>:
}
void Func122(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_4);
8000420e:	3b 80 00 40 	mov %d4,8
80004212:	1d ff f7 fe 	j 80004000 <led_blink>

80004216 <Func123>:
}
 void Func123(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_5);
80004216:	3b 00 01 40 	mov %d4,16
8000421a:	1d ff f3 fe 	j 80004000 <led_blink>

8000421e <Func111>:
}
/*****************************/
 void Func111(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
8000421e:	82 14       	mov %d4,1
80004220:	6d ff f0 fe 	call 80004000 <led_blink>
	Func121();
80004224:	1d ff f2 ff 	j 80004208 <Func121>

80004228 <Func112>:
}
void Func112(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_2);
80004228:	82 24       	mov %d4,2
8000422a:	6d ff eb fe 	call 80004000 <led_blink>
	Func122();
8000422e:	1d ff f0 ff 	j 8000420e <Func122>

80004232 <Func11>:
}
void Func11(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
80004232:	82 14       	mov %d4,1
80004234:	6d ff e6 fe 	call 80004000 <led_blink>
	Func111();
80004238:	6d ff f3 ff 	call 8000421e <Func111>
	Func112();
8000423c:	6d ff f6 ff 	call 80004228 <Func112>
	Func123();
80004240:	1d ff eb ff 	j 80004216 <Func123>

80004244 <Func12>:
}

 void Func12(void)
{
	 led_blink(OSEE_TRIBOARD_2X5_LED_1);
80004244:	82 14       	mov %d4,1
80004246:	6d ff dd fe 	call 80004000 <led_blink>
	Func121();
8000424a:	6d ff df ff 	call 80004208 <Func121>
	Func122();
8000424e:	6d ff e0 ff 	call 8000420e <Func122>
	Func123();
80004252:	1d ff e2 ff 	j 80004216 <Func123>

80004256 <Func131>:

}
void Func131(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_6);
80004256:	3b 00 02 40 	mov %d4,32
8000425a:	1d ff d3 fe 	j 80004000 <led_blink>

8000425e <Func132>:
}
void Func132(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_7);
8000425e:	3b 00 04 40 	mov %d4,64
80004262:	1d ff cf fe 	j 80004000 <led_blink>

80004266 <Func13>:
}
void Func13(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
80004266:	82 14       	mov %d4,1
80004268:	6d ff cc fe 	call 80004000 <led_blink>
	Func131();
8000426c:	6d ff f5 ff 	call 80004256 <Func131>
	Func132();
80004270:	1d ff f7 ff 	j 8000425e <Func132>

80004274 <Func211>:
}
void Func211(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
80004274:	82 14       	mov %d4,1
80004276:	1d ff c5 fe 	j 80004000 <led_blink>

8000427a <Func212>:
}
void Func212(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_2);
8000427a:	82 24       	mov %d4,2
8000427c:	1d ff c2 fe 	j 80004000 <led_blink>

80004280 <Func21>:
}
void Func21(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
80004280:	82 14       	mov %d4,1
80004282:	6d ff bf fe 	call 80004000 <led_blink>
	Func211();
80004286:	6d ff f7 ff 	call 80004274 <Func211>
	Func212();
8000428a:	1d ff f8 ff 	j 8000427a <Func212>

8000428e <Func221>:
}
 void Func221(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_3);
8000428e:	82 44       	mov %d4,4
80004290:	1d ff b8 fe 	j 80004000 <led_blink>

80004294 <Func222>:
}
void Func222(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_4);
80004294:	3b 80 00 40 	mov %d4,8
80004298:	1d ff b4 fe 	j 80004000 <led_blink>

8000429c <Func22>:
}
void Func22(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
8000429c:	82 14       	mov %d4,1
8000429e:	6d ff b1 fe 	call 80004000 <led_blink>
	Func221();
800042a2:	6d ff f6 ff 	call 8000428e <Func221>
	Func222();
800042a6:	1d ff f7 ff 	j 80004294 <Func222>

800042aa <Func311>:
}
void Func311(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_5);
800042aa:	3b 00 01 40 	mov %d4,16
800042ae:	1d ff a9 fe 	j 80004000 <led_blink>

800042b2 <Func312>:
}
void Func312(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_6);
800042b2:	3b 00 02 40 	mov %d4,32
800042b6:	1d ff a5 fe 	j 80004000 <led_blink>

800042ba <Func31>:
}
void Func31(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
800042ba:	82 14       	mov %d4,1
800042bc:	6d ff a2 fe 	call 80004000 <led_blink>
	Func311();
800042c0:	6d ff f5 ff 	call 800042aa <Func311>
	Func312();
800042c4:	1d ff f7 ff 	j 800042b2 <Func312>

800042c8 <Func321>:
}
void Func321(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
800042c8:	82 14       	mov %d4,1
800042ca:	6d ff 9b fe 	call 80004000 <led_blink>
	led_blink(OSEE_TRIBOARD_2X5_LED_7);
800042ce:	3b 00 04 40 	mov %d4,64
800042d2:	1d ff 97 fe 	j 80004000 <led_blink>

800042d6 <Func322>:
}
void Func322(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
800042d6:	82 14       	mov %d4,1
800042d8:	6d ff 94 fe 	call 80004000 <led_blink>
	led_blink(OSEE_TRIBOARD_2X5_LED_8);
800042dc:	3b 00 08 40 	mov %d4,128
800042e0:	1d ff 90 fe 	j 80004000 <led_blink>

800042e4 <Func32>:
}
void Func32(void)
{
	led_blink(OSEE_TRIBOARD_2X5_LED_1);
800042e4:	82 14       	mov %d4,1
800042e6:	6d ff 8d fe 	call 80004000 <led_blink>
	Func321();
800042ea:	6d ff ef ff 	call 800042c8 <Func321>
	Func322();
800042ee:	1d ff f4 ff 	j 800042d6 <Func322>

800042f2 <Func1>:
 DeclareTask(TaskM);
 DeclareTask(TaskCpu0);
 /* Functions */
  void Func1(void)
 {
 	Func11();
800042f2:	6d ff a0 ff 	call 80004232 <Func11>
 	Func12();
800042f6:	6d ff a7 ff 	call 80004244 <Func12>
 	Func13();
800042fa:	1d ff b6 ff 	j 80004266 <Func13>

800042fe <Func2>:

 }
  void Func2(void)
 {
 	Func21();
800042fe:	6d ff c1 ff 	call 80004280 <Func21>
 	Func22();
80004302:	1d ff cd ff 	j 8000429c <Func22>

80004306 <Func3>:

 }
  void Func3(void)
 {
 	Func31();
80004306:	6d ff da ff 	call 800042ba <Func31>
 	Func32();
8000430a:	1d ff ed ff 	j 800042e4 <Func32>

8000430e <FuncTaskM>:
 * TASk M
 */
TASK(TaskM)

{
	  Func1();
8000430e:	6d ff f2 ff 	call 800042f2 <Func1>
	  Func2();
80004312:	6d ff f6 ff 	call 800042fe <Func2>
	  Func3();
80004316:	6d ff f8 ff 	call 80004306 <Func3>
  SetEvent(Task2,RemoteEvent);
8000431a:	82 44       	mov %d4,4
8000431c:	82 15       	mov %d5,1
8000431e:	6d 00 1c 12 	call 80006756 <SetEvent>
  led_blink(OSEE_TRIBOARD_2X5_LED_6);
80004322:	3b 00 02 40 	mov %d4,32
80004326:	6d ff 6d fe 	call 80004000 <led_blink>

  /* Cleanly terminate the Task */
  TerminateTask();
8000432a:	1d 00 b6 0d 	j 80005e96 <TerminateTask>

8000432e <FuncTaskCpu0>:
/*
 * TASK 1
 */
TASK(TaskCpu0)
{
	  led_blink(OSEE_TRIBOARD_2X5_LED_8);
8000432e:	3b 00 08 40 	mov %d4,128
80004332:	6d ff 67 fe 	call 80004000 <led_blink>
	  /* Cleanly terminate the Task */
	  TerminateTask();
80004336:	1d 00 b0 0d 	j 80005e96 <TerminateTask>

8000433a <ErrorHook>:

void ErrorHook(StatusType Error)
{
  (void)Error;

  ++myErrorCounter;
8000433a:	91 00 00 f7 	movh.a %a15,28672
8000433e:	19 ff 10 00 	ld.w %d15,[%a15]16 <70000010 <myErrorCounter>>
  led_blink(OSEE_TRIBOARD_2X5_ALL_LEDS);
80004342:	3b f0 0f 40 	mov %d4,255

void ErrorHook(StatusType Error)
{
  (void)Error;

  ++myErrorCounter;
80004346:	c2 1f       	add %d15,1
80004348:	59 ff 10 00 	st.w [%a15]16 <70000010 <myErrorCounter>>,%d15
  led_blink(OSEE_TRIBOARD_2X5_ALL_LEDS);
8000434c:	1d ff 5a fe 	j 80004000 <led_blink>

80004350 <main>:

/*
 * MAIN TASK
 */
int main(void)
{
80004350:	20 08       	sub.a %sp,8
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80004352:	4d c0 e1 ff 	mfcr %d15,$core_id
	StatusType       status;
	  AppModeType      mode;
	  CoreIdType const core_id = GetCoreID();

	  if (core_id == OS_CORE_ID_MASTER) {
80004356:	16 ff       	and %d15,255
	    StartCore(1, &status);
	    StartCore(2, &status);
	    mode = OSDEFAULTAPPMODE;
	  } else {

	    mode = DONOTCARE;
80004358:	3b f0 0f 40 	mov %d4,255
{
	StatusType       status;
	  AppModeType      mode;
	  CoreIdType const core_id = GetCoreID();

	  if (core_id == OS_CORE_ID_MASTER) {
8000435c:	ee 68       	jnz %d15,8000442c <main+0xdc>
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
    break;
    default:
      P33_OUT.B.P13 = (uint8_t)onoff;
8000435e:	91 40 00 ff 	movh.a %a15,61444
80004362:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004366:	4c f0       	ld.w %d15,[%a15]0
	    /* Init leds */
	    osEE_tc2x5_leds_init();

	    StartCore(1, &status);
80004368:	82 14       	mov %d4,1
8000436a:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
8000436e:	d9 a4 07 00 	lea %a4,[%sp]7
80004372:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P12 = (uint8_t)onoff;
80004374:	4c f0       	ld.w %d15,[%a15]0
80004376:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
8000437a:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P11 = (uint8_t)onoff;
8000437c:	4c f0       	ld.w %d15,[%a15]0
8000437e:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80004382:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P10 = (uint8_t)onoff;
80004384:	4c f0       	ld.w %d15,[%a15]0
80004386:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000438a:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P9 = (uint8_t)onoff;
8000438c:	4c f0       	ld.w %d15,[%a15]0
8000438e:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80004392:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P8 = (uint8_t)onoff;
80004394:	4c f0       	ld.w %d15,[%a15]0
80004396:	8f 0f 50 f1 	or %d15,%d15,256
8000439a:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P7 = (uint8_t)onoff;
8000439c:	4c f0       	ld.w %d15,[%a15]0
8000439e:	96 80       	or %d15,128
800043a0:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P6 = (uint8_t)onoff;
800043a2:	4c f0       	ld.w %d15,[%a15]0
800043a4:	96 40       	or %d15,64
800043a6:	68 0f       	st.w [%a15]0,%d15

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_leds_init( void )
{
  osEE_tc2x5_leds_off();

  P33_IOCR12.B.PC13  =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043a8:	91 40 00 ff 	movh.a %a15,61444
800043ac:	d9 ff 1c cd 	lea %a15,[%a15]-11492 <f003d31c <_SMALL_DATA4_+0x4003531c>>
800043b0:	4c f0       	ld.w %d15,[%a15]0
800043b2:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
800043b6:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
800043ba:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR12.B.PC12  =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043bc:	4c f0       	ld.w %d15,[%a15]0
800043be:	8f 8f cf f1 	andn %d15,%d15,248
800043c2:	96 80       	or %d15,128
800043c4:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR8.B.PC11   =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043c6:	91 40 00 ff 	movh.a %a15,61444
800043ca:	d9 ff 18 cd 	lea %a15,[%a15]-11496 <f003d318 <_SMALL_DATA4_+0x40035318>>
800043ce:	4c f0       	ld.w %d15,[%a15]0
800043d0:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
800043d4:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
800043d8:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR8.B.PC10   =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043da:	4c f0       	ld.w %d15,[%a15]0
800043dc:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
800043e0:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
800043e4:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR8.B.PC9    =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043e6:	4c f0       	ld.w %d15,[%a15]0
800043e8:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
800043ec:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
800043f0:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR8.B.PC8    =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043f2:	4c f0       	ld.w %d15,[%a15]0
800043f4:	8f 8f cf f1 	andn %d15,%d15,248
800043f8:	96 80       	or %d15,128
800043fa:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR4.B.PC7    =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
800043fc:	91 40 00 ff 	movh.a %a15,61444
80004400:	d9 ff 14 cd 	lea %a15,[%a15]-11500 <f003d314 <_SMALL_DATA4_+0x40035314>>
80004404:	4c f0       	ld.w %d15,[%a15]0
80004406:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000440a:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000440e:	68 0f       	st.w [%a15]0,%d15
  P33_IOCR4.B.PC6    =   OSEE_TC2YX_OUTPUT_PUSH_PULL_GP;
80004410:	4c f0       	ld.w %d15,[%a15]0
80004412:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
80004416:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000441a:	68 0f       	st.w [%a15]0,%d15
8000441c:	6d 00 d7 16 	call 800071ca <StartCore>
	    StartCore(2, &status);
80004420:	82 24       	mov %d4,2
80004422:	d9 a4 07 00 	lea %a4,[%sp]7
80004426:	6d 00 d2 16 	call 800071ca <StartCore>
	    mode = OSDEFAULTAPPMODE;
8000442a:	82 04       	mov %d4,0
	  } else {

	    mode = DONOTCARE;
	  }

	  StartOS(mode);
8000442c:	6d 00 84 0a 	call 80005934 <StartOS>

	  return 0;
}
80004430:	82 02       	mov %d2,0
80004432:	00 90       	ret 

80004434 <FuncTask2>:

TASK(Task2)
{
	while(1)
	{
		WaitEvent(RemoteEvent);
80004434:	82 14       	mov %d4,1
80004436:	6d 00 1b 11 	call 8000666c <WaitEvent>
		ActivateTask(Task3);
8000443a:	82 54       	mov %d4,5
8000443c:	6d 00 27 0c 	call 80005c8a <ActivateTask>
		//led_blink(OSEE_TRIBOARD_2X5_LED_3);
		ClearEvent(RemoteEvent);
80004440:	82 14       	mov %d4,1
80004442:	6d 00 7a 12 	call 80006936 <ClearEvent>
	}
80004446:	3c f7       	j 80004434 <FuncTask2>

80004448 <FuncTask3>:
 */

TASK(Task3)
{
	//led_blink(OSEE_TRIBOARD_2X5_LED_4);
	SetRelAlarm(AlarmRemoteCPU0, 50, 0);
80004448:	82 14       	mov %d4,1
8000444a:	3b 20 03 50 	mov %d5,50
8000444e:	82 06       	mov %d6,0
80004450:	6d 00 02 0f 	call 80006254 <SetRelAlarm>
    TerminateTask();
80004454:	1d 00 21 0d 	j 80005e96 <TerminateTask>

80004458 <led_blink>:
#include "ee.h"
#include "ee_tc2x5_board.h"

#define US_LED_ON (400000U)
static void led_blink(enum OsEE_tc2x5_led_id theled)
{
80004458:	02 48       	mov %d8,%d4
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
8000445a:	8b 88 00 92 	eq %d9,%d8,8
  DisableAllInterrupts();
8000445e:	6d 00 9e 09 	call 8000579a <DisableAllInterrupts>
80004462:	df 09 3e 80 	jne %d9,0,800044de <led_blink+0x86>
80004466:	ff 98 0d 80 	jge.u %d8,9,80004480 <led_blink+0x28>
8000446a:	df 28 4a 00 	jeq %d8,2,800044fe <led_blink+0xa6>
8000446e:	df 48 40 00 	jeq %d8,4,800044ee <led_blink+0x96>
80004472:	df 18 4e 80 	jne %d8,1,8000450e <led_blink+0xb6>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
80004476:	91 40 00 ff 	movh.a %a15,61444
8000447a:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000447e:	3c 68       	j 8000454e <led_blink+0xf6>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004480:	8b 08 02 f2 	eq %d15,%d8,32
80004484:	ee 25       	jnz %d15,800044ce <led_blink+0x76>
80004486:	8b 18 a2 f2 	ge.u %d15,%d8,33
8000448a:	ee 0c       	jnz %d15,800044a2 <led_blink+0x4a>
8000448c:	8b 08 01 f2 	eq %d15,%d8,16
80004490:	6e 3f       	jz %d15,8000450e <led_blink+0xb6>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
80004492:	91 40 00 ff 	movh.a %a15,61444
80004496:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
8000449a:	4c f0       	ld.w %d15,[%a15]0
8000449c:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
800044a0:	3c 5a       	j 80004554 <led_blink+0xfc>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
800044a2:	8b 08 04 f2 	eq %d15,%d8,64
800044a6:	ee 0c       	jnz %d15,800044be <led_blink+0x66>
800044a8:	8b 08 08 f2 	eq %d15,%d8,128
800044ac:	6e 31       	jz %d15,8000450e <led_blink+0xb6>
    case OSEE_TRIBOARD_2X5_LED_8:
      P33_OUT.B.P13 = (uint8_t)onoff;
800044ae:	91 40 00 ff 	movh.a %a15,61444
800044b2:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800044b6:	4c f0       	ld.w %d15,[%a15]0
800044b8:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
800044bc:	3c 4c       	j 80004554 <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_7:
      P33_OUT.B.P12 = (uint8_t)onoff;
800044be:	91 40 00 ff 	movh.a %a15,61444
800044c2:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800044c6:	4c f0       	ld.w %d15,[%a15]0
800044c8:	b7 0f 01 f6 	insert %d15,%d15,0,12,1
800044cc:	3c 44       	j 80004554 <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
800044ce:	91 40 00 ff 	movh.a %a15,61444
800044d2:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800044d6:	4c f0       	ld.w %d15,[%a15]0
800044d8:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
800044dc:	3c 3c       	j 80004554 <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_4:
      P33_OUT.B.P9 = (uint8_t)onoff;
800044de:	91 40 00 ff 	movh.a %a15,61444
800044e2:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800044e6:	4c f0       	ld.w %d15,[%a15]0
800044e8:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
800044ec:	3c 34       	j 80004554 <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_3:
      P33_OUT.B.P8 = (uint8_t)onoff;
800044ee:	91 40 00 ff 	movh.a %a15,61444
800044f2:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800044f6:	4c f0       	ld.w %d15,[%a15]0
800044f8:	8f 0f d0 f1 	andn %d15,%d15,256
800044fc:	3c 2c       	j 80004554 <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
800044fe:	91 40 00 ff 	movh.a %a15,61444
80004502:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004506:	4c f0       	ld.w %d15,[%a15]0
80004508:	8f 0f c8 f1 	andn %d15,%d15,128
8000450c:	3c 24       	j 80004554 <led_blink+0xfc>
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
    break;
    default:
      P33_OUT.B.P13 = (uint8_t)onoff;
8000450e:	91 40 00 ff 	movh.a %a15,61444
80004512:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004516:	4c f0       	ld.w %d15,[%a15]0
80004518:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
8000451c:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P12 = (uint8_t)onoff;
8000451e:	4c f0       	ld.w %d15,[%a15]0
80004520:	b7 0f 01 f6 	insert %d15,%d15,0,12,1
80004524:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P11 = (uint8_t)onoff;
80004526:	4c f0       	ld.w %d15,[%a15]0
80004528:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000452c:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P10 = (uint8_t)onoff;
8000452e:	4c f0       	ld.w %d15,[%a15]0
80004530:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80004534:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P9 = (uint8_t)onoff;
80004536:	4c f0       	ld.w %d15,[%a15]0
80004538:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000453c:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P8 = (uint8_t)onoff;
8000453e:	4c f0       	ld.w %d15,[%a15]0
80004540:	8f 0f d0 f1 	andn %d15,%d15,256
80004544:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P7 = (uint8_t)onoff;
80004546:	4c f0       	ld.w %d15,[%a15]0
80004548:	8f 0f c8 f1 	andn %d15,%d15,128
8000454c:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P6 = (uint8_t)onoff;
8000454e:	4c f0       	ld.w %d15,[%a15]0
80004550:	8f 0f c4 f1 	andn %d15,%d15,64
80004554:	68 0f       	st.w [%a15]0,%d15
  osEE_tc2x5_turn_led(theled, OSEE_TRIBOARD_2X5_LED_ON);
  EnableAllInterrupts();
80004556:	6d 00 31 09 	call 800057b8 <EnableAllInterrupts>

  osEE_tc_delay(US_LED_ON);
8000455a:	7b 60 00 40 	movh %d4,6
8000455e:	1b 04 a8 41 	addi %d4,%d4,6784
80004562:	6d 00 a2 08 	call 800056a6 <osEE_tc_delay>

  DisableAllInterrupts();
80004566:	6d 00 1a 09 	call 8000579a <DisableAllInterrupts>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
8000456a:	df 09 40 80 	jne %d9,0,800045ea <led_blink+0x192>
8000456e:	ff 98 0d 80 	jge.u %d8,9,80004588 <led_blink+0x130>
80004572:	df 28 4c 00 	jeq %d8,2,8000460a <led_blink+0x1b2>
80004576:	df 48 42 00 	jeq %d8,4,800045fa <led_blink+0x1a2>
8000457a:	df 18 4f 80 	jne %d8,1,80004618 <led_blink+0x1c0>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
8000457e:	91 40 00 ff 	movh.a %a15,61444
80004582:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004586:	3c 68       	j 80004656 <led_blink+0x1fe>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
80004588:	8b 08 02 f2 	eq %d15,%d8,32
8000458c:	ee 27       	jnz %d15,800045da <led_blink+0x182>
8000458e:	8b 18 a2 f2 	ge.u %d15,%d8,33
80004592:	ee 0d       	jnz %d15,800045ac <led_blink+0x154>
80004594:	8b 08 01 82 	eq %d8,%d8,16
80004598:	df 08 40 00 	jeq %d8,0,80004618 <led_blink+0x1c0>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
8000459c:	91 40 00 ff 	movh.a %a15,61444
800045a0:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800045a4:	4c f0       	ld.w %d15,[%a15]0
800045a6:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800045aa:	3c 58       	j 8000465a <led_blink+0x202>
};

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc2x5_turn_led(
    enum OsEE_tc2x5_led_id led_id, enum OsEE_tc2x5_led_status onoff
) {
  switch(led_id) {
800045ac:	8b 08 04 f2 	eq %d15,%d8,64
800045b0:	ee 0d       	jnz %d15,800045ca <led_blink+0x172>
800045b2:	8b 08 08 82 	eq %d8,%d8,128
800045b6:	df 08 31 00 	jeq %d8,0,80004618 <led_blink+0x1c0>
    case OSEE_TRIBOARD_2X5_LED_8:
      P33_OUT.B.P13 = (uint8_t)onoff;
800045ba:	91 40 00 ff 	movh.a %a15,61444
800045be:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800045c2:	4c f0       	ld.w %d15,[%a15]0
800045c4:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
800045c8:	3c 49       	j 8000465a <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_7:
      P33_OUT.B.P12 = (uint8_t)onoff;
800045ca:	91 40 00 ff 	movh.a %a15,61444
800045ce:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800045d2:	4c f0       	ld.w %d15,[%a15]0
800045d4:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
800045d8:	3c 41       	j 8000465a <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_6:
      P33_OUT.B.P11 = (uint8_t)onoff;
800045da:	91 40 00 ff 	movh.a %a15,61444
800045de:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800045e2:	4c f0       	ld.w %d15,[%a15]0
800045e4:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
800045e8:	3c 39       	j 8000465a <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_5:
      P33_OUT.B.P10 = (uint8_t)onoff;
    break;
    case OSEE_TRIBOARD_2X5_LED_4:
      P33_OUT.B.P9 = (uint8_t)onoff;
800045ea:	91 40 00 ff 	movh.a %a15,61444
800045ee:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
800045f2:	4c f0       	ld.w %d15,[%a15]0
800045f4:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
800045f8:	3c 31       	j 8000465a <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_3:
      P33_OUT.B.P8 = (uint8_t)onoff;
800045fa:	91 40 00 ff 	movh.a %a15,61444
800045fe:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004602:	4c f0       	ld.w %d15,[%a15]0
80004604:	8f 0f 50 f1 	or %d15,%d15,256
80004608:	3c 29       	j 8000465a <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_2:
      P33_OUT.B.P7 = (uint8_t)onoff;
8000460a:	91 40 00 ff 	movh.a %a15,61444
8000460e:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004612:	4c f0       	ld.w %d15,[%a15]0
80004614:	96 80       	or %d15,128
80004616:	3c 22       	j 8000465a <led_blink+0x202>
    break;
    case OSEE_TRIBOARD_2X5_LED_1:
      P33_OUT.B.P6 = (uint8_t)onoff;
    break;
    default:
      P33_OUT.B.P13 = (uint8_t)onoff;
80004618:	91 40 00 ff 	movh.a %a15,61444
8000461c:	d9 ff 00 cd 	lea %a15,[%a15]-11520 <f003d300 <_SMALL_DATA4_+0x40035300>>
80004620:	4c f0       	ld.w %d15,[%a15]0
80004622:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80004626:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P12 = (uint8_t)onoff;
80004628:	4c f0       	ld.w %d15,[%a15]0
8000462a:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
8000462e:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P11 = (uint8_t)onoff;
80004630:	4c f0       	ld.w %d15,[%a15]0
80004632:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80004636:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P10 = (uint8_t)onoff;
80004638:	4c f0       	ld.w %d15,[%a15]0
8000463a:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000463e:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P9 = (uint8_t)onoff;
80004640:	4c f0       	ld.w %d15,[%a15]0
80004642:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80004646:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P8 = (uint8_t)onoff;
80004648:	4c f0       	ld.w %d15,[%a15]0
8000464a:	8f 0f 50 f1 	or %d15,%d15,256
8000464e:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P7 = (uint8_t)onoff;
80004650:	4c f0       	ld.w %d15,[%a15]0
80004652:	96 80       	or %d15,128
80004654:	68 0f       	st.w [%a15]0,%d15
      P33_OUT.B.P6 = (uint8_t)onoff;
80004656:	4c f0       	ld.w %d15,[%a15]0
80004658:	96 40       	or %d15,64
8000465a:	68 0f       	st.w [%a15]0,%d15
  osEE_tc2x5_turn_led(theled, OSEE_TRIBOARD_2X5_LED_OFF);
  EnableAllInterrupts();
8000465c:	1d 00 ae 08 	j 800057b8 <EnableAllInterrupts>

80004660 <FuncTASK_1MS>:
 * TASk M
 */
TASK(TASK_1MS)

{
  led_blink(OSEE_TRIBOARD_2X5_LED_1);
80004660:	82 14       	mov %d4,1
80004662:	6d ff fb fe 	call 80004458 <led_blink>
  /* Cleanly terminate the Task */
  TerminateTask();
80004666:	1d 00 18 0c 	j 80005e96 <TerminateTask>

8000466a <FuncTASK_5MS>:
}

TASK(TASK_5MS)

{
  led_blink(OSEE_TRIBOARD_2X5_LED_2);
8000466a:	82 24       	mov %d4,2
8000466c:	6d ff f6 fe 	call 80004458 <led_blink>
  /* Cleanly terminate the Task */
  TerminateTask();
80004670:	1d 00 13 0c 	j 80005e96 <TerminateTask>

80004674 <FuncTASK_10MS>:
}

TASK(TASK_10MS)

{
  led_blink(OSEE_TRIBOARD_2X5_LED_3);
80004674:	82 44       	mov %d4,4
80004676:	6d ff f1 fe 	call 80004458 <led_blink>
  /* Cleanly terminate the Task */
  TerminateTask();
8000467a:	1d 00 0e 0c 	j 80005e96 <TerminateTask>

8000467e <FuncTASK_20MS>:
}

TASK(TASK_20MS)

{
  led_blink(OSEE_TRIBOARD_2X5_LED_4);
8000467e:	3b 80 00 40 	mov %d4,8
80004682:	6d ff eb fe 	call 80004458 <led_blink>
  /* Cleanly terminate the Task */
  TerminateTask();
80004686:	1d 00 08 0c 	j 80005e96 <TerminateTask>

8000468a <FuncTASK_50MS>:
}

TASK(TASK_50MS)

{
  led_blink(OSEE_TRIBOARD_2X5_LED_5);
8000468a:	3b 00 01 40 	mov %d4,16
8000468e:	6d ff e5 fe 	call 80004458 <led_blink>
  /* Cleanly terminate the Task */
  TerminateTask();
80004692:	1d 00 02 0c 	j 80005e96 <TerminateTask>

80004696 <FuncTASK_100MS>:
}

TASK(TASK_100MS)

{
  led_blink(OSEE_TRIBOARD_2X5_LED_6);
80004696:	3b 00 02 40 	mov %d4,32
8000469a:	6d ff df fe 	call 80004458 <led_blink>
  /* Cleanly terminate the Task */
  TerminateTask();
8000469e:	1d 00 fc 0b 	j 80005e96 <TerminateTask>

800046a2 <osEE_tc_C_init>:
      p_copy_table = NULL;
    }
  }
}

static void osEE_tc_C_init(void) {
800046a2:	40 ae       	mov.aa %a14,%sp
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
800046a4:	91 00 00 48 	movh.a %a4,32768
800046a8:	d9 44 6c 60 	lea %a4,[%a4]1452 <800005ac <__clear_table>>
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
800046ac:	d2 02       	mov %e2,0
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
800046ae:	82 00       	mov %d0,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
800046b0:	82 07       	mov %d7,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
800046b2:	82 06       	mov %d6,0
800046b4:	3c 1a       	j 800046e8 <osEE_tc_C_init+0x46>
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
800046b6:	8f d4 1f 50 	sh %d5,%d4,-3

      while (ull_cnt != 0U) {
800046ba:	76 5b       	jz %d5,800046d0 <osEE_tc_C_init+0x2e>
800046bc:	40 32       	mov.aa %a2,%a3
800046be:	02 5f       	mov %d15,%d5
        *block_to_clear.p_ull = 0ULL;
800046c0:	60 5f       	mov.a %a15,%d5
800046c2:	b0 ff       	add.a %a15,-1
800046c4:	89 22 48 01 	st.d [%a2+]8,%e2
        ++block_to_clear.p_ull;
        --ull_cnt;
800046c8:	c2 ff       	add %d15,-1
800046ca:	fc fd       	loop %a15,800046c4 <osEE_tc_C_init+0x22>
800046cc:	01 35 03 36 	addsc.a %a3,%a3,%d5,3
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
800046d0:	6f 24 03 00 	jz.t %d4,2,800046d6 <osEE_tc_C_init+0x34>
        *block_to_clear.p_ui = 0x0U;
800046d4:	64 30       	st.w [%a3+],%d0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
800046d6:	6f 14 03 00 	jz.t %d4,1,800046dc <osEE_tc_C_init+0x3a>
        *block_to_clear.p_us = 0x0U;
800046da:	a4 37       	st.h [%a3+],%d7
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
800046dc:	6f 04 03 00 	jz.t %d4,0,800046e2 <osEE_tc_C_init+0x40>
        *block_to_clear.p_uc = 0x0U;
800046e0:	34 36       	st.b [%a3],%d6
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
800046e2:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
800046e6:	bc 46       	jz.a %a4,800046f2 <osEE_tc_C_init+0x50>
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
800046e8:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
800046ea:	19 44 04 00 	ld.w %d4,[%a4]4 <80000004 <BootModeHeader0+0x4>>
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
800046ee:	df f4 e4 ff 	jne %d4,-1,800046b6 <osEE_tc_C_init+0x14>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
800046f2:	91 00 00 48 	movh.a %a4,32768
800046f6:	d9 44 54 80 	lea %a4,[%a4]1556 <80000614 <__copy_table>>
800046fa:	3c 25       	j 80004744 <osEE_tc_C_init+0xa2>
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
800046fc:	8f d4 1f 50 	sh %d5,%d4,-3

      while (ull_cnt != 0U) {
80004700:	df 05 12 00 	jeq %d5,0,80004724 <osEE_tc_C_init+0x82>
80004704:	40 63       	mov.aa %a3,%a6
80004706:	40 52       	mov.aa %a2,%a5
80004708:	02 5f       	mov %d15,%d5
8000470a:	60 5f       	mov.a %a15,%d5
8000470c:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
8000470e:	09 32 48 01 	ld.d %e2,[%a3+]8
80004712:	89 22 48 01 	st.d [%a2+]8,%e2
        ++block_src.p_ull;
        ++block_dest.p_ull;
        --ull_cnt;
80004716:	c2 ff       	add %d15,-1
80004718:	fc fb       	loop %a15,8000470e <osEE_tc_C_init+0x6c>
8000471a:	06 35       	sh %d5,3
8000471c:	01 65 00 66 	addsc.a %a6,%a6,%d5,0
80004720:	01 55 00 56 	addsc.a %a5,%a5,%d5,0
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
80004724:	6f 24 04 00 	jz.t %d4,2,8000472c <osEE_tc_C_init+0x8a>
        *block_dest.p_ui = *block_src.p_ui;
80004728:	44 6f       	ld.w %d15,[%a6+]
8000472a:	64 5f       	st.w [%a5+],%d15
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
8000472c:	6f 14 05 00 	jz.t %d4,1,80004736 <osEE_tc_C_init+0x94>
        *block_dest.p_us = *block_src.p_us;
80004730:	09 6f c2 00 	ld.hu %d15,[%a6+]2
80004734:	a4 5f       	st.h [%a5+],%d15
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80004736:	6f 04 04 00 	jz.t %d4,0,8000473e <osEE_tc_C_init+0x9c>
        *block_dest.p_uc = *block_src.p_uc;
8000473a:	0c 60       	ld.bu %d15,[%a6]0
8000473c:	2c 50       	st.b [%a5]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
8000473e:	d9 44 0c 00 	lea %a4,[%a4]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
80004742:	bc 48       	jz.a %a4,80004752 <osEE_tc_C_init+0xb0>
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
80004744:	d4 46       	ld.a %a6,[%a4]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
80004746:	99 45 04 00 	ld.a %a5,[%a4]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
8000474a:	19 44 08 00 	ld.w %d4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
8000474e:	df f4 d7 ff 	jne %d4,-1,800046fc <osEE_tc_C_init+0x5a>
80004752:	00 90       	ret 

80004754 <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004754:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004758:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000475c:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004760:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004764:	54 26       	ld.w %d6,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004766:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004768:	37 06 6e 61 	extr.u %d6,%d6,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000476c:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80004770:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004774:	8f f6 83 61 	xor %d6,%d6,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004778:	8f f8 83 81 	xor %d8,%d8,63
8000477c:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
80004780:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80004782:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80004786:	3b 00 b8 f0 	mov %d15,2944
8000478a:	cd 4f e0 0f 	mtcr $psw,%d15
8000478e:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80004792:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80004796:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
8000479a:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000479e:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
800047a2:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
800047a6:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
800047a8:	16 ff       	and %d15,255
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
800047aa:	cd 42 20 09 	mtcr $pcon1,%d2
800047ae:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800047b2:	53 cf 20 f0 	mul %d15,%d15,12
800047b6:	10 22       	addsc.a %a2,%a2,%d15,0
800047b8:	54 22       	ld.w %d2,[%a2]
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
800047ba:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800047bc:	37 02 6e 21 	extr.u %d2,%d2,2,14
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
800047c0:	d9 2f 00 46 	lea %a15,[%a2]24832
800047c4:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
800047c8:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800047ca:	8f f2 83 21 	xor %d2,%d2,63
/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800047ce:	2e 16       	jz.t %d15,1,800047da <osEE_tc_core0_start+0x86>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800047d0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800047d4:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800047d8:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800047da:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800047de:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800047e2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800047e4:	4c f0       	ld.w %d15,[%a15]0
800047e6:	6f 0f ff ff 	jnz.t %d15,0,800047e4 <osEE_tc_core0_start+0x90>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
800047ea:	82 0f       	mov %d15,0
800047ec:	cd cf 20 09 	mtcr $pcon0,%d15
800047f0:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
800047f4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800047f6:	2e 16       	jz.t %d15,1,80004802 <osEE_tc_core0_start+0xae>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800047f8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800047fc:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004800:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004802:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80004806:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000480a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000480c:	4c f0       	ld.w %d15,[%a15]0
8000480e:	6f 0f ff 7f 	jz.t %d15,0,8000480c <osEE_tc_core0_start+0xb8>
80004812:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80004816:	16 ff       	and %d15,255
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004818:	53 cf 20 f0 	mul %d15,%d15,12
8000481c:	91 30 00 ff 	movh.a %a15,61443
80004820:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80004824:	10 ff       	addsc.a %a15,%a15,%d15,0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004826:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004828:	48 02       	ld.w %d2,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000482a:	d9 2f 00 46 	lea %a15,[%a2]24832
8000482e:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004832:	37 02 6e 21 	extr.u %d2,%d2,2,14
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004836:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004838:	8f f2 83 21 	xor %d2,%d2,63
/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000483c:	2e 16       	jz.t %d15,1,80004848 <osEE_tc_core0_start+0xf4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000483e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004842:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004846:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004848:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000484c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004850:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004852:	4c f0       	ld.w %d15,[%a15]0
80004854:	6f 0f ff ff 	jnz.t %d15,0,80004852 <osEE_tc_core0_start+0xfe>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80004858:	82 0f       	mov %d15,0
8000485a:	cd 0f 04 09 	mtcr $dcon0,%d15
8000485e:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004862:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004864:	2e 16       	jz.t %d15,1,80004870 <osEE_tc_core0_start+0x11c>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004866:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000486a:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000486e:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004870:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80004874:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004878:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000487a:	4c f0       	ld.w %d15,[%a15]0
8000487c:	6f 0f ff 7f 	jz.t %d15,0,8000487a <osEE_tc_core0_start+0x126>
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004880:	91 30 00 ff 	movh.a %a15,61443
80004884:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80004888:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000488a:	2e 16       	jz.t %d15,1,80004896 <osEE_tc_core0_start+0x142>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000488c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004890:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004894:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004896:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000489a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000489e:	91 30 00 ff 	movh.a %a15,61443
800048a2:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800048a6:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800048a8:	4c f0       	ld.w %d15,[%a15]0
800048aa:	91 30 00 2f 	movh.a %a2,61443
800048ae:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800048b2:	6f 0f fb ff 	jnz.t %d15,0,800048a8 <osEE_tc_core0_start+0x154>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
800048b6:	7b 00 00 f8 	movh %d15,32768
800048ba:	1b 0f 70 f0 	addi %d15,%d15,1792
800048be:	cd 4f e2 0f 	mtcr $btv,%d15
800048c2:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
800048c6:	7b 00 00 f8 	movh %d15,32768
800048ca:	1b 0f 00 f2 	addi %d15,%d15,8192
800048ce:	cd 0f e2 0f 	mtcr $biv,%d15
800048d2:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
800048d6:	7b 20 00 f7 	movh %d15,28674
800048da:	1b 0f b0 f9 	addi %d15,%d15,-25856
800048de:	cd 8f e2 0f 	mtcr $isp,%d15
800048e2:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
800048e6:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800048e8:	2e 16       	jz.t %d15,1,800048f4 <osEE_tc_core0_start+0x1a0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800048ea:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800048ee:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800048f2:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800048f4:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800048f8:	91 30 00 ff 	movh.a %a15,61443
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
800048fc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004900:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004904:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004906:	4c f0       	ld.w %d15,[%a15]0
80004908:	6f 0f ff 7f 	jz.t %d15,0,80004906 <osEE_tc_core0_start+0x1b2>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
8000490c:	91 10 00 f7 	movh.a %a15,28673
80004910:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80004914:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80004916:	91 10 00 f8 	movh.a %a15,32769
8000491a:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000491e:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
80004920:	91 10 00 f8 	movh.a %a15,32769
80004924:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80004928:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
#else
  osEE_tc_setareg(a9, &osEE_cdb_var_core0);
8000492a:	91 00 00 f8 	movh.a %a15,32768
8000492e:	d9 ff 34 20 	lea %a15,[%a15]180 <800000b4 <osEE_cdb_var_core0>>
80004932:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80004934:	7b 20 00 f7 	movh %d15,28674
80004938:	7b 20 00 47 	movh %d4,28674
8000493c:	1b 0f c0 59 	addi %d5,%d15,-25600
80004940:	1b 04 c0 4b 	addi %d4,%d4,-17408
80004944:	a2 54       	sub %d4,%d5
80004946:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80004948:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
8000494a:	df 04 16 00 	jeq %d4,0,80004976 <osEE_tc_core0_start+0x222>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
8000494e:	9a f4       	add %d15,%d4,-1
80004950:	06 6f       	sh %d15,6
80004952:	12 53       	add %d3,%d15,%d5

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004954:	82 00       	mov %d0,0
80004956:	60 3f       	mov.a %a15,%d3
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004958:	37 03 70 73 	extr.u %d7,%d3,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000495c:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000495e:	60 4f       	mov.a %a15,%d4
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80004960:	8f 43 1e 20 	sh %d2,%d3,-28
80004964:	1b 0f fc ff 	addi %d15,%d15,-64
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004968:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000496a:	37 27 10 28 	insert %d2,%d7,%d2,16,16
8000496e:	42 5f       	add %d15,%d5

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004970:	82 53       	mov %d3,5
80004972:	fd f0 ca 00 	loop %a15,80004b06 <osEE_tc_core0_start+0x3b2>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
80004976:	cd 82 e3 0f 	mtcr $fcx,%d2
8000497a:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
8000497e:	91 30 00 ff 	movh.a %a15,61443
80004982:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80004986:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004988:	2e 16       	jz.t %d15,1,80004994 <osEE_tc_core0_start+0x240>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000498a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000498e:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004992:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004994:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004998:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000499c:	91 30 00 ff 	movh.a %a15,61443
800049a0:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800049a4:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800049a6:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800049a8:	4c 20       	ld.w %d15,[%a2]0
800049aa:	91 30 00 ff 	movh.a %a15,61443
800049ae:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800049b2:	6f 0f fb ff 	jnz.t %d15,0,800049a8 <osEE_tc_core0_start+0x254>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
800049b6:	4c f1       	ld.w %d15,[%a15]4
800049b8:	96 08       	or %d15,8
800049ba:	68 1f       	st.w [%a15]4,%d15
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
800049bc:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800049be:	2e 16       	jz.t %d15,1,800049ca <osEE_tc_core0_start+0x276>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800049c0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800049c4:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800049c8:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800049ca:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800049ce:	91 30 00 ff 	movh.a %a15,61443
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
800049d2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800049d6:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800049da:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800049dc:	4c f0       	ld.w %d15,[%a15]0
800049de:	6f 0f ff 7f 	jz.t %d15,0,800049dc <osEE_tc_core0_start+0x288>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
800049e2:	91 30 00 ff 	movh.a %a15,61443
800049e6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800049ea:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
800049ec:	2e 16       	jz.t %d15,1,800049f8 <osEE_tc_core0_start+0x2a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
800049ee:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
800049f2:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
800049f6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
800049f8:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
800049fc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80004a00:	91 30 00 ff 	movh.a %a15,61443
80004a04:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80004a08:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80004a0a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80004a0c:	4c 20       	ld.w %d15,[%a2]0
80004a0e:	91 30 00 ff 	movh.a %a15,61443
80004a12:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80004a16:	6f 0f fb ff 	jnz.t %d15,0,80004a0c <osEE_tc_core0_start+0x2b8>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80004a1a:	4c f1       	ld.w %d15,[%a15]4
80004a1c:	96 08       	or %d15,8
80004a1e:	68 1f       	st.w [%a15]4,%d15
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
80004a20:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80004a22:	2e 16       	jz.t %d15,1,80004a2e <osEE_tc_core0_start+0x2da>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80004a24:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80004a28:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80004a2c:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80004a2e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004a32:	91 30 00 ff 	movh.a %a15,61443
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
80004a36:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004a3a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80004a3e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004a40:	4c f0       	ld.w %d15,[%a15]0
80004a42:	91 30 00 cf 	movh.a %a12,61443
80004a46:	d9 cc 30 36 	lea %a12,[%a12]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80004a4a:	6f 0f fb 7f 	jz.t %d15,0,80004a40 <osEE_tc_core0_start+0x2ec>
   re-enabled by ERIKA or by the Application */
  osEE_tc_disable_cpu_wdt(0U, cpu_wdt_pw);
  osEE_tc_disable_safety_wdt(safety_wdt_pw);

/* C initialization routine */
  osEE_tc_C_init();
80004a4e:	6d ff 2a fe 	call 800046a2 <osEE_tc_C_init>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
80004a52:	4c c0       	ld.w %d15,[%a12]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80004a54:	2e 16       	jz.t %d15,1,80004a60 <osEE_tc_core0_start+0x30c>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80004a56:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80004a5a:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80004a5e:	6c c0       	st.w [%a12]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80004a60:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80004a64:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80004a68:	91 30 00 ff 	movh.a %a15,61443
80004a6c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80004a70:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80004a72:	4c f0       	ld.w %d15,[%a15]0
80004a74:	6f 0f ff ff 	jnz.t %d15,0,80004a72 <osEE_tc_core0_start+0x31e>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
80004a78:	7b 20 22 f1 	movh %d15,4642
80004a7c:	1b 1f 10 f0 	addi %d15,%d15,257
80004a80:	91 30 00 ff 	movh.a %a15,61443
80004a84:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80004a88:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
80004a8a:	7b 00 00 f5 	movh %d15,20480
80004a8e:	1b 0f 10 f1 	addi %d15,%d15,4352
80004a92:	91 30 00 ff 	movh.a %a15,61443
80004a96:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80004a9a:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
80004a9c:	7b 70 00 f0 	movh %d15,7
80004aa0:	1b cf 01 f0 	addi %d15,%d15,28
80004aa4:	91 30 00 ff 	movh.a %a15,61443
80004aa8:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80004aac:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
80004aae:	4c f0       	ld.w %d15,[%a15]0
80004ab0:	6f 1f ff 7f 	jz.t %d15,1,80004aae <osEE_tc_core0_start+0x35a>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
80004ab4:	91 30 00 ff 	movh.a %a15,61443
80004ab8:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80004abc:	4c f0       	ld.w %d15,[%a15]0
80004abe:	6f 8f ff 7f 	jz.t %d15,8,80004abc <osEE_tc_core0_start+0x368>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
80004ac2:	7b c0 be 40 	movh %d4,3052
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
80004ac6:	91 30 00 ff 	movh.a %a15,61443
80004aca:	1b 04 20 4c 	addi %d4,%d4,-15872
80004ace:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80004ad2:	6d 00 13 04 	call 800052f8 <osEE_tc_set_pll_fsource>
80004ad6:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80004ad8:	2e 16       	jz.t %d15,1,80004ae4 <osEE_tc_core0_start+0x390>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80004ada:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80004ade:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80004ae2:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80004ae4:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004ae8:	91 30 00 ff 	movh.a %a15,61443
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
80004aec:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004af0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80004af4:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004af6:	4c f0       	ld.w %d15,[%a15]0
80004af8:	6f 0f ff 7f 	jz.t %d15,0,80004af6 <osEE_tc_core0_start+0x3a2>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
80004afc:	6d ff 2a fc 	call 80004350 <main>
80004b00:	02 24       	mov %d4,%d2
80004b02:	6d 00 c9 1d 	call 80008694 <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004b06:	60 f2       	mov.a %a2,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004b08:	37 0f 70 53 	extr.u %d5,%d15,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004b0c:	74 22       	st.w [%a2],%d2
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80004b0e:	8f 4f 1e 20 	sh %d2,%d15,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004b12:	02 24       	mov %d4,%d2

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004b14:	c2 f3       	add %d3,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004b16:	37 45 10 28 	insert %d2,%d5,%d4,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80004b1a:	76 36       	jz %d3,80004b26 <osEE_tc_core0_start+0x3d2>
80004b1c:	1b 0f fc ff 	addi %d15,%d15,-64
80004b20:	fc f3       	loop %a15,80004b06 <osEE_tc_core0_start+0x3b2>
80004b22:	1d ff 2a ff 	j 80004976 <osEE_tc_core0_start+0x222>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80004b26:	cd c2 e3 0f 	mtcr $lcx,%d2
80004b2a:	0d 00 c0 04 	isync 
80004b2e:	3c f7       	j 80004b1c <osEE_tc_core0_start+0x3c8>

80004b30 <osEE_tc_core1_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004b30:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004b34:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004b38:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004b3c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004b40:	19 22 0c 00 	ld.w %d2,[%a2]12 <f003000c <_SMALL_DATA4_+0x4002800c>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004b44:	48 06       	ld.w %d6,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004b46:	37 02 6e 21 	extr.u %d2,%d2,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004b4a:	37 06 6e 61 	extr.u %d6,%d6,2,14
80004b4e:	91 20 00 f6 	movh.a %a15,24578
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004b52:	8f f2 83 21 	xor %d2,%d2,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004b56:	8f f6 83 61 	xor %d6,%d6,63
80004b5a:	d9 ff 40 8b 	lea %a15,[%a15]-18944 <6001b600 <__USTACK1>>
80004b5e:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80004b60:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80004b64:	3b 00 b8 f0 	mov %d15,2944
80004b68:	cd 4f e0 0f 	mtcr $psw,%d15
80004b6c:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80004b70:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80004b74:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80004b78:	cd 0f e0 0f 	mtcr $pcxi,%d15
80004b7c:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80004b80:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80004b84:	82 13       	mov %d3,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80004b86:	16 ff       	and %d15,255
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80004b88:	cd 43 20 09 	mtcr $pcon1,%d3
80004b8c:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004b90:	53 cf 20 f0 	mul %d15,%d15,12
80004b94:	10 22       	addsc.a %a2,%a2,%d15,0
80004b96:	54 23       	ld.w %d3,[%a2]
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004b98:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004b9a:	37 03 6e 31 	extr.u %d3,%d3,2,14
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004b9e:	d9 2f 00 46 	lea %a15,[%a2]24832
80004ba2:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004ba6:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004ba8:	8f f3 83 31 	xor %d3,%d3,63
/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004bac:	2e 16       	jz.t %d15,1,80004bb8 <osEE_tc_core1_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004bae:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004bb2:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004bb6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004bb8:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004bbc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004bc0:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004bc2:	4c f0       	ld.w %d15,[%a15]0
80004bc4:	6f 0f ff ff 	jnz.t %d15,0,80004bc2 <osEE_tc_core1_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80004bc8:	82 0f       	mov %d15,0
80004bca:	cd cf 20 09 	mtcr $pcon0,%d15
80004bce:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004bd2:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004bd4:	2e 16       	jz.t %d15,1,80004be0 <osEE_tc_core1_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004bd6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004bda:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004bde:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004be0:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80004be4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004be8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004bea:	4c f0       	ld.w %d15,[%a15]0
80004bec:	6f 0f ff 7f 	jz.t %d15,0,80004bea <osEE_tc_core1_start+0xba>
80004bf0:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80004bf4:	16 ff       	and %d15,255
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004bf6:	53 cf 20 f0 	mul %d15,%d15,12
80004bfa:	91 30 00 ff 	movh.a %a15,61443
80004bfe:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80004c02:	10 ff       	addsc.a %a15,%a15,%d15,0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004c04:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004c06:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004c08:	d9 2f 00 46 	lea %a15,[%a2]24832
80004c0c:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004c10:	37 03 6e 31 	extr.u %d3,%d3,2,14
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004c14:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004c16:	8f f3 83 31 	xor %d3,%d3,63
/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004c1a:	2e 16       	jz.t %d15,1,80004c26 <osEE_tc_core1_start+0xf6>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004c1c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004c20:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004c24:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004c26:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004c2a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004c2e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004c30:	4c f0       	ld.w %d15,[%a15]0
80004c32:	6f 0f ff ff 	jnz.t %d15,0,80004c30 <osEE_tc_core1_start+0x100>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80004c36:	82 0f       	mov %d15,0
80004c38:	cd 0f 04 09 	mtcr $dcon0,%d15
80004c3c:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004c40:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004c42:	2e 16       	jz.t %d15,1,80004c4e <osEE_tc_core1_start+0x11e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004c44:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004c48:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004c4c:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004c4e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80004c52:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004c56:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004c58:	4c f0       	ld.w %d15,[%a15]0
80004c5a:	6f 0f ff 7f 	jz.t %d15,0,80004c58 <osEE_tc_core1_start+0x128>
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004c5e:	91 30 00 ff 	movh.a %a15,61443
80004c62:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80004c66:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004c68:	2e 16       	jz.t %d15,1,80004c74 <osEE_tc_core1_start+0x144>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004c6a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004c6e:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004c72:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004c74:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004c78:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004c7c:	91 30 00 ff 	movh.a %a15,61443
80004c80:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004c84:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004c86:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004c88:	4c 20       	ld.w %d15,[%a2]0
80004c8a:	91 30 00 ff 	movh.a %a15,61443
80004c8e:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80004c92:	6f 0f fb ff 	jnz.t %d15,0,80004c88 <osEE_tc_core1_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(1U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB1);
80004c96:	7b 00 00 f8 	movh %d15,32768
80004c9a:	1b 0f 70 f0 	addi %d15,%d15,1792
80004c9e:	cd 4f e2 0f 	mtcr $btv,%d15
80004ca2:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB1);
80004ca6:	7b 10 00 f8 	movh %d15,32769
80004caa:	1b 0f 00 fa 	addi %d15,%d15,-24576
80004cae:	cd 0f e2 0f 	mtcr $biv,%d15
80004cb2:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK1);
80004cb6:	7b 20 00 f6 	movh %d15,24578
80004cba:	1b 0f b0 fb 	addi %d15,%d15,-17664
80004cbe:	cd 8f e2 0f 	mtcr $isp,%d15
80004cc2:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004cc6:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004cc8:	2e 16       	jz.t %d15,1,80004cd4 <osEE_tc_core1_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004cca:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004cce:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004cd2:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004cd4:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004cd8:	91 30 00 2f 	movh.a %a2,61443
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
80004cdc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004ce0:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004ce4:	6c 20       	st.w [%a2]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004ce6:	4c 20       	ld.w %d15,[%a2]0
80004ce8:	6f 0f ff 7f 	jz.t %d15,0,80004ce6 <osEE_tc_core1_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(1U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
80004cec:	91 10 00 f7 	movh.a %a15,28673
80004cf0:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80004cf4:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80004cf6:	91 10 00 f8 	movh.a %a15,32769
80004cfa:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80004cfe:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
80004d00:	91 10 00 f8 	movh.a %a15,32769
80004d04:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80004d08:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
#else
  osEE_tc_setareg(a9, &osEE_cdb_var_core1);
80004d0a:	91 00 00 f8 	movh.a %a15,32768
80004d0e:	d9 ff 04 20 	lea %a15,[%a15]132 <80000084 <osEE_cdb_var_core1>>
80004d12:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80004d14:	7b 20 00 36 	movh %d3,24578
80004d18:	7b 20 00 56 	movh %d5,24578
80004d1c:	1b 03 c0 7b 	addi %d7,%d3,-17408
80004d20:	1b 05 c0 5d 	addi %d5,%d5,-9216
80004d24:	a2 75       	sub %d5,%d7
80004d26:	86 a5       	sha %d5,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80004d28:	82 0f       	mov %d15,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80004d2a:	df 05 18 00 	jeq %d5,0,80004d5a <osEE_tc_core1_start+0x22a>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80004d2e:	1b f5 ff 3f 	addi %d3,%d5,-1
80004d32:	06 63       	sh %d3,6
80004d34:	0b 73 00 40 	add %d4,%d3,%d7

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004d38:	82 01       	mov %d1,0
80004d3a:	60 4f       	mov.a %a15,%d4
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004d3c:	37 04 70 03 	extr.u %d0,%d4,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004d40:	68 01       	st.w [%a15]0,%d1
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004d42:	60 5f       	mov.a %a15,%d5
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80004d44:	8f 44 1e f0 	sh %d15,%d4,-28
80004d48:	1b 03 fc 3f 	addi %d3,%d3,-64
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004d4c:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004d4e:	37 f0 10 f8 	insert %d15,%d0,%d15,16,16
80004d52:	42 73       	add %d3,%d7

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004d54:	82 54       	mov %d4,5
80004d56:	fd f0 71 00 	loop %a15,80004e38 <osEE_tc_core1_start+0x308>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
80004d5a:	cd 8f e3 0f 	mtcr $fcx,%d15
80004d5e:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004d62:	91 30 00 ff 	movh.a %a15,61443
80004d66:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80004d6a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004d6c:	2e 16       	jz.t %d15,1,80004d78 <osEE_tc_core1_start+0x248>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004d6e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004d72:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004d76:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004d78:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004d7c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004d80:	91 30 00 ff 	movh.a %a15,61443
80004d84:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004d88:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004d8a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004d8c:	4c 20       	ld.w %d15,[%a2]0
80004d8e:	91 30 00 ff 	movh.a %a15,61443
80004d92:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80004d96:	6f 0f fb ff 	jnz.t %d15,0,80004d8c <osEE_tc_core1_start+0x25c>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
80004d9a:	91 30 00 2f 	movh.a %a2,61443
80004d9e:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80004da2:	4c 24       	ld.w %d15,[%a2]16
80004da4:	96 08       	or %d15,8
80004da6:	6c 24       	st.w [%a2]16,%d15
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004da8:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004daa:	2e 16       	jz.t %d15,1,80004db6 <osEE_tc_core1_start+0x286>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004dac:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004db0:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004db4:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004db6:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004dba:	91 30 00 2f 	movh.a %a2,61443
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
80004dbe:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004dc2:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004dc6:	6c 20       	st.w [%a2]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004dc8:	4c 20       	ld.w %d15,[%a2]0
80004dca:	6f 0f ff 7f 	jz.t %d15,0,80004dc8 <osEE_tc_core1_start+0x298>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
80004dce:	91 30 00 ff 	movh.a %a15,61443
80004dd2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80004dd6:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80004dd8:	2e 16       	jz.t %d15,1,80004de4 <osEE_tc_core1_start+0x2b4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80004dda:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80004dde:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80004de2:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80004de4:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80004de8:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80004dec:	91 30 00 ff 	movh.a %a15,61443
80004df0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80004df4:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80004df6:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80004df8:	4c 20       	ld.w %d15,[%a2]0
80004dfa:	91 30 00 ff 	movh.a %a15,61443
80004dfe:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80004e02:	6f 0f fb ff 	jnz.t %d15,0,80004df8 <osEE_tc_core1_start+0x2c8>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80004e06:	4c f1       	ld.w %d15,[%a15]4
80004e08:	96 08       	or %d15,8
80004e0a:	68 1f       	st.w [%a15]4,%d15
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
80004e0c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80004e0e:	2e 16       	jz.t %d15,1,80004e1a <osEE_tc_core1_start+0x2ea>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80004e10:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80004e14:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80004e18:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80004e1a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004e1e:	91 30 00 2f 	movh.a %a2,61443
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
80004e22:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004e26:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80004e2a:	6c 20       	st.w [%a2]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80004e2c:	4c 20       	ld.w %d15,[%a2]0
80004e2e:	6f 0f ff 7f 	jz.t %d15,0,80004e2c <osEE_tc_core1_start+0x2fc>
/* C core 1 private initialization */
  _c_init_tc1();
#endif /* __TASKING__ */

/* Call main function */
  (void)main();
80004e32:	6d ff 8f fa 	call 80004350 <main>

/* TODO: handle main return */
  for (;;) {
    ;
  }
80004e36:	3c 00       	j 80004e36 <osEE_tc_core1_start+0x306>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004e38:	60 32       	mov.a %a2,%d3
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004e3a:	37 03 70 73 	extr.u %d7,%d3,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80004e3e:	6c 20       	st.w [%a2]0,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80004e40:	8f 43 1e f0 	sh %d15,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004e44:	02 f5       	mov %d5,%d15

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80004e46:	c2 f4       	add %d4,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80004e48:	37 57 10 f8 	insert %d15,%d7,%d5,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80004e4c:	76 45       	jz %d4,80004e56 <osEE_tc_core1_start+0x326>
80004e4e:	1b 03 fc 3f 	addi %d3,%d3,-64
80004e52:	fc f3       	loop %a15,80004e38 <osEE_tc_core1_start+0x308>
80004e54:	3c 83       	j 80004d5a <osEE_tc_core1_start+0x22a>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80004e56:	cd cf e3 0f 	mtcr $lcx,%d15
80004e5a:	0d 00 c0 04 	isync 
80004e5e:	3c f8       	j 80004e4e <osEE_tc_core1_start+0x31e>

80004e60 <osEE_tc_core2_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004e60:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004e64:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004e68:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004e6c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004e70:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x40028018>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004e74:	48 06       	ld.w %d6,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004e76:	37 02 6e 21 	extr.u %d2,%d2,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80004e7a:	37 06 6e 61 	extr.u %d6,%d6,2,14
80004e7e:	91 20 00 f5 	movh.a %a15,20482
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004e82:	8f f2 83 21 	xor %d2,%d2,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004e86:	8f f6 83 61 	xor %d6,%d6,63
80004e8a:	d9 ff 40 8b 	lea %a15,[%a15]-18944 <5001b600 <__USTACK2>>
80004e8e:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80004e90:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80004e94:	3b 00 b8 f0 	mov %d15,2944
80004e98:	cd 4f e0 0f 	mtcr $psw,%d15
80004e9c:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80004ea0:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80004ea4:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80004ea8:	cd 0f e0 0f 	mtcr $pcxi,%d15
80004eac:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80004eb0:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80004eb4:	82 13       	mov %d3,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80004eb6:	16 ff       	and %d15,255
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80004eb8:	cd 43 20 09 	mtcr $pcon1,%d3
80004ebc:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004ec0:	53 cf 20 f0 	mul %d15,%d15,12
80004ec4:	10 22       	addsc.a %a2,%a2,%d15,0
80004ec6:	54 23       	ld.w %d3,[%a2]
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004ec8:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004eca:	37 03 6e 31 	extr.u %d3,%d3,2,14
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004ece:	d9 2f 00 46 	lea %a15,[%a2]24832
80004ed2:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004ed6:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004ed8:	8f f3 83 31 	xor %d3,%d3,63
/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004edc:	2e 16       	jz.t %d15,1,80004ee8 <osEE_tc_core2_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004ede:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004ee2:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004ee6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004ee8:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004eec:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004ef0:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004ef2:	4c f0       	ld.w %d15,[%a15]0
80004ef4:	6f 0f ff ff 	jnz.t %d15,0,80004ef2 <osEE_tc_core2_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80004ef8:	82 0f       	mov %d15,0
80004efa:	cd cf 20 09 	mtcr $pcon0,%d15
80004efe:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004f02:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004f04:	2e 16       	jz.t %d15,1,80004f10 <osEE_tc_core2_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004f06:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004f0a:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004f0e:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004f10:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80004f14:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004f18:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004f1a:	4c f0       	ld.w %d15,[%a15]0
80004f1c:	6f 0f ff 7f 	jz.t %d15,0,80004f1a <osEE_tc_core2_start+0xba>
80004f20:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80004f24:	16 ff       	and %d15,255
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004f26:	53 cf 20 f0 	mul %d15,%d15,12
80004f2a:	91 30 00 ff 	movh.a %a15,61443
80004f2e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80004f32:	10 ff       	addsc.a %a15,%a15,%d15,0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004f34:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004f36:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80004f38:	d9 2f 00 46 	lea %a15,[%a2]24832
80004f3c:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80004f40:	37 03 6e 31 	extr.u %d3,%d3,2,14
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004f44:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80004f46:	8f f3 83 31 	xor %d3,%d3,63
/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004f4a:	2e 16       	jz.t %d15,1,80004f56 <osEE_tc_core2_start+0xf6>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004f4c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004f50:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004f54:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004f56:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004f5a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004f5e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004f60:	4c f0       	ld.w %d15,[%a15]0
80004f62:	6f 0f ff ff 	jnz.t %d15,0,80004f60 <osEE_tc_core2_start+0x100>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80004f66:	82 0f       	mov %d15,0
80004f68:	cd 0f 04 09 	mtcr $dcon0,%d15
80004f6c:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004f70:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004f72:	2e 16       	jz.t %d15,1,80004f7e <osEE_tc_core2_start+0x11e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004f74:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004f78:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004f7c:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80004f7e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80004f82:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004f86:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80004f88:	4c f0       	ld.w %d15,[%a15]0
80004f8a:	6f 0f ff 7f 	jz.t %d15,0,80004f88 <osEE_tc_core2_start+0x128>
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004f8e:	91 30 00 ff 	movh.a %a15,61443
80004f92:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
80004f96:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004f98:	2e 16       	jz.t %d15,1,80004fa4 <osEE_tc_core2_start+0x144>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004f9a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004f9e:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80004fa2:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80004fa4:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80004fa8:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004fac:	91 30 00 ff 	movh.a %a15,61443
80004fb0:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004fb4:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80004fb6:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80004fb8:	4c 20       	ld.w %d15,[%a2]0
80004fba:	91 30 00 ff 	movh.a %a15,61443
80004fbe:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
80004fc2:	6f 0f fb ff 	jnz.t %d15,0,80004fb8 <osEE_tc_core2_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(2U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB2);
80004fc6:	7b 00 00 f8 	movh %d15,32768
80004fca:	1b 0f 70 f0 	addi %d15,%d15,1792
80004fce:	cd 4f e2 0f 	mtcr $btv,%d15
80004fd2:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB2);
80004fd6:	7b 10 00 f8 	movh %d15,32769
80004fda:	1b 0f 00 fc 	addi %d15,%d15,-16384
80004fde:	cd 0f e2 0f 	mtcr $biv,%d15
80004fe2:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK2);
80004fe6:	7b 20 00 f5 	movh %d15,20482
80004fea:	1b 0f b0 fb 	addi %d15,%d15,-17664
80004fee:	cd 8f e2 0f 	mtcr $isp,%d15
80004ff2:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80004ff6:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80004ff8:	2e 16       	jz.t %d15,1,80005004 <osEE_tc_core2_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80004ffa:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80004ffe:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80005002:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80005004:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80005008:	91 30 00 2f 	movh.a %a2,61443
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
8000500c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80005010:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80005014:	6c 20       	st.w [%a2]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80005016:	4c 20       	ld.w %d15,[%a2]0
80005018:	6f 0f ff 7f 	jz.t %d15,0,80005016 <osEE_tc_core2_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(2U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
8000501c:	91 10 00 f7 	movh.a %a15,28673
80005020:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80005024:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80005026:	91 10 00 f8 	movh.a %a15,32769
8000502a:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000502e:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
80005030:	91 10 00 f8 	movh.a %a15,32769
80005034:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80005038:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
#else
  osEE_tc_setareg(a9, &osEE_cdb_var_core2);
8000503a:	91 00 00 f8 	movh.a %a15,32768
8000503e:	d9 ff 14 10 	lea %a15,[%a15]84 <80000054 <osEE_cdb_var_core2>>
80005042:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80005044:	7b 20 00 35 	movh %d3,20482
80005048:	7b 20 00 55 	movh %d5,20482
8000504c:	1b 03 c0 7b 	addi %d7,%d3,-17408
80005050:	1b 05 c0 5d 	addi %d5,%d5,-9216
80005054:	a2 75       	sub %d5,%d7
80005056:	86 a5       	sha %d5,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80005058:	82 0f       	mov %d15,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
8000505a:	df 05 18 00 	jeq %d5,0,8000508a <osEE_tc_core2_start+0x22a>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
8000505e:	1b f5 ff 3f 	addi %d3,%d5,-1
80005062:	06 63       	sh %d3,6
80005064:	0b 73 00 40 	add %d4,%d3,%d7

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80005068:	82 01       	mov %d1,0
8000506a:	60 4f       	mov.a %a15,%d4
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000506c:	37 04 70 03 	extr.u %d0,%d4,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80005070:	68 01       	st.w [%a15]0,%d1
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80005072:	60 5f       	mov.a %a15,%d5
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80005074:	8f 44 1e f0 	sh %d15,%d4,-28
80005078:	1b 03 fc 3f 	addi %d3,%d3,-64
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000507c:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000507e:	37 f0 10 f8 	insert %d15,%d0,%d15,16,16
80005082:	42 73       	add %d3,%d7

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80005084:	82 54       	mov %d4,5
80005086:	fd f0 71 00 	loop %a15,80005168 <osEE_tc_core2_start+0x308>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
8000508a:	cd 8f e3 0f 	mtcr $fcx,%d15
8000508e:	0d 00 c0 04 	isync 
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
80005092:	91 30 00 ff 	movh.a %a15,61443
80005096:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
8000509a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000509c:	2e 16       	jz.t %d15,1,800050a8 <osEE_tc_core2_start+0x248>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000509e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800050a2:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800050a6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800050a8:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800050ac:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800050b0:	91 30 00 ff 	movh.a %a15,61443
800050b4:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800050b8:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800050ba:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800050bc:	4c 20       	ld.w %d15,[%a2]0
800050be:	91 30 00 ff 	movh.a %a15,61443
800050c2:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
800050c6:	6f 0f fb ff 	jnz.t %d15,0,800050bc <osEE_tc_core2_start+0x25c>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
800050ca:	91 30 00 2f 	movh.a %a2,61443
800050ce:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800050d2:	4c 27       	ld.w %d15,[%a2]28
800050d4:	96 08       	or %d15,8
800050d6:	6c 27       	st.w [%a2]28,%d15
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  OsEE_tc_SCU_WDTCPU_CON0
    cpu_wdt_con0 = p_cpu_wdt->con0;
800050d8:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800050da:	2e 16       	jz.t %d15,1,800050e6 <osEE_tc_core2_start+0x286>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800050dc:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800050e0:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800050e4:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800050e6:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800050ea:	91 30 00 2f 	movh.a %a2,61443
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
800050ee:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800050f2:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
  cpu_wdt_con0.bits.lck     = 1U;
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800050f6:	6c 20       	st.w [%a2]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800050f8:	4c 20       	ld.w %d15,[%a2]0
800050fa:	6f 0f ff 7f 	jz.t %d15,0,800050f8 <osEE_tc_core2_start+0x298>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
800050fe:	91 30 00 ff 	movh.a %a15,61443
80005102:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80005106:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80005108:	2e 16       	jz.t %d15,1,80005114 <osEE_tc_core2_start+0x2b4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000510a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000510e:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80005112:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80005114:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80005118:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000511c:	91 30 00 ff 	movh.a %a15,61443
80005120:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80005124:	40 f2       	mov.aa %a2,%a15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80005126:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80005128:	4c 20       	ld.w %d15,[%a2]0
8000512a:	91 30 00 ff 	movh.a %a15,61443
8000512e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80005132:	6f 0f fb ff 	jnz.t %d15,0,80005128 <osEE_tc_core2_start+0x2c8>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80005136:	4c f1       	ld.w %d15,[%a15]4
80005138:	96 08       	or %d15,8
8000513a:	68 1f       	st.w [%a15]4,%d15
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0
    safety_wdt_con0 = OSEE_TC_SCU_WDTS.con0;
8000513c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000513e:	2e 16       	jz.t %d15,1,8000514a <osEE_tc_core2_start+0x2ea>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80005140:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80005144:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80005148:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000514a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000514e:	91 30 00 2f 	movh.a %a2,61443
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
80005152:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80005156:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
  safety_wdt_con0.bits.lck     = 1U;
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
8000515a:	6c 20       	st.w [%a2]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000515c:	4c 20       	ld.w %d15,[%a2]0
8000515e:	6f 0f ff 7f 	jz.t %d15,0,8000515c <osEE_tc_core2_start+0x2fc>
/* C core 2 private initialization */
  _c_init_tc2();
#endif /* __TASKING__ */

/* Call main function */
  (void)main();
80005162:	6d ff f7 f8 	call 80004350 <main>
  
/* TODO: handle main return */
  for (;;) {
    ;
  }
80005166:	3c 00       	j 80005166 <osEE_tc_core2_start+0x306>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80005168:	60 32       	mov.a %a2,%d3
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000516a:	37 03 70 73 	extr.u %d7,%d3,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000516e:	6c 20       	st.w [%a2]0,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80005170:	8f 43 1e f0 	sh %d15,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80005174:	02 f5       	mov %d5,%d15

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80005176:	c2 f4       	add %d4,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80005178:	37 57 10 f8 	insert %d15,%d7,%d5,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
8000517c:	76 45       	jz %d4,80005186 <osEE_tc_core2_start+0x326>
8000517e:	1b 03 fc 3f 	addi %d3,%d3,-64
80005182:	fc f3       	loop %a15,80005168 <osEE_tc_core2_start+0x308>
80005184:	3c 83       	j 8000508a <osEE_tc_core2_start+0x22a>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80005186:	cd cf e3 0f 	mtcr $lcx,%d15
8000518a:	0d 00 c0 04 	isync 
8000518e:	3c f8       	j 8000517e <osEE_tc_core2_start+0x31e>

80005190 <osEE_tc_stm_us_ticks>:
#if (defined(__TASKING__))
#define OS_STOP_SEC_GLOBAL_VAR_CLEARED
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
80005190:	40 ae       	mov.aa %a14,%sp
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
80005192:	91 00 00 f7 	movh.a %a15,28672
80005196:	19 ff 18 00 	ld.w %d15,[%a15]24 <70000018 <osEE_tc_stm_freq_khz>>
8000519a:	3b 80 3e 20 	mov %d2,1000
8000519e:	3f 2f 0c 80 	jlt.u %d15,%d2,800051b6 <osEE_tc_stm_us_ticks+0x26>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
800051a2:	7b 20 06 21 	movh %d2,4194
800051a6:	1b 32 dd 24 	addi %d2,%d2,19923
800051aa:	73 2f 68 20 	mul.u %e2,%d15,%d2
800051ae:	8f a3 1f 20 	sh %d2,%d3,-6
800051b2:	e2 42       	mul %d2,%d4
800051b4:	00 90       	ret 
  } else if (usec >= OSEE_KILO) {
800051b6:	02 25       	mov %d5,%d2
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
800051b8:	73 f4 0a 20 	mul %d2,%d4,%d15
800051bc:	7b 20 06 31 	movh %d3,4194
800051c0:	1b 33 dd 34 	addi %d3,%d3,19923
800051c4:	73 32 68 20 	mul.u %e2,%d2,%d3
800051c8:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
800051cc:	3f 54 0b 80 	jlt.u %d4,%d5,800051e2 <osEE_tc_stm_us_ticks+0x52>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
800051d0:	7b 20 06 21 	movh %d2,4194
800051d4:	1b 32 dd 24 	addi %d2,%d2,19923
800051d8:	73 24 68 40 	mul.u %e4,%d4,%d2
800051dc:	8f a5 1f 20 	sh %d2,%d5,-6
800051e0:	e2 f2       	mul %d2,%d15
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
  }
  return ticks;
}
800051e2:	00 90       	ret 

800051e4 <osEE_tc_stm_set_sr0_next_match>:
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
  }
}

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0_next_match(OsEE_reg usec)
{
800051e4:	40 ae       	mov.aa %a14,%sp
800051e6:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
800051ea:	5c d3       	call 80005190 <osEE_tc_stm_us_ticks>
800051ec:	16 03       	and %d15,3
800051ee:	9b 0f 0f f0 	addih %d15,%d15,240
800051f2:	8f 8f 00 f0 	sh %d15,%d15,8
800051f6:	60 ff       	mov.a %a15,%d15
800051f8:	4c fc       	ld.w %d15,[%a15]48
800051fa:	42 f2       	add %d2,%d15
800051fc:	68 c2       	st.w [%a15]48,%d2
800051fe:	00 90       	ret 

80005200 <osEE_tc_stm_set_sr0>:
    that qualifier on pointers.
 */

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0(OsEE_reg usec,
    OsEE_tc_isr_hw_prio intvec)
{
80005200:	40 ae       	mov.aa %a14,%sp
80005202:	02 58       	mov %d8,%d5
80005204:	4d c0 e1 ff 	mfcr %d15,$core_id
    5U;
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80005208:	5c c4       	call 80005190 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000520a:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
8000520e:	16 03       	and %d15,3
80005210:	9b 0f 0f 40 	addih %d4,%d15,240
80005214:	8f 84 00 40 	sh %d4,%d4,8
80005218:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
8000521a:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
8000521c:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
8000521e:	68 c2       	st.w [%a15]48,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80005220:	df 08 22 00 	jeq %d8,0,80005264 <osEE_tc_stm_set_sr0+0x64>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
80005224:	48 e2       	ld.w %d2,[%a15]56
80005226:	b7 02 05 24 	insert %d2,%d2,0,8,5
8000522a:	68 e2       	st.w [%a15]56,%d2
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
8000522c:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
80005230:	48 e2       	ld.w %d2,[%a15]56
80005232:	37 32 05 30 	insert %d3,%d2,%d3,0,5
80005236:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
80005238:	48 f2       	ld.w %d2,[%a15]60
8000523a:	8f 42 c0 21 	andn %d2,%d2,4
8000523e:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
80005240:	48 f2       	ld.w %d2,[%a15]60
80005242:	8f 12 40 21 	or %d2,%d2,1
80005246:	68 f2       	st.w [%a15]60,%d2

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
80005248:	8f 3f 00 20 	sh %d2,%d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000524c:	60 22       	mov.a %a2,%d2
8000524e:	d9 2f 50 28 	lea %a15,[%a2]-31600
80005252:	11 4f 00 ff 	addih.a %a15,%a15,61444
80005256:	b7 88 99 83 	insert %d8,%d8,8,7,25
8000525a:	8f bf 00 f0 	sh %d15,%d15,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000525e:	a6 8f       	or %d15,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80005260:	68 0f       	st.w [%a15]0,%d15
80005262:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en                 = 0U;
80005264:	48 f2       	ld.w %d2,[%a15]60
80005266:	8f 12 c0 21 	andn %d2,%d2,1
8000526a:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
8000526c:	1b 2f 09 f7 	addi %d15,%d15,28818
80005270:	9b 0f e0 f1 	addih %d15,%d15,7680
80005274:	06 3f       	sh %d15,3
80005276:	82 02       	mov %d2,0
80005278:	60 ff       	mov.a %a15,%d15
8000527a:	68 02       	st.w [%a15]0,%d2
8000527c:	00 90       	ret 

8000527e <osEE_tricore_system_timer_handler>:
  (OSEE_SYSTEM_TIMER_CORE6_DEVICE != OSEE_TC_STM_SR1)
#error Unsupported Device for CORE6 as System Timer!
#endif
#endif /* OSEE_SYSTEM_TIMER_CORE6_DEVICE */

void osEE_tricore_system_timer_handler(void) {
8000527e:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80005280:	4d c0 e1 ff 	mfcr %d15,$core_id
  osEE_tc_stm_set_sr0_next_match(OSTICKDURATION / 1000U);
#elif (OSEE_SYSTEM_TIMER_DEVICE == OSEE_TC_STM_SR1)
  osEE_tc_stm_set_sr1_next_match(OSTICKDURATION / 1000U);
#endif /* OSEE_SYSTEM_TIMER_DEVICE */
#else /* OSEE_SINGLECORE */
  switch (osEE_get_curr_core_id()) {
80005284:	16 ff       	and %d15,255
80005286:	1e 18       	jeq %d15,1,80005296 <osEE_tricore_system_timer_handler+0x18>
80005288:	6e 03       	jz %d15,8000528e <osEE_tricore_system_timer_handler+0x10>
8000528a:	1e 2a       	jeq %d15,2,8000529e <osEE_tricore_system_timer_handler+0x20>
8000528c:	3c 0c       	j 800052a4 <osEE_tricore_system_timer_handler+0x26>
#if (defined(OSEE_SYSTEM_TIMER_CORE0_DEVICE))
    case OS_CORE_ID_MASTER:
#if (OSEE_SYSTEM_TIMER_CORE0_DEVICE == OSEE_TC_STM_SR0)
      osEE_tc_stm_set_sr0_next_match(OSTICKDURATION_CORE0 / 1000U);
8000528e:	3b 00 71 42 	mov %d4,10000
80005292:	5c a9       	call 800051e4 <osEE_tc_stm_set_sr0_next_match>
#elif (OSEE_SYSTEM_TIMER_CORE0_DEVICE == OSEE_TC_STM_SR1)
      osEE_tc_stm_set_sr1_next_match(OSTICKDURATION_CORE0 / 1000U);
#endif
    break;
80005294:	3c 08       	j 800052a4 <osEE_tricore_system_timer_handler+0x26>
#endif /* OSEE_SYSTEM_TIMER_CORE0_DEVICE */
#if (defined(OSEE_SYSTEM_TIMER_CORE1_DEVICE))
    case OS_CORE_ID_1:
#if (OSEE_SYSTEM_TIMER_CORE1_DEVICE == OSEE_TC_STM_SR0)
      osEE_tc_stm_set_sr0_next_match(OSTICKDURATION_CORE1 / 1000U);
80005296:	3b 00 71 42 	mov %d4,10000
8000529a:	5c a5       	call 800051e4 <osEE_tc_stm_set_sr0_next_match>
#elif (OSEE_SYSTEM_TIMER_CORE1_DEVICE == OSEE_TC_STM_SR1)
      osEE_tc_stm_set_sr1_next_match(OSTICKDURATION_CORE1 / 1000U);
#endif
    break;
8000529c:	3c 04       	j 800052a4 <osEE_tricore_system_timer_handler+0x26>
#endif /* OSEE_SYSTEM_TIMER_CORE1_DEVICE */
#if (defined(OSEE_SYSTEM_TIMER_CORE2_DEVICE))
    case OS_CORE_ID_2:
#if (OSEE_SYSTEM_TIMER_CORE2_DEVICE == OSEE_TC_STM_SR0)
      osEE_tc_stm_set_sr0_next_match(OSTICKDURATION_CORE2 / 1000U);
8000529e:	3b 80 3e 40 	mov %d4,1000
800052a2:	5c a1       	call 800051e4 <osEE_tc_stm_set_sr0_next_match>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
800052a4:	40 9f       	mov.aa %a15,%a9
      break;
  }
#endif /* OSEE_SINGLECORE */

  p_cdb = osEE_get_curr_core();
  osEE_counter_increment(p_cdb->p_sys_counter_db);
800052a6:	c8 64       	ld.a %a4,[%a15]24
800052a8:	6d 00 5a 14 	call 80007b5c <osEE_counter_increment>
800052ac:	00 90       	ret 

800052ae <osEE_tc_initialize_system_timer>:
}

/* System Timer Initialization */
void osEE_tc_initialize_system_timer(OsEE_TDB * p_tdb) {
800052ae:	40 ae       	mov.aa %a14,%sp
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
800052b0:	39 45 1c 00 	ld.bu %d5,[%a4]28
800052b4:	8f f5 07 51 	and %d5,%d5,127
800052b8:	c2 15       	add %d5,1
800052ba:	4d c0 e1 ff 	mfcr %d15,$core_id
  osEE_tc_stm_set_sr0(OSTICKDURATION / 1000U, isr2_prio);
#elif (OSEE_SYSTEM_TIMER_DEVICE == OSEE_TC_STM_SR1)
  osEE_tc_stm_set_sr1(OSTICKDURATION / 1000U, isr2_prio);
#endif
#else /* OSEE_SINGLECORE */
  switch (osEE_get_curr_core_id()) {
800052be:	16 ff       	and %d15,255
800052c0:	1e 1c       	jeq %d15,1,800052d8 <osEE_tc_initialize_system_timer+0x2a>
800052c2:	6e 03       	jz %d15,800052c8 <osEE_tc_initialize_system_timer+0x1a>
800052c4:	9e 22       	jeq %d15,2,800052e8 <osEE_tc_initialize_system_timer+0x3a>
800052c6:	00 90       	ret 
 * @brief  Used to set STM suspension when OCDS take control
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_stm_ocds_suspend_control(OsEE_reg stm_id)
{
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_OCS_OFF) =
800052c8:	7b 00 20 f1 	movh %d15,4608
800052cc:	a5 ff 28 30 	st.w f00000e8 <_SMALL_DATA4_+0x3fff80e8>,%d15
    case OS_CORE_ID_MASTER:
#if (defined(OSEE_DEBUG))
      osEE_tc_stm_ocds_suspend_control(0U);
#endif /* OSEE_DEBUG */
#if (OSEE_SYSTEM_TIMER_CORE0_DEVICE == OSEE_TC_STM_SR0)
      osEE_tc_stm_set_sr0(OSTICKDURATION_CORE0 / 1000U, isr2_prio);
800052d0:	3b 00 71 42 	mov %d4,10000
800052d4:	5c 96       	call 80005200 <osEE_tc_stm_set_sr0>
#elif (OSEE_SYSTEM_TIMER_CORE0_DEVICE == OSEE_TC_STM_SR1)
      osEE_tc_stm_set_sr1(OSTICKDURATION_CORE0 / 1000U, isr2_prio);
#endif
    break;
800052d6:	00 90       	ret 
800052d8:	7b 00 20 f1 	movh %d15,4608
800052dc:	a5 ff 28 70 	st.w f00001e8 <_SMALL_DATA4_+0x3fff81e8>,%d15
    case OS_CORE_ID_1:
#if (defined(OSEE_DEBUG))
      osEE_tc_stm_ocds_suspend_control(1U);
#endif /* OSEE_DEBUG */
#if (OSEE_SYSTEM_TIMER_CORE1_DEVICE == OSEE_TC_STM_SR0)
      osEE_tc_stm_set_sr0(OSTICKDURATION_CORE1 / 1000U, isr2_prio);
800052e0:	3b 00 71 42 	mov %d4,10000
800052e4:	5c 8e       	call 80005200 <osEE_tc_stm_set_sr0>
#elif (OSEE_SYSTEM_TIMER_CORE1_DEVICE == OSEE_TC_STM_SR1)
      osEE_tc_stm_set_sr1(OSTICKDURATION_CORE1 / 1000U, isr2_prio);
#endif
    break;
800052e6:	00 90       	ret 
800052e8:	7b 00 20 f1 	movh %d15,4608
800052ec:	a5 ff 28 b0 	st.w f00002e8 <_SMALL_DATA4_+0x3fff82e8>,%d15
    case OS_CORE_ID_2:
#if (defined(OSEE_DEBUG))
      osEE_tc_stm_ocds_suspend_control(2U);
#endif /* OSEE_DEBUG */
#if (OSEE_SYSTEM_TIMER_CORE2_DEVICE == OSEE_TC_STM_SR0)
      osEE_tc_stm_set_sr0(OSTICKDURATION_CORE2 / 1000U, isr2_prio);
800052f0:	3b 80 3e 40 	mov %d4,1000
800052f4:	5c 86       	call 80005200 <osEE_tc_stm_set_sr0>
800052f6:	00 90       	ret 

800052f8 <osEE_tc_set_pll_fsource>:
#define OSEE_TC_K2_MIN      (1U)
#define OSEE_TC_N_MAX       (128U)  /* '7 bits */
#define OSEE_TC_N_MIN       (1U)
#define OSEE_TC_DEV_ALLOWED (2U)

void osEE_tc_set_pll_fsource(OsEE_reg fpll) {
800052f8:	40 ae       	mov.aa %a14,%sp
  fPllLeastError  = OSEE_TC_CLOCK_MAX;
  fPllError       = OSEE_TC_CLOCK_MAX;

  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
800052fa:	7b e0 e4 20 	movh %d2,3662
800052fe:	1b 12 c0 21 	addi %d2,%d2,7169
80005302:	0b 24 30 f1 	lt.u %d15,%d4,%d2
80005306:	82 22       	mov %d2,2
80005308:	ab 12 80 ff 	sel %d15,%d15,%d2,1
8000530c:	60 f4       	mov.a %a4,%d15
8000530e:	53 ff 20 f0 	mul %d15,%d15,15
80005312:	60 f5       	mov.a %a5,%d15
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80005314:	3b 00 01 e0 	mov %d14,16
80005318:	82 03       	mov %d3,0
8000531a:	7b c0 be 20 	movh %d2,3052
8000531e:	1b 02 20 2c 	addi %d2,%d2,-15872
80005322:	02 28       	mov %d8,%d2
80005324:	82 01       	mov %d1,0
80005326:	82 0b       	mov %d11,0
80005328:	82 0d       	mov %d13,0
8000532a:	82 0c       	mov %d12,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000532c:	7b 10 13 a0 	movh %d10,305
80005330:	1b 0a d0 a2 	addi %d10,%d10,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80005334:	91 40 0f 60 	movh.a %a6,244
80005338:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
    {
      for (
8000533c:	a0 1d       	mov.a %a13,1
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
8000533e:	53 14 40 60 	mul.u %e6,%d4,1
80005342:	60 62       	mov.a %a2,%d6
80005344:	60 73       	mov.a %a3,%d7

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80005346:	91 80 7d f1 	movh.a %a15,6104
8000534a:	d9 ff 41 08 	lea %a15,[%a15]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
        {
          for (
8000534e:	a0 1c       	mov.a %a12,1
80005350:	3c 5e       	j 8000540c <osEE_tc_set_pll_fsource+0x114>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80005352:	4b ea 11 62 	div.u %e6,%d10,%d14
80005356:	82 07       	mov %d7,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80005358:	7b 60 f8 ff 	movh %d15,65414
8000535c:	1b 0f e0 fe 	addi %d15,%d15,-4608
80005360:	0b f6 40 60 	addx %d6,%d6,%d15
80005364:	8b f7 bf 50 	addc %d5,%d7,-1
80005368:	ba 05       	eq %d15,%d5,0
8000536a:	80 67       	mov.d %d7,%a6
8000536c:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80005370:	8b 05 00 f5 	or.ne %d15,%d5,0
80005374:	ee 4a       	jnz %d15,80005408 <osEE_tc_set_pll_fsource+0x110>
    {
      for (
80005376:	df 00 56 00 	jeq %d0,0,80005422 <osEE_tc_set_pll_fsource+0x12a>
8000537a:	02 e9       	mov %d9,%d14
8000537c:	80 d0       	mov.d %d0,%a13
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000537e:	60 e7       	mov.a %a7,%d14
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80005380:	80 2f       	mov.d %d15,%a2
80005382:	73 f0 68 60 	mul.u %e6,%d0,%d15
80005386:	80 3f       	mov.d %d15,%a3
80005388:	03 f0 0a 77 	madd %d7,%d7,%d0,%d15

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000538c:	7b 80 82 fe 	movh %d15,59432
80005390:	1b 0f c0 f7 	addi %d15,%d15,31744
80005394:	0b f6 40 60 	addx %d6,%d6,%d15
80005398:	8b f7 bf 50 	addc %d5,%d7,-1
8000539c:	ba 05       	eq %d15,%d5,0
8000539e:	80 f7       	mov.d %d7,%a15
800053a0:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
800053a4:	8b 05 00 f5 	or.ne %d15,%d5,0
800053a8:	ee 25       	jnz %d15,800053f2 <osEE_tc_set_pll_fsource+0xfa>
        {
          for (
800053aa:	0f 23 a0 f0 	or %d15,%d3,%d2
800053ae:	6e 2d       	jz %d15,80005408 <osEE_tc_set_pll_fsource+0x110>
800053b0:	80 c6       	mov.d %d6,%a12
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
800053b2:	4b 96 11 22 	div.u %e2,%d6,%d9
800053b6:	02 2f       	mov %d15,%d2
800053b8:	e2 af       	mul %d15,%d10
800053ba:	a2 4f       	sub %d15,%d4
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
800053bc:	53 1f 40 20 	mul.u %e2,%d15,1
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800053c0:	df 0f ac 00 	jeq %d15,0,80005518 <osEE_tc_set_pll_fsource+0x220>
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
800053c4:	0b 13 00 51 	eq %d5,%d3,%d1
800053c8:	0b 8f 50 52 	and.ge.u %d5,%d15,%d8
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
800053cc:	2b f8 40 85 	sel %d8,%d5,%d8,%d15
800053d0:	ab 01 80 15 	sel %d1,%d5,%d1,0
800053d4:	2b eb 40 b5 	sel %d11,%d5,%d11,%d14
800053d8:	2b 6d 40 d5 	sel %d13,%d5,%d13,%d6
800053dc:	2b 0c 40 c5 	sel %d12,%d5,%d12,%d0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
800053e0:	c2 16       	add %d6,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
800053e2:	8b 16 68 52 	lt.u %d5,%d6,129
800053e6:	8b 0f 20 54 	and.ne %d5,%d15,0
800053ea:	df 05 e4 ff 	jne %d5,0,800053b2 <osEE_tc_set_pll_fsource+0xba>
800053ee:	02 d6       	mov %d6,%d13
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800053f0:	02 6d       	mov %d13,%d6
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
800053f2:	80 4f       	mov.d %d15,%a4
800053f4:	42 f0       	add %d0,%d15
800053f6:	80 56       	mov.d %d6,%a5
800053f8:	42 69       	add %d9,%d6

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
800053fa:	0f 32 a0 50 	or %d5,%d2,%d3
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
800053fe:	8b d0 61 f2 	lt.u %d15,%d0,29
80005402:	8b 05 20 f4 	and.ne %d15,%d5,0
80005406:	ee bd       	jnz %d15,80005380 <osEE_tc_set_pll_fsource+0x88>
80005408:	01 45 20 50 	sub.a %a5,%a5,%a4
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000540c:	c2 fe       	add %d14,-1
    k2Steps = 1;
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
8000540e:	0f 32 a0 f0 	or %d15,%d2,%d3
80005412:	8b 0f 20 02 	ne %d0,%d15,0
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
80005416:	8b 0e 20 52 	ne %d5,%d14,0
8000541a:	8b 0f 20 54 	and.ne %d5,%d15,0
8000541e:	df 05 9a ff 	jne %d5,0,80005352 <osEE_tc_set_pll_fsource+0x5a>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
80005422:	06 14       	sh %d4,1
80005424:	7b c0 1e f5 	movh %d15,20972
80005428:	1b ff 51 f8 	addi %d15,%d15,-31457
8000542c:	73 f4 68 40 	mul.u %e4,%d4,%d15
80005430:	8f b5 1f 20 	sh %d2,%d5,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
80005434:	ba 01       	eq %d15,%d1,0
80005436:	0b 28 50 f2 	and.ge.u %d15,%d8,%d2
8000543a:	8b 01 00 f5 	or.ne %d15,%d1,0
8000543e:	ee 73       	jnz %d15,80005524 <osEE_tc_set_pll_fsource+0x22c>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
80005440:	c2 fc       	add %d12,-1
80005442:	91 30 00 ff 	movh.a %a15,61443
80005446:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000544a:	4c f0       	ld.w %d15,[%a15]0
8000544c:	37 cf 07 c0 	insert %d12,%d15,%d12,0,7
80005450:	68 0c       	st.w [%a15]0,%d12

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
80005452:	91 30 00 ff 	movh.a %a15,61443
80005456:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000545a:	4c f0       	ld.w %d15,[%a15]0
8000545c:	6f 5f ff 7f 	jz.t %d15,5,8000545a <osEE_tc_set_pll_fsource+0x162>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
80005460:	91 30 00 ff 	movh.a %a15,61443
80005464:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80005468:	4c f0       	ld.w %d15,[%a15]0
8000546a:	96 01       	or %d15,1
8000546c:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
8000546e:	91 30 00 ff 	movh.a %a15,61443
80005472:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005476:	4c f0       	ld.w %d15,[%a15]0
80005478:	6f 0f ff 7f 	jz.t %d15,0,80005476 <osEE_tc_set_pll_fsource+0x17e>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000547c:	9a fb       	add %d15,%d11,-1
8000547e:	91 30 00 ff 	movh.a %a15,61443
80005482:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80005486:	16 0f       	and %d15,15
80005488:	8f 8f 01 f0 	sh %d15,%d15,24
8000548c:	48 02       	ld.w %d2,[%a15]0
8000548e:	b7 02 04 2c 	insert %d2,%d2,0,24,4
80005492:	a6 2f       	or %d15,%d2
80005494:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
80005496:	9a fd       	add %d15,%d13,-1
80005498:	16 7f       	and %d15,127
8000549a:	8f 9f 00 f0 	sh %d15,%d15,9
8000549e:	48 02       	ld.w %d2,[%a15]0
800054a0:	b7 02 87 24 	insert %d2,%d2,0,9,7
800054a4:	a6 2f       	or %d15,%d2
800054a6:	68 0f       	st.w [%a15]0,%d15

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
800054a8:	4c f0       	ld.w %d15,[%a15]0
800054aa:	8f 2f c0 f1 	andn %d15,%d15,2
800054ae:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
800054b0:	4c f0       	ld.w %d15,[%a15]0
800054b2:	96 40       	or %d15,64
800054b4:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
800054b6:	4c f0       	ld.w %d15,[%a15]0
800054b8:	96 20       	or %d15,32
800054ba:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
800054bc:	91 30 00 ff 	movh.a %a15,61443
800054c0:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800054c4:	4c f0       	ld.w %d15,[%a15]0
800054c6:	6f 3f ff ff 	jnz.t %d15,3,800054c4 <osEE_tc_set_pll_fsource+0x1cc>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
800054ca:	91 30 00 ff 	movh.a %a15,61443
800054ce:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800054d2:	4c f0       	ld.w %d15,[%a15]0
800054d4:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
800054d8:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
800054da:	91 30 00 ff 	movh.a %a15,61443
800054de:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800054e2:	4c f0       	ld.w %d15,[%a15]0
800054e4:	6f 2f ff 7f 	jz.t %d15,2,800054e2 <osEE_tc_set_pll_fsource+0x1ea>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
800054e8:	91 30 00 ff 	movh.a %a15,61443
800054ec:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800054f0:	4c f0       	ld.w %d15,[%a15]0
800054f2:	8f 1f c0 f1 	andn %d15,%d15,1
800054f6:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
800054f8:	91 30 00 ff 	movh.a %a15,61443
800054fc:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005500:	4c f0       	ld.w %d15,[%a15]0
80005502:	6f 0f ff ff 	jnz.t %d15,0,80005500 <osEE_tc_set_pll_fsource+0x208>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
80005506:	91 30 00 ff 	movh.a %a15,61443
8000550a:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000550e:	4c f0       	ld.w %d15,[%a15]0
80005510:	8f 0f c4 f1 	andn %d15,%d15,64
80005514:	68 0f       	st.w [%a15]0,%d15
80005516:	00 90       	ret 
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
            {
              fPllLeastError = fPllError;
80005518:	02 28       	mov %d8,%d2
8000551a:	02 31       	mov %d1,%d3
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000551c:	80 7b       	mov.d %d11,%a7
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
8000551e:	02 0c       	mov %d12,%d0
80005520:	1d ff 68 ff 	j 800053f0 <osEE_tc_set_pll_fsource+0xf8>
80005524:	00 90       	ret 

80005526 <osEE_tc_get_fsource>:
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
  }

}

OsEE_reg osEE_tc_get_fsource(void) {
80005526:	40 ae       	mov.aa %a14,%sp
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80005528:	91 30 00 ff 	movh.a %a15,61443
8000552c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005530:	4c f0       	ld.w %d15,[%a15]0
80005532:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
80005536:	7b 60 5f 20 	movh %d2,1526
8000553a:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000553e:	6e 45       	jz %d15,800055c8 <osEE_tc_get_fsource+0xa2>
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
80005540:	91 30 00 ff 	movh.a %a15,61443
80005544:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005548:	4c f0       	ld.w %d15,[%a15]0
8000554a:	6f 0f 11 00 	jz.t %d15,0,8000556c <osEE_tc_get_fsource+0x46>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000554e:	91 30 00 ff 	movh.a %a15,61443
80005552:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80005556:	48 02       	ld.w %d2,[%a15]0
80005558:	37 02 67 28 	extr.u %d2,%d2,16,7
8000555c:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000555e:	7b 10 13 f0 	movh %d15,305
80005562:	1b 0f d0 f2 	addi %d15,%d15,11520
80005566:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000556a:	00 90       	ret 
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000556c:	4c f0       	ld.w %d15,[%a15]0
8000556e:	6f 3f 11 00 	jz.t %d15,3,80005590 <osEE_tc_get_fsource+0x6a>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80005572:	91 30 00 ff 	movh.a %a15,61443
80005576:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000557a:	48 02       	ld.w %d2,[%a15]0
8000557c:	8f f2 07 21 	and %d2,%d2,127
80005580:	9a 12       	add %d15,%d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
80005582:	7b 10 13 20 	movh %d2,305
80005586:	1b 02 d0 22 	addi %d2,%d2,11520
8000558a:	4b f2 11 22 	div.u %e2,%d2,%d15
8000558e:	00 90       	ret 
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80005590:	91 30 00 ff 	movh.a %a15,61443
80005594:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80005598:	4c f0       	ld.w %d15,[%a15]0
8000559a:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000559e:	91 30 00 ff 	movh.a %a15,61443
800055a2:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800055a6:	4c f0       	ld.w %d15,[%a15]0
800055a8:	37 0f 64 3c 	extr.u %d3,%d15,24,4
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
800055ac:	48 02       	ld.w %d2,[%a15]0
800055ae:	37 02 e7 44 	extr.u %d4,%d2,9,7
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
800055b2:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
800055b4:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
800055b8:	7b 10 13 20 	movh %d2,305
800055bc:	1b 02 d0 22 	addi %d2,%d2,11520
800055c0:	4b f2 11 22 	div.u %e2,%d2,%d15
800055c4:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
800055c8:	00 90       	ret 

800055ca <osEE_tc_stm_set_clockpersec>:
  return ticks;
}

/* Set inside std time reference  */
void osEE_tc_stm_set_clockpersec(void)
{
800055ca:	40 ae       	mov.aa %a14,%sp
#if (defined(__TASKING__))
  /* I don't know where is declared */
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
800055cc:	6d ff ad ff 	call 80005526 <osEE_tc_get_fsource>
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
800055d0:	91 30 00 ff 	movh.a %a15,61443
800055d4:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800055d8:	4c f0       	ld.w %d15,[%a15]0
800055da:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800055de:	c2 12       	add %d2,1
800055e0:	4b f2 11 22 	div.u %e2,%d2,%d15

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
800055e4:	7b 20 06 f1 	movh %d15,4194
800055e8:	1b 3f dd f4 	addi %d15,%d15,19923
800055ec:	73 f2 68 20 	mul.u %e2,%d2,%d15
800055f0:	8f a3 1f f0 	sh %d15,%d3,-6
800055f4:	91 00 00 f7 	movh.a %a15,28672
800055f8:	59 ff 18 00 	st.w [%a15]24 <70000018 <osEE_tc_stm_freq_khz>>,%d15
800055fc:	00 90       	ret 

800055fe <osEE_tc_stm_set_sr1>:
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1(OsEE_reg usec,
  OsEE_tc_isr_hw_prio intvec)
{
800055fe:	40 ae       	mov.aa %a14,%sp
80005600:	02 58       	mov %d8,%d5
80005602:	4d c0 e1 ff 	mfcr %d15,$core_id
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80005606:	6d ff c5 fd 	call 80005190 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000560a:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
8000560e:	16 03       	and %d15,3
80005610:	9b 0f 0f 40 	addih %d4,%d15,240
80005614:	8f 84 00 40 	sh %d4,%d4,8
80005618:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
8000561a:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
8000561c:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
8000561e:	68 d2       	st.w [%a15]52,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80005620:	df 08 27 00 	jeq %d8,0,8000566e <osEE_tc_stm_set_sr1+0x70>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
80005624:	48 e2       	ld.w %d2,[%a15]56
80005626:	b7 02 05 2c 	insert %d2,%d2,0,24,5
8000562a:	68 e2       	st.w [%a15]56,%d2
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
8000562c:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
80005630:	8f f3 01 31 	and %d3,%d3,31
80005634:	8f 03 01 30 	sh %d3,%d3,16
80005638:	48 e2       	ld.w %d2,[%a15]56
8000563a:	b7 02 05 28 	insert %d2,%d2,0,16,5
8000563e:	a6 23       	or %d3,%d2
80005640:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
80005642:	48 f2       	ld.w %d2,[%a15]60
80005644:	8f 02 44 21 	or %d2,%d2,64
80005648:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
8000564a:	48 f2       	ld.w %d2,[%a15]60
8000564c:	8f 02 41 21 	or %d2,%d2,16
80005650:	68 f2       	st.w [%a15]60,%d2
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
80005652:	8f 3f 00 20 	sh %d2,%d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80005656:	60 22       	mov.a %a2,%d2
80005658:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000565c:	11 4f 00 ff 	addih.a %a15,%a15,61444
80005660:	b7 88 99 83 	insert %d8,%d8,8,7,25
80005664:	8f bf 00 f0 	sh %d15,%d15,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80005668:	a6 8f       	or %d15,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000566a:	68 0f       	st.w [%a15]0,%d15
8000566c:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
8000566e:	48 f2       	ld.w %d2,[%a15]60
80005670:	8f 02 c1 21 	andn %d2,%d2,16
80005674:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
80005676:	06 3f       	sh %d15,3
80005678:	60 f2       	mov.a %a2,%d15
8000567a:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000567e:	11 4f 00 ff 	addih.a %a15,%a15,61444
80005682:	82 0f       	mov %d15,0
80005684:	68 0f       	st.w [%a15]0,%d15
80005686:	00 90       	ret 

80005688 <osEE_tc_stm_set_sr1_next_match>:
  }
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1_next_match(OsEE_reg usec)
{
80005688:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000568a:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
8000568e:	6d ff 81 fd 	call 80005190 <osEE_tc_stm_us_ticks>
80005692:	16 03       	and %d15,3
80005694:	9b 0f 0f f0 	addih %d15,%d15,240
80005698:	8f 8f 00 f0 	sh %d15,%d15,8
8000569c:	60 ff       	mov.a %a15,%d15
8000569e:	4c fd       	ld.w %d15,[%a15]52
800056a0:	42 f2       	add %d2,%d15
800056a2:	68 d2       	st.w [%a15]52,%d2
800056a4:	00 90       	ret 

800056a6 <osEE_tc_delay>:
}

void osEE_tc_delay(OsEE_reg usec)
{
800056a6:	40 ae       	mov.aa %a14,%sp
800056a8:	4d c0 e1 ff 	mfcr %d15,$core_id
800056ac:	16 03       	and %d15,3
800056ae:	9b 0f 0f f0 	addih %d15,%d15,240
800056b2:	8f 8f 00 f0 	sh %d15,%d15,8
800056b6:	60 f2       	mov.a %a2,%d15
800056b8:	d9 2f 10 00 	lea %a15,[%a2]16
800056bc:	19 28 10 00 	ld.w %d8,[%a2]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);
800056c0:	6d ff 68 fd 	call 80005190 <osEE_tc_stm_us_ticks>
800056c4:	4c f0       	ld.w %d15,[%a15]0

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
800056c6:	a2 8f       	sub %d15,%d8
800056c8:	3f 2f fe ff 	jlt.u %d15,%d2,800056c4 <osEE_tc_delay+0x1e>
    ; /* Wait */
  }
}
800056cc:	00 90       	ret 

800056ce <osEE_tc_isr2_wrapper>:

#if (defined(__GNUC__))
#pragma section
#endif /* __GNUC__ */

static void OSEE_COMPILER_KEEP osEE_tc_isr2_wrapper(TaskType isr2_tid) {
800056ce:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_SINGLECORE))
  if (isr2_tid == INVALID_TASK) {
800056d0:	df f4 50 80 	jne %d4,-1,80005770 <osEE_tc_isr2_wrapper+0xa2>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800056d4:	4d c0 e2 ff 	mfcr %d15,$icr
    OsEE_icr icr  = osEE_tc_get_icr();
    if (icr.bits.ccpn == 1U) {
800056d8:	16 ff       	and %d15,255
800056da:	df 1f 4d 80 	jne %d15,1,80005774 <osEE_tc_isr2_wrapper+0xa6>
      CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
      CONSTP2CONST(OsEE_KCB, AUTOMATIC, OS_APPL_DATA) p_kcb = p_kdb->p_kcb;
800056de:	91 00 00 f8 	movh.a %a15,32768
800056e2:	99 f2 28 00 	ld.a %a2,[%a15]40 <80000028 <osEE_kdb_var>>
800056e6:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800056ea:	8f f8 0f f1 	and %d15,%d8,255
800056ee:	ff 2f 09 80 	jge.u %d15,2,80005700 <osEE_tc_isr2_wrapper+0x32>
    OsEE_icr icr_temp = icr;
800056f2:	02 8f       	mov %d15,%d8
800056f4:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800056f8:	cd cf e2 0f 	mtcr $icr,%d15
800056fc:	0d 00 c0 04 	isync 
80005700:	4d c0 e1 ff 	mfcr %d15,$core_id
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_ack_signal(void)
{
  CoreIdType core_id = osEE_get_curr_core_id();

  OSEE_TC_SRC_REG(OSEE_TC_GPSR_SRC_OFFSET(OSEE_TC_GPSR_G, core_id)) |=
80005704:	8f ff 0f 21 	and %d2,%d15,255
80005708:	91 40 00 ff 	movh.a %a15,61444
8000570c:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
80005710:	ff 32 0a 80 	jge.u %d2,3,80005724 <osEE_tc_isr2_wrapper+0x56>
80005714:	16 ff       	and %d15,255
80005716:	60 f3       	mov.a %a3,%d15
80005718:	d9 3f 40 0e 	lea %a15,[%a3]-7168
8000571c:	11 1f c0 f3 	addih.a %a15,%a15,15361
80005720:	30 ff       	add.a %a15,%a15
80005722:	30 ff       	add.a %a15,%a15
80005724:	4c f0       	ld.w %d15,[%a15]0
80005726:	7b 00 20 24 	movh %d2,16896
8000572a:	a6 2f       	or %d15,%d2
8000572c:	68 0f       	st.w [%a15]0,%d15

      /* Ack IIRQ */
      osEE_tc_ack_signal();

      /* Check for ShutdownAllCores */
      if (p_kcb->ar_shutdown_all_cores_flag) {
8000572e:	0c 2e       	ld.bu %d15,[%a2]14
80005730:	6e 12       	jz %d15,80005754 <osEE_tc_isr2_wrapper+0x86>
80005732:	40 93       	mov.aa %a3,%a9
        CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
          p_curr_cdb = osEE_get_curr_core();
        osEE_shutdown_os(p_curr_cdb,
80005734:	39 22 0d 00 	ld.bu %d2,[%a2]13
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80005738:	cc 33       	ld.a %a15,[%a3]12
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000573a:	39 ff 10 00 	ld.bu %d15,[%a15]16 <3 <_.+0x2>>

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000573e:	82 33       	mov %d3,3
80005740:	e9 f3 10 00 	st.b [%a15]16,%d3
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
80005744:	e9 f2 12 00 	st.b [%a15]18,%d2

  if (os_status == OSEE_KERNEL_STARTED) {
80005748:	5e 25       	jne %d15,2,80005752 <osEE_tc_isr2_wrapper+0x84>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000574a:	99 34 14 00 	ld.a %a4,[%a3]20 <14 <_.+0x13>>
8000574e:	6d 00 f1 15 	call 80008330 <osEE_idle_task_terminate>
80005752:	3c 00       	j 80005752 <osEE_tc_isr2_wrapper+0x84>
          p_kcb->ar_shutdown_all_cores_error);
      } else {
        (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
80005754:	91 00 00 48 	movh.a %a4,32768
80005758:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
8000575c:	6d 00 5a 11 	call 80007a10 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005760:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005764:	3e 88       	jeq %d15,%d8,80005774 <osEE_tc_isr2_wrapper+0xa6>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005766:	cd c8 e2 0f 	mtcr $icr,%d8
8000576a:	0d 00 c0 04 	isync 
8000576e:	3c 03       	j 80005774 <osEE_tc_isr2_wrapper+0xa6>
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
80005770:	6d 00 c1 0f 	call 800076f2 <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
80005774:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
80005778:	00 80       	rfe 
8000577a:	00 90       	ret 

8000577c <osEE_shutdown_os>:
  osEE_shutdown_os
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
8000577c:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000577e:	cc 43       	ld.a %a15,[%a4]12
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80005780:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
80005784:	82 32       	mov %d2,3
80005786:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000578a:	e9 f4 12 00 	st.b [%a15]18,%d4

  if (os_status == OSEE_KERNEL_STARTED) {
8000578e:	5e 25       	jne %d15,2,80005798 <osEE_shutdown_os+0x1c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
80005790:	99 44 14 00 	ld.a %a4,[%a4]20
80005794:	6d 00 ce 15 	call 80008330 <osEE_idle_task_terminate>
  } else {
    osEE_call_shutdown_hook(p_ccb, Error);
  }
  for (;;) {
    ; /* Endless Loop (entered only if Kernel Not Started) */
  }
80005798:	3c 00       	j 80005798 <osEE_shutdown_os+0x1c>

8000579a <DisableAllInterrupts>:
FUNC(void, OS_CODE)
  DisableAllInterrupts
(
  void
)
{
8000579a:	40 ae       	mov.aa %a14,%sp
8000579c:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000579e:	c8 3f       	ld.a %a15,[%a15]12
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
800057a0:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
800057a4:	82 1f       	mov %d15,1
800057a6:	e9 ff 22 00 	st.b [%a15]34,%d15
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
800057aa:	da 0c       	mov %d15,12
800057ac:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800057b0:	82 0f       	mov %d15,0
800057b2:	e9 ff 23 00 	st.b [%a15]35,%d15
800057b6:	00 90       	ret 

800057b8 <EnableAllInterrupts>:
FUNC(void, OS_CODE)
  EnableAllInterrupts
(
  void
)
{
800057b8:	40 ae       	mov.aa %a14,%sp
800057ba:	40 9f       	mov.aa %a15,%a9
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800057bc:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800057be:	da 0f       	mov %d15,15
800057c0:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800057c4:	82 1f       	mov %d15,1
800057c6:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
800057ca:	39 ff 22 00 	ld.bu %d15,[%a15]34
800057ce:	6e 09       	jz %d15,800057e0 <EnableAllInterrupts+0x28>
    p_ccb->d_isr_all_cnt = 0U;
800057d0:	82 0f       	mov %d15,0
800057d2:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
800057d6:	0d 00 00 03 	enable 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800057da:	39 ff 23 00 	ld.bu %d15,[%a15]35
800057de:	5e 17       	jne %d15,1,800057ec <EnableAllInterrupts+0x34>
    p_ccb->service_id            = service_id;
800057e0:	da 0e       	mov %d15,14
800057e2:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800057e6:	82 0f       	mov %d15,0
800057e8:	e9 ff 23 00 	st.b [%a15]35,%d15
800057ec:	00 90       	ret 

800057ee <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
800057ee:	40 ae       	mov.aa %a14,%sp
800057f0:	40 94       	mov.aa %a4,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800057f2:	cc 43       	ld.a %a15,[%a4]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800057f4:	da 11       	mov %d15,17
800057f6:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800057fa:	82 1f       	mov %d15,1
800057fc:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt == 0U) {
80005800:	39 ff 20 00 	ld.bu %d15,[%a15]32
80005804:	ee 0c       	jnz %d15,8000581c <SuspendAllInterrupts+0x2e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005806:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000580a:	0d 00 40 03 	disable 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
8000580e:	68 6f       	st.w [%a15]24,%d15
    ++p_ccb->s_isr_all_cnt;
80005810:	39 ff 20 00 	ld.bu %d15,[%a15]32
80005814:	c2 1f       	add %d15,1
80005816:	e9 ff 20 00 	st.b [%a15]32,%d15
8000581a:	3c 0b       	j 80005830 <SuspendAllInterrupts+0x42>
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
8000581c:	8b ff 0f 22 	eq %d2,%d15,255
80005820:	f6 25       	jnz %d2,8000582a <SuspendAllInterrupts+0x3c>
    ++p_ccb->s_isr_all_cnt;
80005822:	c2 1f       	add %d15,1
80005824:	e9 ff 20 00 	st.b [%a15]32,%d15
80005828:	3c 04       	j 80005830 <SuspendAllInterrupts+0x42>
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
8000582a:	3b 90 01 40 	mov %d4,25
8000582e:	3c a7       	j 8000577c <osEE_shutdown_os>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005830:	39 ff 23 00 	ld.bu %d15,[%a15]35
80005834:	5e 17       	jne %d15,1,80005842 <SuspendAllInterrupts+0x54>
    p_ccb->service_id            = service_id;
80005836:	da 10       	mov %d15,16
80005838:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000583c:	82 0f       	mov %d15,0
8000583e:	e9 ff 23 00 	st.b [%a15]35,%d15
80005842:	00 90       	ret 

80005844 <ResumeAllInterrupts>:
FUNC(void, OS_CODE)
  ResumeAllInterrupts
(
  void
)
{
80005844:	40 ae       	mov.aa %a14,%sp
80005846:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80005848:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000584a:	da 13       	mov %d15,19
8000584c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80005850:	82 1f       	mov %d15,1
80005852:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
80005856:	39 ff 20 00 	ld.bu %d15,[%a15]32
8000585a:	6e 0e       	jz %d15,80005876 <ResumeAllInterrupts+0x32>
    p_ccb->s_isr_all_cnt--;
8000585c:	c2 ff       	add %d15,-1
8000585e:	16 ff       	and %d15,255
80005860:	e9 ff 20 00 	st.b [%a15]32,%d15
    
    if (p_ccb->s_isr_all_cnt == 0U) {
80005864:	ee 06       	jnz %d15,80005870 <ResumeAllInterrupts+0x2c>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005866:	4c f6       	ld.w %d15,[%a15]24
80005868:	cd cf e2 0f 	mtcr $icr,%d15
8000586c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005870:	39 ff 23 00 	ld.bu %d15,[%a15]35
80005874:	5e 17       	jne %d15,1,80005882 <ResumeAllInterrupts+0x3e>
    p_ccb->service_id            = service_id;
80005876:	da 12       	mov %d15,18
80005878:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000587c:	82 0f       	mov %d15,0
8000587e:	e9 ff 23 00 	st.b [%a15]35,%d15
80005882:	00 90       	ret 

80005884 <SuspendOSInterrupts>:
FUNC(void, OS_CODE)
  SuspendOSInterrupts
(
  void
)
{
80005884:	40 ae       	mov.aa %a14,%sp
80005886:	40 94       	mov.aa %a4,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80005888:	cc 43       	ld.a %a15,[%a4]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000588a:	da 15       	mov %d15,21
8000588c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80005890:	82 1f       	mov %d15,1
80005892:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
80005896:	39 ff 21 00 	ld.bu %d15,[%a15]33
8000589a:	ee 15       	jnz %d15,800058c4 <SuspendOSInterrupts+0x40>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000589c:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800058a0:	8f ff 0f 21 	and %d2,%d15,255
800058a4:	ff 22 09 80 	jge.u %d2,2,800058b6 <SuspendOSInterrupts+0x32>
    OsEE_icr icr_temp = icr;
800058a8:	02 f2       	mov %d2,%d15
800058aa:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800058ae:	cd c2 e2 0f 	mtcr $icr,%d2
800058b2:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
800058b6:	68 7f       	st.w [%a15]28,%d15
    ++p_ccb->s_isr_os_cnt;
800058b8:	39 ff 21 00 	ld.bu %d15,[%a15]33
800058bc:	c2 1f       	add %d15,1
800058be:	e9 ff 21 00 	st.b [%a15]33,%d15
800058c2:	3c 0c       	j 800058da <SuspendOSInterrupts+0x56>
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
800058c4:	8b ff 0f 22 	eq %d2,%d15,255
800058c8:	f6 25       	jnz %d2,800058d2 <SuspendOSInterrupts+0x4e>
    ++p_ccb->s_isr_os_cnt;
800058ca:	c2 1f       	add %d15,1
800058cc:	e9 ff 21 00 	st.b [%a15]33,%d15
800058d0:	3c 05       	j 800058da <SuspendOSInterrupts+0x56>
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
800058d2:	3b 90 01 40 	mov %d4,25
800058d6:	1d ff 53 ff 	j 8000577c <osEE_shutdown_os>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800058da:	39 ff 23 00 	ld.bu %d15,[%a15]35
800058de:	5e 17       	jne %d15,1,800058ec <SuspendOSInterrupts+0x68>
    p_ccb->service_id            = service_id;
800058e0:	da 14       	mov %d15,20
800058e2:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800058e6:	82 0f       	mov %d15,0
800058e8:	e9 ff 23 00 	st.b [%a15]35,%d15
800058ec:	00 90       	ret 

800058ee <ResumeOSInterrupts>:
FUNC(void, OS_CODE)
  ResumeOSInterrupts
(
  void
)
{
800058ee:	40 ae       	mov.aa %a14,%sp
800058f0:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800058f2:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800058f4:	da 17       	mov %d15,23
800058f6:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800058fa:	82 1f       	mov %d15,1
800058fc:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
80005900:	39 ff 21 00 	ld.bu %d15,[%a15]33
80005904:	6e 11       	jz %d15,80005926 <ResumeOSInterrupts+0x38>
    p_ccb->s_isr_os_cnt--;
80005906:	c2 ff       	add %d15,-1
80005908:	16 ff       	and %d15,255
8000590a:	e9 ff 21 00 	st.b [%a15]33,%d15
    
    if (p_ccb->s_isr_os_cnt == 0U) {
8000590e:	ee 09       	jnz %d15,80005920 <ResumeOSInterrupts+0x32>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
80005910:	48 72       	ld.w %d2,[%a15]28
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005912:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005916:	3e 25       	jeq %d15,%d2,80005920 <ResumeOSInterrupts+0x32>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005918:	cd c2 e2 0f 	mtcr $icr,%d2
8000591c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005920:	39 ff 23 00 	ld.bu %d15,[%a15]35
80005924:	5e 17       	jne %d15,1,80005932 <ResumeOSInterrupts+0x44>
    p_ccb->service_id            = service_id;
80005926:	da 16       	mov %d15,22
80005928:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000592c:	82 0f       	mov %d15,0
8000592e:	e9 ff 23 00 	st.b [%a15]35,%d15
80005932:	00 90       	ret 

80005934 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
80005934:	40 ae       	mov.aa %a14,%sp
80005936:	20 10       	sub.a %sp,16
80005938:	02 4c       	mov %d12,%d4
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000593a:	4d c0 e1 ef 	mfcr %d14,$core_id
  VAR(StatusType, AUTOMATIC)                      ev = E_OK;
  VAR(AppModeType, AUTOMATIC)                     real_mode = Mode;
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
8000593e:	91 00 00 f8 	movh.a %a15,32768
80005942:	99 fc 28 00 	ld.a %a12,[%a15]40 <80000028 <osEE_kdb_var>>
80005946:	40 9d       	mov.aa %a13,%a9
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80005948:	cc d3       	ld.a %a15,[%a13]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000594a:	4d c0 e2 df 	mfcr %d13,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000594e:	8f fd 0f f1 	and %d15,%d13,255
80005952:	ff 2f 09 80 	jge.u %d15,2,80005964 <StartOS+0x30>
    OsEE_icr icr_temp = icr;
80005956:	02 df       	mov %d15,%d13
80005958:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000595c:	cd cf e2 0f 	mtcr $icr,%d15
80005960:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80005964:	da 4b       	mov %d15,75
80005966:	e9 ff 13 00 	st.b [%a15]19 <80000013 <BootModeHeader0+0x13>>,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000596a:	82 1f       	mov %d15,1
8000596c:	e9 ff 23 00 	st.b [%a15]35 <80000023 <_start+0x3>>,%d15
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
80005970:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000010 <BootModeHeader0+0x10>>
80005974:	df 0f 72 81 	jne %d15,0,80005c58 <StartOS+0x324>
80005978:	8f fe 0f a1 	and %d10,%d14,255
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
8000597c:	df 0a 43 81 	jne %d10,0,80005c02 <StartOS+0x2ce>
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
80005980:	6d 00 eb 14 	call 80008356 <osEE_cpu_startos>
80005984:	df 02 23 01 	jeq %d2,0,80005bca <StartOS+0x296>
80005988:	1d 00 59 01 	j 80005c3a <StartOS+0x306>
    if (
      (p_kcb->ar_core_mask & ((CoreMaskType)1U << (OsEE_reg)curr_core_id)) ==
        0U
    )
    {
      for(;;) {}  /* Endless Loop */
8000598c:	3c 00       	j 8000598c <StartOS+0x58>
    /* Initialize Slaves Hardware after First synchronization point:
       This ensures that all the Master Initializations have been done. */
    if (curr_core_id != OS_CORE_ID_MASTER) {
      if (!osEE_cpu_startos()) {
        /* Enter in an endless loop if it happens */
        for(;;) {}
8000598e:	3c 00       	j 8000598e <StartOS+0x5a>
80005990:	8f fe 0f 41 	and %d4,%d14,255
    and shall enter an endless loop on every core. (SRS_Os_80006) */
    {
      VAR(CoreNumType, AUTOMATIC)  i;

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
        if ((p_kcb->ar_core_mask & ((CoreMaskType)1U << i)) != 0U) {
80005994:	54 c2       	ld.w %d2,[%a12]
80005996:	57 02 61 2e 	extr.u %d2,%d2,%d14,1
8000599a:	df 02 13 00 	jeq %d2,0,800059c0 <StartOS+0x8c>
          CONST(AppModeType, AUTOMATIC)
            /* MISRA-C 2012: Rule 10.5 deviation. Cast back from
               unsigned to enum is safe here, since we are in a loop
               with the right limits. */
            current_mode = osEE_get_core((CoreIdType)i)->p_ccb->app_mode;
8000599e:	6d 00 a4 15 	call 800084e6 <osEE_get_core>
800059a2:	99 22 0c 00 	ld.a %a2,[%a2]12
800059a6:	39 22 11 00 	ld.bu %d2,[%a2]17

          if (current_mode != DONOTCARE) {
800059aa:	8b f2 0f 32 	eq %d3,%d2,255
800059ae:	f6 39       	jnz %d3,800059c0 <StartOS+0x8c>
            if (real_mode == DONOTCARE) {
800059b0:	8b ff 0f 32 	eq %d3,%d15,255
800059b4:	f6 33       	jnz %d3,800059ba <StartOS+0x86>
              real_mode = current_mode;
            } else if (real_mode != current_mode) {
800059b6:	3e 24       	jeq %d15,%d2,800059be <StartOS+0x8a>
            /* Error condition specified by SWS_Os_00608 requirement:
               enter in an endless loop */
              for(;;) {}
800059b8:	3c 00       	j 800059b8 <StartOS+0x84>
               with the right limits. */
            current_mode = osEE_get_core((CoreIdType)i)->p_ccb->app_mode;

          if (current_mode != DONOTCARE) {
            if (real_mode == DONOTCARE) {
              real_mode = current_mode;
800059ba:	02 2f       	mov %d15,%d2
800059bc:	3c 02       	j 800059c0 <StartOS+0x8c>
800059be:	02 2f       	mov %d15,%d2
800059c0:	c2 1e       	add %d14,1
    StartOS shall not start the scheduling, shall not call any StartupHooks,
    and shall enter an endless loop on every core. (SRS_Os_80006) */
    {
      VAR(CoreNumType, AUTOMATIC)  i;

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
800059c2:	df 3e e7 ff 	jne %d14,3,80005990 <StartOS+0x5c>
            }
          }
        }
      }

      if (real_mode != DONOTCARE) {
800059c6:	8b ff 0f 22 	eq %d2,%d15,255
800059ca:	f6 27       	jnz %d2,800059d8 <StartOS+0xa4>
        /* Set mode for this core as real_mode */
        if (Mode == DONOTCARE) {
800059cc:	8b fc 2f c2 	ne %d12,%d12,255
800059d0:	f6 c8       	jnz %d12,800059e0 <StartOS+0xac>
          p_ccb->app_mode = real_mode;
800059d2:	e9 ff 11 00 	st.b [%a15]17 <80000011 <BootModeHeader0+0x11>>,%d15
800059d6:	3c 05       	j 800059e0 <StartOS+0xac>
        }
      } else {
        /* XXX: It is not specified how to handle the condition that no cores
                defines an AppMode different from DONOTCARE.
                I choose to handle it using OSDEFAULTAPPMODE */
        p_ccb->app_mode = OSDEFAULTAPPMODE;
800059d8:	82 0f       	mov %d15,0
800059da:	e9 ff 11 00 	st.b [%a15]17 <80000011 <BootModeHeader0+0x11>>,%d15
        real_mode = OSDEFAULTAPPMODE;
800059de:	82 0f       	mov %d15,0
#if (defined(OSEE_HAS_AUTOSTART_TRIGGER))
    {
      VAR(MemSize, AUTOMATIC) i;
      VAR(MemSize, AUTOMATIC) trigger_size;
      CONSTP2VAR(OsEE_autostart_trigger, AUTOMATIC, OS_APPL_CONST)
        p_auto_triggers = &(*p_cdb->p_autostart_trigger_array)[real_mode];
800059e0:	19 d2 24 00 	ld.w %d2,[%a13]36
800059e4:	02 fc       	mov %d12,%d15
      P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db_tmp;  /* MISRA R13.2 */
#endif /* OSEE_HAS_ALARMS */
      P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db_tmp;   /* MISRA R13.2 */
#endif /* OSEE_HAS_SCHEDULE_TABLES */

      trigger_size = p_auto_triggers->trigger_array_size;
800059e6:	60 23       	mov.a %a3,%d2
800059e8:	d0 32       	addsc.a %a2,%a3,%d15,3
800059ea:	19 2e 04 00 	ld.w %d14,[%a2]4
      for (i = 0U; i < trigger_size; ++i) {
800059ee:	df 0e 3b 00 	jeq %d14,0,80005a64 <StartOS+0x130>
800059f2:	82 0f       	mov %d15,0
        CONSTP2VAR(OsEE_autostart_trigger_info, AUTOMATIC, OS_APPL_CONST)
          p_trigger_to_act_info = &(*p_auto_triggers->p_trigger_ptr_array)[i];
800059f4:	13 8c 20 b2 	madd %d11,%d2,%d12,8
800059f8:	60 b2       	mov.a %a2,%d11
800059fa:	54 22       	ld.w %d2,[%a2]
        CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_CONST)
          p_trigger_to_act_db   = p_trigger_to_act_info->p_trigger_db;
800059fc:	13 0f 21 32 	madd %d3,%d2,%d15,16
80005a00:	60 33       	mov.a %a3,%d3
80005a02:	d4 32       	ld.a %a2,[%a3]
          p_trigger_to_act_db,
          p_trigger_to_act_info->first_tick_parameter,
          p_trigger_to_act_info->second_tick_parameter
        );
#else
        switch (p_trigger_to_act_info->autostart_type) {
80005a04:	39 33 0c 00 	ld.bu %d3,[%a3]12
80005a08:	df 13 14 00 	jeq %d3,1,80005a30 <StartOS+0xfc>
80005a0c:	76 34       	jz %d3,80005a14 <StartOS+0xe0>
80005a0e:	df 23 1d 00 	jeq %d3,2,80005a48 <StartOS+0x114>
80005a12:	3c 26       	j 80005a5e <StartOS+0x12a>
#if (defined(OSEE_HAS_ALARMS))
          case OSEE_AUTOSTART_ALARM:
            p_alarm_db_tmp = osEE_trigger_get_alarm_db(p_trigger_to_act_db);
            (void)osEE_alarm_set_rel(
80005a14:	13 0f 21 42 	madd %d4,%d2,%d15,16
80005a18:	60 43       	mov.a %a3,%d4
80005a1a:	99 24 04 00 	ld.a %a4,[%a2]4
80005a1e:	99 25 08 00 	ld.a %a5,[%a2]8
80005a22:	19 34 04 00 	ld.w %d4,[%a3]4
80005a26:	19 35 08 00 	ld.w %d5,[%a3]8
80005a2a:	6d 00 5b 12 	call 80007ee0 <osEE_alarm_set_rel>
              p_trigger_to_act_db->p_counter_db,
              p_alarm_db_tmp,                               /* MISRA R13.2 */
              p_trigger_to_act_info->first_tick_parameter,
              p_trigger_to_act_info->second_tick_parameter
            );
          break;
80005a2e:	3c 18       	j 80005a5e <StartOS+0x12a>
#endif /* OSEE_HAS_ALARMS */
          case OSEE_AUTOSTART_SCHEDULE_TABLE_ABS:
            p_st_db_tmp = osEE_trigger_get_st_db(p_trigger_to_act_db);
            (void)osEE_st_start_abs(
80005a30:	13 0f 21 52 	madd %d5,%d2,%d15,16
80005a34:	60 53       	mov.a %a3,%d5
80005a36:	99 24 04 00 	ld.a %a4,[%a2]4
80005a3a:	99 25 0c 00 	ld.a %a5,[%a2]12
80005a3e:	19 34 04 00 	ld.w %d4,[%a3]4
80005a42:	6d 00 81 13 	call 80008144 <osEE_st_start_abs>
              p_trigger_to_act_db->p_counter_db,
              p_st_db_tmp,                                  /* MISRA R13.2 */
              p_trigger_to_act_info->first_tick_parameter
            );
          break;
80005a46:	3c 0c       	j 80005a5e <StartOS+0x12a>
          case OSEE_AUTOSTART_SCHEDULE_TABLE_REL:
            p_st_db_tmp = osEE_trigger_get_st_db(p_trigger_to_act_db);
            (void)osEE_st_start_rel(
80005a48:	13 0f 21 32 	madd %d3,%d2,%d15,16
80005a4c:	60 33       	mov.a %a3,%d3
80005a4e:	99 24 04 00 	ld.a %a4,[%a2]4
80005a52:	99 25 0c 00 	ld.a %a5,[%a2]12
80005a56:	19 34 04 00 	ld.w %d4,[%a3]4
80005a5a:	6d 00 22 13 	call 8000809e <osEE_st_start_rel>
#endif /* OSEE_HAS_ALARMS */
      P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db_tmp;   /* MISRA R13.2 */
#endif /* OSEE_HAS_SCHEDULE_TABLES */

      trigger_size = p_auto_triggers->trigger_array_size;
      for (i = 0U; i < trigger_size; ++i) {
80005a5e:	c2 1f       	add %d15,1
80005a60:	5f ef cc ff 	jne %d15,%d14,800059f8 <StartOS+0xc4>
#if (defined(OSEE_HAS_AUTOSTART_TASK))
    {
      VAR(MemSize, AUTOMATIC) i;
      VAR(MemSize, AUTOMATIC) tdbsize;
      CONSTP2VAR(OsEE_autostart_tdb, AUTOMATIC, OS_APPL_CONST)
        p_auto_tdb  = &(*p_cdb->p_autostart_tdb_array)[real_mode];
80005a64:	19 d2 1c 00 	ld.w %d2,[%a13]28
#if (!defined(OSEE_ALLOW_TASK_MIGRATION))
      CONSTP2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)
        p_rq        = &p_ccb->rq;
80005a68:	80 fb       	mov.d %d11,%a15
80005a6a:	c2 4b       	add %d11,4
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80005a6c:	99 d2 10 00 	ld.a %a2,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80005a70:	82 18       	mov %d8,1
80005a72:	82 09       	mov %d9,0
80005a74:	0b 89 10 48 	mov %e4,%d9,%d8
80005a78:	49 24 c0 08 	cmpswap.w [%a2]0,%e4
80005a7c:	02 4f       	mov %d15,%d4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80005a7e:	df 04 f9 ff 	jne %d4,0,80005a70 <StartOS+0x13c>
        p_rq        = &p_kcb->rq;
      CONSTP2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)
        pp_free_sn  = &p_ccb->p_free_sn;
#endif /* !OSEE_ALLOW_TASK_MIGRATION */

      tdbsize = p_auto_tdb->tdb_array_size;
80005a82:	60 23       	mov.a %a3,%d2
80005a84:	01 3c 03 26 	addsc.a %a2,%a3,%d12,3
80005a88:	19 28 04 00 	ld.w %d8,[%a2]4
      for (i = 0U; i < tdbsize; ++i) {
80005a8c:	df 08 1b 00 	jeq %d8,0,80005ac2 <StartOS+0x18e>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
          p_tdb_to_act = (*p_auto_tdb->p_tdb_ptr_array)[i];
80005a90:	13 8c 20 c2 	madd %d12,%d2,%d12,8
        CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
          p_tcb_to_act = p_tdb_to_act->p_tcb;

        /* Mark the autostart-TASK as Activated */
        ++p_tcb_to_act->current_num_of_act;
        p_tcb_to_act->status = OSEE_TASK_READY;
80005a94:	82 19       	mov %d9,1
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
  (*pp_first)              = p_sn_allocated->p_next;
  p_sn_allocated->p_next  = NULL;
80005a96:	82 0e       	mov %d14,0
#endif /* !OSEE_ALLOW_TASK_MIGRATION */

      tdbsize = p_auto_tdb->tdb_array_size;
      for (i = 0U; i < tdbsize; ++i) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
          p_tdb_to_act = (*p_auto_tdb->p_tdb_ptr_array)[i];
80005a98:	60 c3       	mov.a %a3,%d12
80005a9a:	d4 32       	ld.a %a2,[%a3]
80005a9c:	90 22       	addsc.a %a2,%a2,%d15,2
80005a9e:	d4 26       	ld.a %a6,[%a2]
        CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
          p_tcb_to_act = p_tdb_to_act->p_tcb;
80005aa0:	99 62 0c 00 	ld.a %a2,[%a6]12

        /* Mark the autostart-TASK as Activated */
        ++p_tcb_to_act->current_num_of_act;
80005aa4:	14 22       	ld.bu %d2,[%a2]
80005aa6:	c2 12       	add %d2,1
80005aa8:	34 22       	st.b [%a2],%d2
        p_tcb_to_act->status = OSEE_TASK_READY;
80005aaa:	e9 29 02 00 	st.b [%a2]2,%d9
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80005aae:	c8 25       	ld.a %a5,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80005ab0:	54 52       	ld.w %d2,[%a5]
80005ab2:	68 22       	st.w [%a15]8,%d2
  p_sn_allocated->p_next  = NULL;
80005ab4:	74 5e       	st.w [%a5],%d14

        (void)osEE_scheduler_rq_insert(
80005ab6:	60 b4       	mov.a %a4,%d11
80005ab8:	6d 00 9a 0d 	call 800075ec <osEE_scheduler_rq_insert>
      CONSTP2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)
        pp_free_sn  = &p_ccb->p_free_sn;
#endif /* !OSEE_ALLOW_TASK_MIGRATION */

      tdbsize = p_auto_tdb->tdb_array_size;
      for (i = 0U; i < tdbsize; ++i) {
80005abc:	c2 1f       	add %d15,1
80005abe:	5f 8f ed ff 	jne %d15,%d8,80005a98 <StartOS+0x164>
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80005ac2:	99 d2 10 00 	ld.a %a2,[%a13]16
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80005ac6:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80005aca:	82 0f       	mov %d15,0
80005acc:	6c 20       	st.w [%a2]0,%d15
    Specification paragraph 7.9.4 Multi-Core start-up concept:
    "This release of the AUTOSAR specification does not support timeouts
    during the synchronization phase. Cores that are activated with
    StartCore but do not call StartOS may cause the system to hang.
    It is in the responsibility of the integrator to avoid such behavior." */
    osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_core_mask,
80005ace:	91 00 00 28 	movh.a %a2,32768
80005ad2:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80005ad6:	99 24 08 00 	ld.a %a4,[%a2]8 <80000008 <BootModeHeader0+0x8>>
80005ada:	99 e5 fc ff 	ld.a %a5,[%a14]-4 <80000008 <BootModeHeader0+0x8>>
80005ade:	a0 06       	mov.a %a6,0
80005ae0:	6d 00 c8 14 	call 80008470 <osEE_hal_sync_barrier>
      OSEE_STARTOS_2ND_SYNC_BARRIER_CB);
/* After second synchronization I'm sure that no more AR cores will be
   started: I initialize the Shutdown(AllCores) mask in master core */
    if (curr_core_id == OS_CORE_ID_MASTER) {
80005ae4:	f6 a4       	jnz %d10,80005aec <StartOS+0x1b8>
      p_kcb->ar_shutdown_mask = p_kcb->ar_core_mask;
80005ae6:	54 c3       	ld.w %d3,[%a12]
80005ae8:	59 c3 08 00 	st.w [%a12]8,%d3
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
80005aec:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000010 <BootModeHeader0+0x10>>
80005af0:	5e 14       	jne %d15,1,80005af8 <StartOS+0x1c4>
      p_ccb->os_status = OSEE_KERNEL_STARTED;
80005af2:	82 2f       	mov %d15,2
80005af4:	e9 ff 10 00 	st.b [%a15]16 <80000010 <BootModeHeader0+0x10>>,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005af8:	39 ff 23 00 	ld.bu %d15,[%a15]35 <80000023 <_start+0x3>>
80005afc:	5e 17       	jne %d15,1,80005b0a <StartOS+0x1d6>
    p_ccb->service_id            = service_id;
80005afe:	da 4a       	mov %d15,74
80005b00:	e9 ff 13 00 	st.b [%a15]19 <80000013 <BootModeHeader0+0x13>>,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80005b04:	82 0f       	mov %d15,0
80005b06:	e9 ff 23 00 	st.b [%a15]35 <80000023 <_start+0x3>>,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
80005b0a:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000010 <BootModeHeader0+0x10>>
80005b0e:	5e 2a       	jne %d15,2,80005b22 <StartOS+0x1ee>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
80005b10:	60 d4       	mov.a %a4,%d13
80005b12:	99 45 04 00 	ld.a %a5,[%a4]4
80005b16:	40 56       	mov.aa %a6,%a5
80005b18:	6d 00 54 15 	call 800085c0 <osEE_hal_save_ctx_and_ready2stacked>
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
80005b1c:	60 d4       	mov.a %a4,%d13
80005b1e:	6d 00 a2 0d 	call 80007662 <osEE_task_end>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80005b22:	0d 00 40 03 	disable 
 *  \brief Locks the kernel.
 *  
 *  Locks the kernel using the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_lock_kernel(void) {
  osEE_hal_spin_lock(osEE_kdb_var.p_lock);
80005b26:	91 00 00 f8 	movh.a %a15,32768
80005b2a:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
80005b2e:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80005b30:	82 14       	mov %d4,1
80005b32:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80005b36:	82 05       	mov %d5,0
80005b38:	59 e5 f8 ff 	st.w [%a14]-8,%d5
80005b3c:	09 e2 74 f9 	ld.d %e2,[%a14]-12
80005b40:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80005b44:	df 02 f6 ff 	jne %d2,0,80005b30 <StartOS+0x1fc>
#if (!defined(OSEE_SINGLECORE))
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
80005b48:	91 00 00 28 	movh.a %a2,32768
80005b4c:	99 25 28 00 	ld.a %a5,[%a2]40 <80000028 <osEE_kdb_var>>

    if (p_kcb->ar_shutdown_all_cores_flag) {
80005b50:	0c 5e       	ld.bu %d15,[%a5]14
80005b52:	6e 0e       	jz %d15,80005b6e <StartOS+0x23a>
80005b54:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80005b58:	82 0f       	mov %d15,0
80005b5a:	68 0f       	st.w [%a15]0,%d15
         participating to shutdown */
      osEE_unlock_kernel();

      /* [OS587]: Before calling the global ShutdownHook, all cores shall be
          synchronized. (BSW4080007) */
      osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_shutdown_mask,
80005b5c:	d9 2f 28 00 	lea %a15,[%a2]40 <80000028 <osEE_kdb_var>>
80005b60:	c8 24       	ld.a %a4,[%a15]8
80005b62:	d9 55 08 00 	lea %a5,[%a5]8 <80000002 <BootModeHeader0+0x2>>
80005b66:	a0 06       	mov.a %a6,0
80005b68:	6d 00 84 14 	call 80008470 <osEE_hal_sync_barrier>
80005b6c:	3c 12       	j 80005b90 <StartOS+0x25c>
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80005b6e:	4d c0 e1 ff 	mfcr %d15,$core_id
80005b72:	16 ff       	and %d15,255
        OSEE_SHUTDOWNOS_SYNC_BARRIER_CB);
    } else {
      /* Remove this core from the waiting mask: this core has already reached
         the barrier/ it's already shutdown */
      p_kcb->ar_shutdown_mask &=
80005b74:	19 52 08 00 	ld.w %d2,[%a5]8
80005b78:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80005b7c:	6c 52       	st.w [%a5]8,%d15
 *  \brief Unlocks the kernel.
 *  
 *  Unlock the kernel by releasing the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_unlock_kernel(void) {
  osEE_hal_spin_unlock(osEE_kdb_var.p_lock);
80005b7e:	91 00 00 f8 	movh.a %a15,32768
80005b82:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
80005b86:	c8 1f       	ld.a %a15,[%a15]4
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80005b88:	0d 00 80 04 	dsync 
80005b8c:	82 0f       	mov %d15,0
80005b8e:	68 0f       	st.w [%a15]0,%d15
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
80005b90:	3c 00       	j 80005b90 <StartOS+0x25c>
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80005b92:	82 42       	mov %d2,4
80005b94:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80005b98:	e9 f8 12 00 	st.b [%a15]18,%d8
    ErrorHook(Error);
80005b9c:	02 84       	mov %d4,%d8
80005b9e:	6d ff ce f3 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80005ba2:	e9 ff 14 00 	st.b [%a15]20,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005ba6:	39 ff 23 00 	ld.bu %d15,[%a15]35
80005baa:	5e 17       	jne %d15,1,80005bb8 <StartOS+0x284>
    p_ccb->service_id            = service_id;
80005bac:	da 4a       	mov %d15,74
80005bae:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80005bb2:	82 0f       	mov %d15,0
80005bb4:	e9 ff 23 00 	st.b [%a15]35,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005bb8:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005bbc:	5f df 54 00 	jeq %d15,%d13,80005c64 <StartOS+0x330>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005bc0:	cd cd e2 0f 	mtcr $icr,%d13
80005bc4:	0d 00 c0 04 	isync 
80005bc8:	3c 4e       	j 80005c64 <StartOS+0x330>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80005bca:	39 ff 14 00 	ld.bu %d15,[%a15]20
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
80005bce:	3b 80 01 80 	mov %d8,24
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80005bd2:	df 4f e0 ff 	jne %d15,4,80005b92 <StartOS+0x25e>
80005bd6:	3c e8       	j 80005ba6 <StartOS+0x272>
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
80005bd8:	02 cf       	mov %d15,%d12
80005bda:	82 0e       	mov %d14,0
80005bdc:	1d ff da fe 	j 80005990 <StartOS+0x5c>
          "This release of the AUTOSAR specification does not support timeouts
          during the synchronization phase. Cores that are activated with
          StartCore but do not call StartOS may cause the system to hang.
          It is in the responsibility of the integrator to avoid such
          behavior." */
    osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_core_mask,
80005be0:	b5 ec fc ff 	st.a [%a14]-4,%a12
80005be4:	91 00 00 28 	movh.a %a2,32768
80005be8:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80005bec:	99 24 08 00 	ld.a %a4,[%a2]8 <80000008 <BootModeHeader0+0x8>>
80005bf0:	40 c5       	mov.aa %a5,%a12
80005bf2:	a0 06       	mov.a %a6,0
80005bf4:	6d 00 3e 14 	call 80008470 <osEE_hal_sync_barrier>
      OSEE_STARTOS_1ST_SYNC_BARRIER_CB);

    /* Initialize Slaves Hardware after First synchronization point:
       This ensures that all the Master Initializations have been done. */
    if (curr_core_id != OS_CORE_ID_MASTER) {
      if (!osEE_cpu_startos()) {
80005bf8:	6d 00 af 13 	call 80008356 <osEE_cpu_startos>
80005bfc:	df 02 c9 7e 	jeq %d2,0,8000598e <StartOS+0x5a>
80005c00:	3c ec       	j 80005bd8 <StartOS+0x2a4>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
80005c02:	19 dd 14 00 	ld.w %d13,[%a13]20
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80005c06:	82 1f       	mov %d15,1
80005c08:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
80005c0c:	e9 fc 11 00 	st.b [%a15]17,%d12
80005c10:	8f fe 0f e1 	and %d14,%d14,255
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
      (p_kcb->ar_core_mask & ((CoreMaskType)1U << (OsEE_reg)curr_core_id)) ==
80005c14:	4c c0       	ld.w %d15,[%a12]0
80005c16:	57 0f 61 ee 	extr.u %d14,%d15,%d14,1
    shall be used. (SRS_Os_80006) */
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
80005c1a:	df 0e b9 7e 	jeq %d14,0,8000598c <StartOS+0x58>
80005c1e:	3c e1       	j 80005be0 <StartOS+0x2ac>
          "This release of the AUTOSAR specification does not support timeouts
          during the synchronization phase. Cores that are activated with
          StartCore but do not call StartOS may cause the system to hang.
          It is in the responsibility of the integrator to avoid such
          behavior." */
    osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_core_mask,
80005c20:	b5 ec fc ff 	st.a [%a14]-4,%a12
80005c24:	91 00 00 28 	movh.a %a2,32768
80005c28:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80005c2c:	99 24 08 00 	ld.a %a4,[%a2]8 <80000008 <BootModeHeader0+0x8>>
80005c30:	40 c5       	mov.aa %a5,%a12
80005c32:	a0 06       	mov.a %a6,0
80005c34:	6d 00 1e 14 	call 80008470 <osEE_hal_sync_barrier>
80005c38:	3c d0       	j 80005bd8 <StartOS+0x2a4>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
80005c3a:	19 dd 14 00 	ld.w %d13,[%a13]20
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80005c3e:	82 1f       	mov %d15,1
80005c40:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
80005c44:	e9 fc 11 00 	st.b [%a15]17,%d12
80005c48:	8f fe 0f e1 	and %d14,%d14,255
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
      (p_kcb->ar_core_mask & ((CoreMaskType)1U << (OsEE_reg)curr_core_id)) ==
80005c4c:	4c c0       	ld.w %d15,[%a12]0
80005c4e:	57 0f 61 ee 	extr.u %d14,%d15,%d14,1
    shall be used. (SRS_Os_80006) */
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
80005c52:	df 0e 9d 7e 	jeq %d14,0,8000598c <StartOS+0x58>
80005c56:	3c e5       	j 80005c20 <StartOS+0x2ec>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80005c58:	39 ff 14 00 	ld.bu %d15,[%a15]20

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
80005c5c:	82 18       	mov %d8,1
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80005c5e:	df 4f 9a ff 	jne %d15,4,80005b92 <StartOS+0x25e>
80005c62:	3c a5       	j 80005bac <StartOS+0x278>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
80005c64:	02 82       	mov %d2,%d8
80005c66:	00 90       	ret 

80005c68 <GetActiveApplicationMode>:
FUNC(AppModeType, OS_CODE)
  GetActiveApplicationMode
(
  void
)
{
80005c68:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80005c6a:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
80005c6c:	c8 3f       	ld.a %a15,[%a15]12

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80005c6e:	39 ff 10 00 	ld.bu %d15,[%a15]16 <3 <_.+0x2>>
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
80005c72:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80005c76:	6e 03       	jz %d15,80005c7c <GetActiveApplicationMode+0x14>
    app_mode = p_ccb->app_mode;
80005c78:	39 f2 11 00 	ld.bu %d2,[%a15]17
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
80005c7c:	da 46       	mov %d15,70
80005c7e:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80005c82:	82 0f       	mov %d15,0
80005c84:	e9 ff 23 00 	st.b [%a15]35,%d15
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
80005c88:	00 90       	ret 

80005c8a <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80005c8a:	40 ae       	mov.aa %a14,%sp
80005c8c:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80005c8e:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80005c90:	82 1f       	mov %d15,1
80005c92:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80005c96:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80005c9a:	91 00 00 28 	movh.a %a2,32768
80005c9e:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80005ca2:	19 22 10 00 	ld.w %d2,[%a2]16 <80000010 <BootModeHeader0+0x10>>
80005ca6:	82 3f       	mov %d15,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80005ca8:	7f 24 31 80 	jge.u %d4,%d2,80005d0a <ActivateTask+0x80>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
80005cac:	91 00 00 28 	movh.a %a2,32768
80005cb0:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80005cb4:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
80005cb8:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80005cbc:	d4 2c       	ld.a %a12,[%a2]

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80005cbe:	39 c2 14 00 	ld.bu %d2,[%a12]20
80005cc2:	ff 22 24 80 	jge.u %d2,2,80005d0a <ActivateTask+0x80>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005cc6:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005cca:	8f f8 0f f1 	and %d15,%d8,255
80005cce:	ff 2f 09 80 	jge.u %d15,2,80005ce0 <ActivateTask+0x56>
    OsEE_icr icr_temp = icr;
80005cd2:	02 8f       	mov %d15,%d8
80005cd4:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005cd8:	cd cf e2 0f 	mtcr $icr,%d15
80005cdc:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
80005ce0:	40 c4       	mov.aa %a4,%a12
80005ce2:	6d 00 a0 0c 	call 80007622 <osEE_task_activated>
80005ce6:	02 2f       	mov %d15,%d2

      if (ev == E_OK) {
80005ce8:	f6 28       	jnz %d2,80005cf8 <ActivateTask+0x6e>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
80005cea:	91 00 00 48 	movh.a %a4,32768
80005cee:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80005cf2:	40 c5       	mov.aa %a5,%a12
80005cf4:	6d 00 23 0d 	call 8000773a <osEE_scheduler_task_activated>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005cf8:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005cfc:	5f 82 06 00 	jeq %d2,%d8,80005d08 <ActivateTask+0x7e>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005d00:	cd c8 e2 0f 	mtcr $icr,%d8
80005d04:	0d 00 c0 04 	isync 
      ev = E_OS_ID;
    }
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80005d08:	6e 24       	jz %d15,80005d50 <ActivateTask+0xc6>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005d0a:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005d0e:	8f f9 0f 21 	and %d2,%d9,255
80005d12:	ff 22 09 80 	jge.u %d2,2,80005d24 <ActivateTask+0x9a>
    OsEE_icr icr_temp = icr;
80005d16:	02 92       	mov %d2,%d9
80005d18:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005d1c:	cd c2 e2 0f 	mtcr $icr,%d2
80005d20:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80005d24:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80005d28:	df 48 0c 00 	jeq %d8,4,80005d40 <ActivateTask+0xb6>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80005d2c:	82 42       	mov %d2,4
80005d2e:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80005d32:	e9 ff 12 00 	st.b [%a15]18,%d15
    ErrorHook(Error);
80005d36:	02 f4       	mov %d4,%d15
80005d38:	6d ff 01 f3 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80005d3c:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005d40:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005d44:	5f 92 06 00 	jeq %d2,%d9,80005d50 <ActivateTask+0xc6>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005d48:	cd c9 e2 0f 	mtcr $icr,%d9
80005d4c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005d50:	39 f2 23 00 	ld.bu %d2,[%a15]35
80005d54:	df 12 07 80 	jne %d2,1,80005d62 <ActivateTask+0xd8>
    p_ccb->service_id            = service_id;
80005d58:	82 02       	mov %d2,0
80005d5a:	e9 f2 13 00 	st.b [%a15]19,%d2
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80005d5e:	e9 f2 23 00 	st.b [%a15]35,%d2
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80005d62:	02 f2       	mov %d2,%d15
80005d64:	00 90       	ret 

80005d66 <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80005d66:	40 ae       	mov.aa %a14,%sp
80005d68:	40 9f       	mov.aa %a15,%a9
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
80005d6a:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
80005d6c:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80005d6e:	82 5f       	mov %d15,5
80005d70:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80005d74:	82 1f       	mov %d15,1
80005d76:	e9 ff 23 00 	st.b [%a15]35,%d15
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#if (defined(OSEE_HAS_CHECKS))
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80005d7a:	39 2f 14 00 	ld.bu %d15,[%a2]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
      || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80005d7e:	82 29       	mov %d9,2
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#if (defined(OSEE_HAS_CHECKS))
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80005d80:	ff 2f 82 80 	jge.u %d15,2,80005e84 <ChainTask+0x11e>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80005d84:	91 00 00 38 	movh.a %a3,32768
80005d88:	d9 33 28 00 	lea %a3,[%a3]40 <80000028 <osEE_kdb_var>>
80005d8c:	4c 34       	ld.w %d15,[%a3]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80005d8e:	82 39       	mov %d9,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80005d90:	7f f4 7a 80 	jge.u %d4,%d15,80005e84 <ChainTask+0x11e>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
80005d94:	91 00 00 38 	movh.a %a3,32768
80005d98:	d9 33 28 00 	lea %a3,[%a3]40 <80000028 <osEE_kdb_var>>
80005d9c:	99 33 0c 00 	ld.a %a3,[%a3]12 <8000000c <BootModeHeader0+0xc>>
80005da0:	01 34 02 36 	addsc.a %a3,%a3,%d4,2
80005da4:	d4 3c       	ld.a %a12,[%a3]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80005da6:	39 cf 14 00 	ld.bu %d15,[%a12]20
80005daa:	ff 2f 6d 80 	jge.u %d15,2,80005e84 <ChainTask+0x11e>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80005dae:	39 ff 20 00 	ld.bu %d15,[%a15]32
80005db2:	6e 09       	jz %d15,80005dc4 <ChainTask+0x5e>
        p_ccb->s_isr_all_cnt = 0U;
80005db4:	82 0f       	mov %d15,0
80005db6:	e9 ff 20 00 	st.b [%a15]32,%d15
80005dba:	4c f6       	ld.w %d15,[%a15]24
80005dbc:	cd cf e2 0f 	mtcr $icr,%d15
80005dc0:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
80005dc4:	39 ff 22 00 	ld.bu %d15,[%a15]34
80005dc8:	6e 06       	jz %d15,80005dd4 <ChainTask+0x6e>
        p_ccb->d_isr_all_cnt = 0U;
80005dca:	82 0f       	mov %d15,0
80005dcc:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80005dd0:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005dd4:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005dd8:	8f ff 0f 21 	and %d2,%d15,255
80005ddc:	ff 22 09 80 	jge.u %d2,2,80005dee <ChainTask+0x88>
    OsEE_icr icr_temp = icr;
80005de0:	02 f2       	mov %d2,%d15
80005de2:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005de6:	cd c2 e2 0f 	mtcr $icr,%d2
80005dea:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
80005dee:	7d 2c 06 80 	jne.a %a12,%a2,80005dfa <ChainTask+0x94>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
80005df2:	cc c3       	ld.a %a15,[%a12]12
80005df4:	82 5f       	mov %d15,5
80005df6:	28 2f       	st.b [%a15]2,%d15
80005df8:	3c 3b       	j 80005e6e <ChainTask+0x108>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
80005dfa:	40 c4       	mov.aa %a4,%a12
80005dfc:	6d 00 13 0c 	call 80007622 <osEE_task_activated>
80005e00:	02 29       	mov %d9,%d2
        if (ev == E_OK) {
80005e02:	df 02 3d 80 	jne %d2,0,80005e7c <ChainTask+0x116>
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
80005e06:	91 00 00 48 	movh.a %a4,32768
80005e0a:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80005e0e:	40 c5       	mov.aa %a5,%a12
80005e10:	6d 00 fe 0c 	call 8000780c <osEE_scheduler_task_insert>
80005e14:	3c 2d       	j 80005e6e <ChainTask+0x108>
80005e16:	cd cf e2 0f 	mtcr $icr,%d15
80005e1a:	0d 00 c0 04 	isync 
80005e1e:	3c 33       	j 80005e84 <ChainTask+0x11e>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
80005e20:	02 f2       	mov %d2,%d15
80005e22:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005e26:	cd c2 e2 0f 	mtcr $icr,%d2
80005e2a:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80005e2e:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80005e32:	df 48 0c 00 	jeq %d8,4,80005e4a <ChainTask+0xe4>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80005e36:	82 42       	mov %d2,4
80005e38:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80005e3c:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80005e40:	02 94       	mov %d4,%d9
80005e42:	6d ff 7c f2 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80005e46:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005e4a:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005e4e:	5f f3 06 00 	jeq %d3,%d15,80005e5a <ChainTask+0xf4>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005e52:	cd cf e2 0f 	mtcr $icr,%d15
80005e56:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005e5a:	39 ff 23 00 	ld.bu %d15,[%a15]35
80005e5e:	de 1a       	jne %d15,1,80005e92 <ChainTask+0x12c>
    p_ccb->service_id            = service_id;
80005e60:	82 4f       	mov %d15,4
80005e62:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80005e66:	82 0f       	mov %d15,0
80005e68:	e9 ff 23 00 	st.b [%a15]35,%d15
80005e6c:	3c 13       	j 80005e92 <ChainTask+0x12c>
80005e6e:	40 9f       	mov.aa %a15,%a9
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80005e70:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
80005e72:	c8 0f       	ld.a %a15,[%a15]0
80005e74:	c8 14       	ld.a %a4,[%a15]4
80005e76:	a0 05       	mov.a %a5,0
80005e78:	1d 00 db 13 	j 8000862e <osEE_hal_terminate_ctx>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005e7c:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005e80:	5f f2 cb ff 	jne %d2,%d15,80005e16 <ChainTask+0xb0>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005e84:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005e88:	8f ff 0f 31 	and %d3,%d15,255
80005e8c:	ff 23 d1 ff 	jge.u %d3,2,80005e2e <ChainTask+0xc8>
80005e90:	3c c8       	j 80005e20 <ChainTask+0xba>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
80005e92:	02 92       	mov %d2,%d9
80005e94:	00 90       	ret 

80005e96 <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
80005e96:	40 ae       	mov.aa %a14,%sp
80005e98:	40 9f       	mov.aa %a15,%a9
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
80005e9a:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80005e9c:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80005e9e:	82 3f       	mov %d15,3
80005ea0:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80005ea4:	82 1f       	mov %d15,1
80005ea6:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80005eaa:	39 2f 14 00 	ld.bu %d15,[%a2]20
80005eae:	bf 2f 09 80 	jlt.u %d15,2,80005ec0 <TerminateTask+0x2a>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005eb2:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005eb6:	8f f8 0f f1 	and %d15,%d8,255
80005eba:	ff 2f 2e 80 	jge.u %d15,2,80005f16 <TerminateTask+0x80>
80005ebe:	3c 25       	j 80005f08 <TerminateTask+0x72>
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80005ec0:	39 ff 20 00 	ld.bu %d15,[%a15]32
80005ec4:	6e 09       	jz %d15,80005ed6 <TerminateTask+0x40>
        p_ccb->s_isr_all_cnt = 0U;
80005ec6:	82 0f       	mov %d15,0
80005ec8:	e9 ff 20 00 	st.b [%a15]32,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005ecc:	4c f6       	ld.w %d15,[%a15]24
80005ece:	cd cf e2 0f 	mtcr $icr,%d15
80005ed2:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
80005ed6:	39 ff 22 00 	ld.bu %d15,[%a15]34
80005eda:	6e 06       	jz %d15,80005ee6 <TerminateTask+0x50>
        p_ccb->d_isr_all_cnt = 0U;
80005edc:	82 0f       	mov %d15,0
80005ede:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80005ee2:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005ee6:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005eea:	8f ff 0f 21 	and %d2,%d15,255
80005eee:	ff 22 08 80 	jge.u %d2,2,80005efe <TerminateTask+0x68>
80005ef2:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005ef6:	cd cf e2 0f 	mtcr $icr,%d15
80005efa:	0d 00 c0 04 	isync 
80005efe:	99 24 04 00 	ld.a %a4,[%a2]4
80005f02:	a0 05       	mov.a %a5,0
80005f04:	1d 00 95 13 	j 8000862e <osEE_hal_terminate_ctx>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
80005f08:	02 8f       	mov %d15,%d8
80005f0a:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005f0e:	cd cf e2 0f 	mtcr $icr,%d15
80005f12:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80005f16:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80005f1a:	1e 4c       	jeq %d15,4,80005f32 <TerminateTask+0x9c>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80005f1c:	82 42       	mov %d2,4
80005f1e:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80005f22:	82 22       	mov %d2,2
80005f24:	e9 f2 12 00 	st.b [%a15]18,%d2
    ErrorHook(Error);
80005f28:	82 24       	mov %d4,2
80005f2a:	6d ff 08 f2 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80005f2e:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005f32:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005f36:	3e 85       	jeq %d15,%d8,80005f40 <TerminateTask+0xaa>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005f38:	cd c8 e2 0f 	mtcr $icr,%d8
80005f3c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80005f40:	39 ff 23 00 	ld.bu %d15,[%a15]35
80005f44:	5e 17       	jne %d15,1,80005f52 <TerminateTask+0xbc>
    p_ccb->service_id            = service_id;
80005f46:	82 2f       	mov %d15,2
80005f48:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80005f4c:	82 0f       	mov %d15,0
80005f4e:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_TerminateTask);

  return ev;
}
80005f52:	82 22       	mov %d2,2
80005f54:	00 90       	ret 

80005f56 <Schedule>:
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
80005f56:	40 ae       	mov.aa %a14,%sp
80005f58:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
80005f5a:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
80005f5c:	c8 0c       	ld.a %a12,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
80005f5e:	99 cd 0c 00 	ld.a %a13,[%a12]12 <0 <NULL>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80005f62:	82 7f       	mov %d15,7
80005f64:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80005f68:	82 1f       	mov %d15,1
80005f6a:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
  if (osEE_check_disableint(p_curr_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80005f6e:	39 cf 14 00 	ld.bu %d15,[%a12]20
80005f72:	ff 2f 55 80 	jge.u %d15,2,8000601c <Schedule+0xc6>
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
80005f76:	39 d2 01 00 	ld.bu %d2,[%a13]1
80005f7a:	39 cf 1d 00 	ld.bu %d15,[%a12]29
80005f7e:	5f f2 4d 80 	jne %d2,%d15,80006018 <Schedule+0xc2>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005f82:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80005f86:	8f f8 0f f1 	and %d15,%d8,255
80005f8a:	ff 2f 09 80 	jge.u %d15,2,80005f9c <Schedule+0x46>
    OsEE_icr icr_temp = icr;
80005f8e:	02 8f       	mov %d15,%d8
80005f90:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005f94:	cd cf e2 0f 	mtcr $icr,%d15
80005f98:	0d 00 c0 04 	isync 
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
80005f9c:	39 cf 1c 00 	ld.bu %d15,[%a12]28
80005fa0:	2c d1       	st.b [%a13]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
80005fa2:	91 00 00 48 	movh.a %a4,32768
80005fa6:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80005faa:	6d 00 33 0d 	call 80007a10 <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
80005fae:	39 cf 1d 00 	ld.bu %d15,[%a12]29
80005fb2:	2c d1       	st.b [%a13]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005fb4:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005fb8:	5f 8f 30 00 	jeq %d15,%d8,80006018 <Schedule+0xc2>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005fbc:	cd c8 e2 0f 	mtcr $icr,%d8
80005fc0:	0d 00 c0 04 	isync 
80005fc4:	3c 2a       	j 80006018 <Schedule+0xc2>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
80005fc6:	02 f2       	mov %d2,%d15
80005fc8:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005fcc:	cd c2 e2 0f 	mtcr $icr,%d2
80005fd0:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80005fd4:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80005fd8:	df 48 0d 00 	jeq %d8,4,80005ff2 <Schedule+0x9c>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80005fdc:	82 42       	mov %d2,4
80005fde:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80005fe2:	82 22       	mov %d2,2
80005fe4:	e9 f2 12 00 	st.b [%a15]18,%d2
    ErrorHook(Error);
80005fe8:	82 24       	mov %d4,2
80005fea:	6d ff a8 f1 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80005fee:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80005ff2:	4d c0 e2 3f 	mfcr %d3,$icr
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_curr_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80005ff6:	82 22       	mov %d2,2
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80005ff8:	5f f3 06 00 	jeq %d3,%d15,80006004 <Schedule+0xae>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80005ffc:	cd cf e2 0f 	mtcr $icr,%d15
80006000:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006004:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006008:	de 11       	jne %d15,1,8000602a <Schedule+0xd4>
    p_ccb->service_id            = service_id;
8000600a:	82 6f       	mov %d15,6
8000600c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006010:	82 0f       	mov %d15,0
80006012:	e9 ff 23 00 	st.b [%a15]35,%d15
80006016:	00 90       	ret 
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
80006018:	82 02       	mov %d2,0
8000601a:	3c f5       	j 80006004 <Schedule+0xae>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000601c:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006020:	8f ff 0f 21 	and %d2,%d15,255
80006024:	ff 22 d8 ff 	jge.u %d2,2,80005fd4 <Schedule+0x7e>
80006028:	3c cf       	j 80005fc6 <Schedule+0x70>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000602a:	00 90       	ret 

8000602c <ShutdownOS>:
FUNC(StatusType, OS_CODE)
  ShutdownOS
(
  VAR(StatusType, AUTOMATIC) Error
)
{
8000602c:	40 ae       	mov.aa %a14,%sp
8000602e:	40 94       	mov.aa %a4,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006030:	cc 43       	ld.a %a15,[%a4]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006032:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006036:	8f f8 0f f1 	and %d15,%d8,255
8000603a:	ff 2f 09 80 	jge.u %d15,2,8000604c <ShutdownOS+0x20>
    OsEE_icr icr_temp = icr;
8000603e:	02 8f       	mov %d15,%d8
80006040:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006044:	cd cf e2 0f 	mtcr $icr,%d15
80006048:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000604c:	39 ff 10 00 	ld.bu %d15,[%a15]16
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006050:	3b 90 04 20 	mov %d2,73
80006054:	e9 f2 13 00 	st.b [%a15]19,%d2
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006058:	82 12       	mov %d2,1
8000605a:	e9 f2 23 00 	st.b [%a15]35,%d2
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((os_status == OSEE_KERNEL_STARTED) || (os_status == OSEE_KERNEL_STARTING))
8000605e:	c2 ff       	add %d15,-1
80006060:	16 ff       	and %d15,255
80006062:	ff 2f 04 80 	jge.u %d15,2,8000606a <ShutdownOS+0x3e>
  {
OSEE_WARN_LABEL(osee_useless_ev_assign)
    ev = E_OK;
    osEE_shutdown_os(p_cdb, Error);
80006066:	1d ff 8b fb 	j 8000577c <osEE_shutdown_os>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
8000606a:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
8000606e:	1e 4f       	jeq %d15,4,8000608c <ShutdownOS+0x60>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006070:	82 42       	mov %d2,4
80006072:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006076:	82 72       	mov %d2,7
80006078:	e9 f2 12 00 	st.b [%a15]18,%d2
    ErrorHook(Error);
8000607c:	82 74       	mov %d4,7
8000607e:	6d ff 5e f1 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006082:	e9 ff 14 00 	st.b [%a15]20,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006086:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000608a:	5e 17       	jne %d15,1,80006098 <ShutdownOS+0x6c>
    p_ccb->service_id            = service_id;
8000608c:	da 48       	mov %d15,72
8000608e:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006092:	82 0f       	mov %d15,0
80006094:	e9 ff 23 00 	st.b [%a15]35,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006098:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000609c:	3e 85       	jeq %d15,%d8,800060a6 <ShutdownOS+0x7a>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000609e:	cd c8 e2 0f 	mtcr $icr,%d8
800060a2:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
800060a6:	82 72       	mov %d2,7
800060a8:	00 90       	ret 

800060aa <GetTaskID>:
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
800060aa:	40 ae       	mov.aa %a14,%sp
800060ac:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800060ae:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800060b0:	da 09       	mov %d15,9
800060b2:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800060b6:	82 1f       	mov %d15,1
800060b8:	e9 ff 23 00 	st.b [%a15]35,%d15
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
800060bc:	bd 04 50 00 	jz.a %a4,8000615c <GetTaskID+0xb2>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
800060c0:	c8 02       	ld.a %a2,[%a15]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
800060c2:	39 2f 14 00 	ld.bu %d15,[%a2]20 <0 <NULL>>
800060c6:	ff 2f 05 80 	jge.u %d15,2,800060d0 <GetTaskID+0x26>
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
800060ca:	19 22 10 00 	ld.w %d2,[%a2]16
800060ce:	3c 1b       	j 80006104 <GetTaskID+0x5a>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
800060d0:	82 f2       	mov %d2,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
800060d2:	de 29       	jne %d15,2,80006104 <GetTaskID+0x5a>
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
800060d4:	c8 32       	ld.a %a2,[%a15]12
800060d6:	d4 22       	ld.a %a2,[%a2]

      while (p_sn != NULL) {
800060d8:	bd 02 16 00 	jz.a %a2,80006104 <GetTaskID+0x5a>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
800060dc:	99 23 04 00 	ld.a %a3,[%a2]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
800060e0:	39 3f 14 00 	ld.bu %d15,[%a3]20
800060e4:	ff 2f 0c 80 	jge.u %d15,2,800060fc <GetTaskID+0x52>
800060e8:	3c 07       	j 800060f6 <GetTaskID+0x4c>
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
800060ea:	99 23 04 00 	ld.a %a3,[%a2]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
800060ee:	39 3f 14 00 	ld.bu %d15,[%a3]20
800060f2:	ff 2f 05 80 	jge.u %d15,2,800060fc <GetTaskID+0x52>
          tid = p_searched_tdb->tid;
800060f6:	19 32 10 00 	ld.w %d2,[%a3]16
          break;
800060fa:	3c 05       	j 80006104 <GetTaskID+0x5a>
        } else {
          p_sn = p_sn->p_next;
800060fc:	d4 22       	ld.a %a2,[%a2]
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
800060fe:	bd 02 f6 ff 	jnz.a %a2,800060ea <GetTaskID+0x40>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80006102:	82 f2       	mov %d2,-1
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
80006104:	74 42       	st.w [%a4],%d2
    ev = E_OK;
80006106:	82 02       	mov %d2,0
80006108:	3c 20       	j 80006148 <GetTaskID+0x9e>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
8000610a:	02 8f       	mov %d15,%d8
8000610c:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006110:	cd cf e2 0f 	mtcr $icr,%d15
80006114:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006118:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
8000611c:	1e 4d       	jeq %d15,4,80006136 <GetTaskID+0x8c>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
8000611e:	82 42       	mov %d2,4
80006120:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006124:	3b e0 00 20 	mov %d2,14
80006128:	e9 f2 12 00 	st.b [%a15]18,%d2
    ErrorHook(Error);
8000612c:	02 24       	mov %d4,%d2
8000612e:	6d ff 06 f1 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006132:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006136:	4d c0 e2 ff 	mfcr %d15,$icr
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
8000613a:	3b e0 00 20 	mov %d2,14
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000613e:	3e 85       	jeq %d15,%d8,80006148 <GetTaskID+0x9e>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006140:	cd c8 e2 0f 	mtcr $icr,%d8
80006144:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006148:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000614c:	5e 1f       	jne %d15,1,8000616a <GetTaskID+0xc0>
    p_ccb->service_id            = service_id;
8000614e:	da 08       	mov %d15,8
80006150:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006154:	82 0f       	mov %d15,0
80006156:	e9 ff 23 00 	st.b [%a15]35,%d15
8000615a:	00 90       	ret 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000615c:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006160:	8f f8 0f f1 	and %d15,%d8,255
80006164:	ff 2f da ff 	jge.u %d15,2,80006118 <GetTaskID+0x6e>
80006168:	3c d1       	j 8000610a <GetTaskID+0x60>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
8000616a:	00 90       	ret 

8000616c <GetTaskState>:
  GetTaskState
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(TaskStateRefType, AUTOMATIC)  State
)
{
8000616c:	40 ae       	mov.aa %a14,%sp
8000616e:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006170:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006172:	da 0b       	mov %d15,11
80006174:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006178:	82 1f       	mov %d15,1
8000617a:	e9 ff 23 00 	st.b [%a15]35,%d15
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
8000617e:	bd 04 60 00 	jz.a %a4,8000623e <GetTaskState+0xd2>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80006182:	91 00 00 28 	movh.a %a2,32768
80006186:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
8000618a:	4c 24       	ld.w %d15,[%a2]16
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000618c:	82 39       	mov %d9,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000618e:	7f f4 5a 80 	jge.u %d4,%d15,80006242 <GetTaskState+0xd6>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
80006192:	91 00 00 28 	movh.a %a2,32768
80006196:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
8000619a:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
8000619e:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
800061a2:	d4 22       	ld.a %a2,[%a2]
800061a4:	99 22 0c 00 	ld.a %a2,[%a2]12
    switch (local_state) {
800061a8:	0c 22       	ld.bu %d15,[%a2]2
        break;
      default:
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
800061aa:	82 09       	mov %d9,0
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
800061ac:	ff 6f 3d 80 	jge.u %d15,6,80006226 <GetTaskState+0xba>
800061b0:	91 00 00 28 	movh.a %a2,32768
800061b4:	d9 22 3c 66 	lea %a2,[%a2]25020 <800061bc <GetTaskState+0x50>>
800061b8:	90 22       	addsc.a %a2,%a2,%d15,2
800061ba:	dc 02       	ji %a2
800061bc:	1d 00 0c 00 	j 800061d4 <GetTaskState+0x68>
800061c0:	1d 00 0d 00 	j 800061da <GetTaskState+0x6e>
800061c4:	1d 00 0b 00 	j 800061da <GetTaskState+0x6e>
800061c8:	1d 00 0c 00 	j 800061e0 <GetTaskState+0x74>
800061cc:	1d 00 0d 00 	j 800061e6 <GetTaskState+0x7a>
800061d0:	1d 00 0b 00 	j 800061e6 <GetTaskState+0x7a>
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
800061d4:	82 0f       	mov %d15,0
800061d6:	2c 40       	st.b [%a4]0,%d15
        break;
800061d8:	3c 31       	j 8000623a <GetTaskState+0xce>
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
800061da:	82 1f       	mov %d15,1
800061dc:	2c 40       	st.b [%a4]0,%d15
        break;
800061de:	3c 2e       	j 8000623a <GetTaskState+0xce>
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
800061e0:	82 3f       	mov %d15,3
800061e2:	2c 40       	st.b [%a4]0,%d15
        break;
800061e4:	3c 2b       	j 8000623a <GetTaskState+0xce>
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
800061e6:	82 4f       	mov %d15,4
800061e8:	2c 40       	st.b [%a4]0,%d15
        break;
800061ea:	3c 28       	j 8000623a <GetTaskState+0xce>
    OsEE_icr icr_temp = icr;
800061ec:	02 f2       	mov %d2,%d15
800061ee:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800061f2:	cd c2 e2 0f 	mtcr $icr,%d2
800061f6:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
800061fa:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
800061fe:	df 48 0c 00 	jeq %d8,4,80006216 <GetTaskState+0xaa>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006202:	82 42       	mov %d2,4
80006204:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006208:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
8000620c:	02 94       	mov %d4,%d9
8000620e:	6d ff 96 f0 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006212:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006216:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000621a:	5f f3 06 00 	jeq %d3,%d15,80006226 <GetTaskState+0xba>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000621e:	cd cf e2 0f 	mtcr $icr,%d15
80006222:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006226:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000622a:	de 13       	jne %d15,1,80006250 <GetTaskState+0xe4>
    p_ccb->service_id            = service_id;
8000622c:	da 0a       	mov %d15,10
8000622e:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006232:	82 0f       	mov %d15,0
80006234:	e9 ff 23 00 	st.b [%a15]35,%d15
80006238:	3c 0c       	j 80006250 <GetTaskState+0xe4>
      default:
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000623a:	82 09       	mov %d9,0
8000623c:	3c f5       	j 80006226 <GetTaskState+0xba>
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
8000623e:	3b e0 00 90 	mov %d9,14
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006242:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006246:	8f ff 0f 31 	and %d3,%d15,255
8000624a:	ff 23 d8 ff 	jge.u %d3,2,800061fa <GetTaskState+0x8e>
8000624e:	3c cf       	j 800061ec <GetTaskState+0x80>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
80006250:	02 92       	mov %d2,%d9
80006252:	00 90       	ret 

80006254 <SetRelAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  increment,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
80006254:	40 ae       	mov.aa %a14,%sp
80006256:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006258:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000625a:	da 29       	mov %d15,41
8000625c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006260:	82 1f       	mov %d15,1
80006262:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
80006266:	91 00 00 28 	movh.a %a2,32768
8000626a:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
8000626e:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
80006270:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
80006272:	7f f4 3a 80 	jge.u %d4,%d15,800062e6 <SetRelAlarm+0x92>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
80006276:	91 00 00 28 	movh.a %a2,32768
8000627a:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
8000627e:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
80006282:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006286:	d4 25       	ld.a %a5,[%a2]
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
80006288:	99 52 04 00 	ld.a %a2,[%a5]4
8000628c:	99 24 04 00 	ld.a %a4,[%a2]4
        (increment > p_counter_db->info.maxallowedvalue) ||
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
80006290:	3b 80 00 80 	mov %d8,8
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((increment == 0U) ||
80006294:	df 05 29 00 	jeq %d5,0,800062e6 <SetRelAlarm+0x92>
        (increment > p_counter_db->info.maxallowedvalue) ||
80006298:	4c 41       	ld.w %d15,[%a4]4
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((increment == 0U) ||
8000629a:	3f 5f 26 80 	jlt.u %d15,%d5,800062e6 <SetRelAlarm+0x92>
        (increment > p_counter_db->info.maxallowedvalue) ||
8000629e:	76 69       	jz %d6,800062b0 <SetRelAlarm+0x5c>
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
800062a0:	19 43 0c 00 	ld.w %d3,[%a4]12
800062a4:	0b 36 30 21 	lt.u %d2,%d6,%d3
800062a8:	0b 6f a0 22 	or.lt.u %d2,%d15,%d6
800062ac:	df 02 1d 80 	jne %d2,0,800062e6 <SetRelAlarm+0x92>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800062b0:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800062b4:	8f f9 0f f1 	and %d15,%d9,255
800062b8:	ff 2f 09 80 	jge.u %d15,2,800062ca <SetRelAlarm+0x76>
    OsEE_icr icr_temp = icr;
800062bc:	02 9f       	mov %d15,%d9
800062be:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800062c2:	cd cf e2 0f 	mtcr $icr,%d15
800062c6:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_rel(p_counter_db, p_alarm_db, increment, cycle);
800062ca:	02 54       	mov %d4,%d5
800062cc:	02 65       	mov %d5,%d6
800062ce:	6d 00 09 0e 	call 80007ee0 <osEE_alarm_set_rel>
800062d2:	02 28       	mov %d8,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800062d4:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800062d8:	3e 95       	jeq %d15,%d9,800062e2 <SetRelAlarm+0x8e>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800062da:	cd c9 e2 0f 	mtcr $icr,%d9
800062de:	0d 00 c0 04 	isync 
      osEE_end_primitive(flags);
    }
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
800062e2:	df 08 23 00 	jeq %d8,0,80006328 <SetRelAlarm+0xd4>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800062e6:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800062ea:	8f f9 0f f1 	and %d15,%d9,255
800062ee:	ff 2f 09 80 	jge.u %d15,2,80006300 <SetRelAlarm+0xac>
    OsEE_icr icr_temp = icr;
800062f2:	02 9f       	mov %d15,%d9
800062f4:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800062f8:	cd cf e2 0f 	mtcr $icr,%d15
800062fc:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006300:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006304:	1e 4b       	jeq %d15,4,8000631a <SetRelAlarm+0xc6>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006306:	82 42       	mov %d2,4
80006308:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
8000630c:	e9 f8 12 00 	st.b [%a15]18,%d8
    ErrorHook(Error);
80006310:	02 84       	mov %d4,%d8
80006312:	6d ff 14 f0 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006316:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000631a:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000631e:	3e 95       	jeq %d15,%d9,80006328 <SetRelAlarm+0xd4>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006320:	cd c9 e2 0f 	mtcr $icr,%d9
80006324:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006328:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000632c:	5e 17       	jne %d15,1,8000633a <SetRelAlarm+0xe6>
    p_ccb->service_id            = service_id;
8000632e:	da 28       	mov %d15,40
80006330:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006334:	82 0f       	mov %d15,0
80006336:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetRelAlarm);

  return ev;
}
8000633a:	02 82       	mov %d2,%d8
8000633c:	00 90       	ret 

8000633e <SetAbsAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  start,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
8000633e:	40 ae       	mov.aa %a14,%sp
80006340:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006342:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006344:	da 2b       	mov %d15,43
80006346:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000634a:	82 1f       	mov %d15,1
8000634c:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
80006350:	91 00 00 28 	movh.a %a2,32768
80006354:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006358:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
8000635a:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000635c:	7f f4 38 80 	jge.u %d4,%d15,800063cc <SetAbsAlarm+0x8e>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
80006360:	91 00 00 28 	movh.a %a2,32768
80006364:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006368:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
8000636c:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006370:	d4 25       	ld.a %a5,[%a2]
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
80006372:	99 52 04 00 	ld.a %a2,[%a5]4
80006376:	99 24 04 00 	ld.a %a4,[%a2]4

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((start > p_counter_db->info.maxallowedvalue) ||
8000637a:	4c 41       	ld.w %d15,[%a4]4
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
8000637c:	3b 80 00 80 	mov %d8,8
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((start > p_counter_db->info.maxallowedvalue) ||
80006380:	3f 5f 26 80 	jlt.u %d15,%d5,800063cc <SetAbsAlarm+0x8e>
80006384:	76 69       	jz %d6,80006396 <SetAbsAlarm+0x58>
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
80006386:	19 43 0c 00 	ld.w %d3,[%a4]12
8000638a:	0b 36 30 21 	lt.u %d2,%d6,%d3
8000638e:	0b 6f a0 22 	or.lt.u %d2,%d15,%d6
80006392:	df 02 1d 80 	jne %d2,0,800063cc <SetAbsAlarm+0x8e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006396:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000639a:	8f f9 0f f1 	and %d15,%d9,255
8000639e:	ff 2f 09 80 	jge.u %d15,2,800063b0 <SetAbsAlarm+0x72>
    OsEE_icr icr_temp = icr;
800063a2:	02 9f       	mov %d15,%d9
800063a4:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800063a8:	cd cf e2 0f 	mtcr $icr,%d15
800063ac:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_abs(p_counter_db, p_alarm_db, start, cycle);
800063b0:	02 54       	mov %d4,%d5
800063b2:	02 65       	mov %d5,%d6
800063b4:	6d 00 db 0d 	call 80007f6a <osEE_alarm_set_abs>
800063b8:	02 28       	mov %d8,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800063ba:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800063be:	3e 95       	jeq %d15,%d9,800063c8 <SetAbsAlarm+0x8a>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800063c0:	cd c9 e2 0f 	mtcr $icr,%d9
800063c4:	0d 00 c0 04 	isync 
      osEE_end_primitive(flags);
    }
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
800063c8:	df 08 23 00 	jeq %d8,0,8000640e <SetAbsAlarm+0xd0>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800063cc:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800063d0:	8f f9 0f f1 	and %d15,%d9,255
800063d4:	ff 2f 09 80 	jge.u %d15,2,800063e6 <SetAbsAlarm+0xa8>
    OsEE_icr icr_temp = icr;
800063d8:	02 9f       	mov %d15,%d9
800063da:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800063de:	cd cf e2 0f 	mtcr $icr,%d15
800063e2:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
800063e6:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
800063ea:	1e 4b       	jeq %d15,4,80006400 <SetAbsAlarm+0xc2>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
800063ec:	82 42       	mov %d2,4
800063ee:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
800063f2:	e9 f8 12 00 	st.b [%a15]18,%d8
    ErrorHook(Error);
800063f6:	02 84       	mov %d4,%d8
800063f8:	6d ff a1 ef 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
800063fc:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006400:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006404:	3e 95       	jeq %d15,%d9,8000640e <SetAbsAlarm+0xd0>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006406:	cd c9 e2 0f 	mtcr $icr,%d9
8000640a:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000640e:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006412:	5e 17       	jne %d15,1,80006420 <SetAbsAlarm+0xe2>
    p_ccb->service_id            = service_id;
80006414:	da 2a       	mov %d15,42
80006416:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000641a:	82 0f       	mov %d15,0
8000641c:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetAbsAlarm);

  return ev;
}
80006420:	02 82       	mov %d2,%d8
80006422:	00 90       	ret 

80006424 <CancelAlarm>:
FUNC(StatusType, OS_CODE)
  CancelAlarm
(
  VAR(AlarmType, AUTOMATIC) AlarmID
)
{
80006424:	40 ae       	mov.aa %a14,%sp
80006426:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006428:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000642a:	da 2d       	mov %d15,45
8000642c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006430:	82 1f       	mov %d15,1
80006432:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
80006436:	91 00 00 28 	movh.a %a2,32768
8000643a:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
8000643e:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
80006440:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
80006442:	7f f4 24 80 	jge.u %d4,%d15,8000648a <CancelAlarm+0x66>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db  = (*p_kdb->p_alarm_ptr_array)[AlarmID];
80006446:	91 00 00 28 	movh.a %a2,32768
8000644a:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
8000644e:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
80006452:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006456:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006458:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000645c:	8f f9 0f f1 	and %d15,%d9,255
80006460:	ff 2f 09 80 	jge.u %d15,2,80006472 <CancelAlarm+0x4e>
    OsEE_icr icr_temp = icr;
80006464:	02 9f       	mov %d15,%d9
80006466:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000646a:	cd cf e2 0f 	mtcr $icr,%d15
8000646e:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_cancel(p_alarm_db);
80006472:	6d 00 b3 0d 	call 80007fd8 <osEE_alarm_cancel>
80006476:	02 28       	mov %d8,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006478:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000647c:	3e 95       	jeq %d15,%d9,80006486 <CancelAlarm+0x62>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000647e:	cd c9 e2 0f 	mtcr $icr,%d9
80006482:	0d 00 c0 04 	isync 

    osEE_end_primitive(flags);
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80006486:	df 08 23 00 	jeq %d8,0,800064cc <CancelAlarm+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000648a:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000648e:	8f f9 0f f1 	and %d15,%d9,255
80006492:	ff 2f 09 80 	jge.u %d15,2,800064a4 <CancelAlarm+0x80>
    OsEE_icr icr_temp = icr;
80006496:	02 9f       	mov %d15,%d9
80006498:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000649c:	cd cf e2 0f 	mtcr $icr,%d15
800064a0:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
800064a4:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
800064a8:	1e 4b       	jeq %d15,4,800064be <CancelAlarm+0x9a>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
800064aa:	82 42       	mov %d2,4
800064ac:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
800064b0:	e9 f8 12 00 	st.b [%a15]18,%d8
    ErrorHook(Error);
800064b4:	02 84       	mov %d4,%d8
800064b6:	6d ff 42 ef 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
800064ba:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800064be:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800064c2:	3e 95       	jeq %d15,%d9,800064cc <CancelAlarm+0xa8>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800064c4:	cd c9 e2 0f 	mtcr $icr,%d9
800064c8:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800064cc:	39 ff 23 00 	ld.bu %d15,[%a15]35
800064d0:	5e 17       	jne %d15,1,800064de <CancelAlarm+0xba>
    p_ccb->service_id            = service_id;
800064d2:	da 2c       	mov %d15,44
800064d4:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800064d8:	82 0f       	mov %d15,0
800064da:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_CancelAlarm);

  return ev;
}
800064de:	02 82       	mov %d2,%d8
800064e0:	00 90       	ret 

800064e2 <GetAlarm>:
  GetAlarm
(
  VAR(AlarmType, AUTOMATIC)   AlarmID,
  VAR(TickRefType, AUTOMATIC) Tick
)
{
800064e2:	40 ae       	mov.aa %a14,%sp
800064e4:	40 45       	mov.aa %a5,%a4
800064e6:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800064e8:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800064ea:	da 27       	mov %d15,39
800064ec:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800064f0:	82 1f       	mov %d15,1
800064f2:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
800064f6:	91 00 00 28 	movh.a %a2,32768
800064fa:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800064fe:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
80006500:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
80006502:	7f f4 26 80 	jge.u %d4,%d15,8000654e <GetAlarm+0x6c>
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
80006506:	bd 04 4f 00 	jz.a %a4,800065a4 <GetAlarm+0xc2>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000650a:	91 00 00 28 	movh.a %a2,32768
8000650e:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006512:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
80006516:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000651a:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000651c:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006520:	8f f9 0f f1 	and %d15,%d9,255
80006524:	ff 2f 09 80 	jge.u %d15,2,80006536 <GetAlarm+0x54>
    OsEE_icr icr_temp = icr;
80006528:	02 9f       	mov %d15,%d9
8000652a:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000652e:	cd cf e2 0f 	mtcr $icr,%d15
80006532:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_get(p_alarm_db, Tick);
80006536:	6d 00 81 0d 	call 80008038 <osEE_alarm_get>
8000653a:	02 28       	mov %d8,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000653c:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006540:	3e 95       	jeq %d15,%d9,8000654a <GetAlarm+0x68>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006542:	cd c9 e2 0f 	mtcr $icr,%d9
80006546:	0d 00 c0 04 	isync 

    osEE_end_primitive(flags);
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
8000654a:	df 08 23 00 	jeq %d8,0,80006590 <GetAlarm+0xae>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000654e:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006552:	8f f9 0f f1 	and %d15,%d9,255
80006556:	ff 2f 09 80 	jge.u %d15,2,80006568 <GetAlarm+0x86>
    OsEE_icr icr_temp = icr;
8000655a:	02 9f       	mov %d15,%d9
8000655c:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006560:	cd cf e2 0f 	mtcr $icr,%d15
80006564:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006568:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
8000656c:	1e 4b       	jeq %d15,4,80006582 <GetAlarm+0xa0>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
8000656e:	82 42       	mov %d2,4
80006570:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006574:	e9 f8 12 00 	st.b [%a15]18,%d8
    ErrorHook(Error);
80006578:	02 84       	mov %d4,%d8
8000657a:	6d ff e0 ee 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
8000657e:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006582:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006586:	3e 95       	jeq %d15,%d9,80006590 <GetAlarm+0xae>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006588:	cd c9 e2 0f 	mtcr $icr,%d9
8000658c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006590:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006594:	5e 1b       	jne %d15,1,800065aa <GetAlarm+0xc8>
    p_ccb->service_id            = service_id;
80006596:	da 26       	mov %d15,38
80006598:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000659c:	82 0f       	mov %d15,0
8000659e:	e9 ff 23 00 	st.b [%a15]35,%d15
800065a2:	3c 04       	j 800065aa <GetAlarm+0xc8>
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
    ev = E_OS_PARAM_POINTER;
800065a4:	3b e0 00 80 	mov %d8,14
800065a8:	3c d3       	j 8000654e <GetAlarm+0x6c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarm);

  return ev;
}
800065aa:	02 82       	mov %d2,%d8
800065ac:	00 90       	ret 

800065ae <GetAlarmBase>:
  GetAlarmBase
(
  VAR(AlarmType, AUTOMATIC)         AlarmID,
  VAR(AlarmBaseRefType, AUTOMATIC)  Info
)
{
800065ae:	40 ae       	mov.aa %a14,%sp
800065b0:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800065b2:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800065b4:	da 25       	mov %d15,37
800065b6:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800065ba:	82 1f       	mov %d15,1
800065bc:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
800065c0:	91 00 00 28 	movh.a %a2,32768
800065c4:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800065c8:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
800065ca:	82 39       	mov %d9,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
800065cc:	7f f4 47 80 	jge.u %d4,%d15,8000665a <GetAlarmBase+0xac>
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
800065d0:	bd 04 43 00 	jz.a %a4,80006656 <GetAlarmBase+0xa8>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
800065d4:	91 00 00 28 	movh.a %a2,32768
800065d8:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800065dc:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
800065e0:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_trigger_db;
800065e4:	d4 22       	ld.a %a2,[%a2]
    CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
      p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = p_trigger_db->p_counter_db;
800065e6:	99 22 04 00 	ld.a %a2,[%a2]4
800065ea:	19 22 04 00 	ld.w %d2,[%a2]4

    *Info = p_counter_db->info;
800065ee:	60 22       	mov.a %a2,%d2
800065f0:	b0 42       	add.a %a2,4
800065f2:	09 22 48 01 	ld.d %e2,[%a2+]8
800065f6:	89 42 48 01 	st.d [%a4+]8,%e2
800065fa:	44 22       	ld.w %d2,[%a2+]
800065fc:	64 42       	st.w [%a4+],%d2

    ev = E_OK;
800065fe:	82 09       	mov %d9,0
80006600:	3c 21       	j 80006642 <GetAlarmBase+0x94>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
80006602:	02 f2       	mov %d2,%d15
80006604:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006608:	cd c2 e2 0f 	mtcr $icr,%d2
8000660c:	0d 00 c0 04 	isync 
80006610:	40 92       	mov.aa %a2,%a9
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_set_service_id(p_ccb, OSServiceId_GetAlarmBase);
    osEE_set_api_param1_num_param(p_ccb, AlarmID);
    osEE_set_api_param2_p_param(p_ccb, Info);
    osEE_call_error_hook(osEE_get_curr_core()->p_ccb, ev);
80006612:	99 2c 0c 00 	ld.a %a12,[%a2]12 <8000000c <BootModeHeader0+0xc>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006616:	39 c8 14 00 	ld.bu %d8,[%a12]20 <8000000c <BootModeHeader0+0xc>>
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
8000661a:	df 48 0c 00 	jeq %d8,4,80006632 <GetAlarmBase+0x84>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
8000661e:	82 42       	mov %d2,4
80006620:	e9 c2 14 00 	st.b [%a12]20,%d2
    p_ccb->last_error = Error;
80006624:	e9 c9 12 00 	st.b [%a12]18,%d9
    ErrorHook(Error);
80006628:	02 94       	mov %d4,%d9
8000662a:	6d ff 88 ee 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
8000662e:	e9 c8 14 00 	st.b [%a12]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006632:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006636:	5f f3 06 00 	jeq %d3,%d15,80006642 <GetAlarmBase+0x94>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000663a:	cd cf e2 0f 	mtcr $icr,%d15
8000663e:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006642:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006646:	de 11       	jne %d15,1,80006668 <GetAlarmBase+0xba>
    p_ccb->service_id            = service_id;
80006648:	da 24       	mov %d15,36
8000664a:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000664e:	82 0f       	mov %d15,0
80006650:	e9 ff 23 00 	st.b [%a15]35,%d15
80006654:	3c 0a       	j 80006668 <GetAlarmBase+0xba>
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
    ev = E_OS_PARAM_POINTER;
80006656:	3b e0 00 90 	mov %d9,14
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000665a:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000665e:	8f ff 0f 31 	and %d3,%d15,255
80006662:	ff 23 d7 ff 	jge.u %d3,2,80006610 <GetAlarmBase+0x62>
80006666:	3c ce       	j 80006602 <GetAlarmBase+0x54>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarmBase);

  return ev;
}
80006668:	02 92       	mov %d2,%d9
8000666a:	00 90       	ret 

8000666c <WaitEvent>:
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000666c:	40 ae       	mov.aa %a14,%sp
8000666e:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
80006670:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80006672:	c8 0c       	ld.a %a12,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80006674:	99 cd 0c 00 	ld.a %a13,[%a12]12 <0 <NULL>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006678:	da 23       	mov %d15,35
8000667a:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000667e:	82 1f       	mov %d15,1
80006680:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
80006684:	4c f8       	ld.w %d15,[%a15]32
80006686:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
8000668a:	3b c0 00 90 	mov %d9,12
   *    context AND is currently not inside a Category 1 ISR the Operating
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
8000668e:	ee 5b       	jnz %d15,80006744 <WaitEvent+0xd8>
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80006690:	39 cf 14 00 	ld.bu %d15,[%a12]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80006694:	82 29       	mov %d9,2
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80006696:	ff 2f 57 80 	jge.u %d15,2,80006744 <WaitEvent+0xd8>
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_ACCESS;
8000669a:	82 19       	mov %d9,1
#else
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
8000669c:	df 1f 54 80 	jne %d15,1,80006744 <WaitEvent+0xd8>
    ev = E_OS_ACCESS;
  } else
#endif /* OSEE_HAS_CHECKS */
  /* Check if we have to wait */
  if ((p_curr_tcb->event_mask & Mask) == 0U) {
800066a0:	4c d2       	ld.w %d15,[%a13]8
800066a2:	26 4f       	and %d15,%d4
800066a4:	ee 4e       	jnz %d15,80006740 <WaitEvent+0xd4>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800066a6:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800066aa:	8f f8 0f f1 	and %d15,%d8,255
800066ae:	ff 2f 09 80 	jge.u %d15,2,800066c0 <WaitEvent+0x54>
    OsEE_icr icr_temp = icr;
800066b2:	02 8f       	mov %d15,%d8
800066b4:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800066b8:	cd cf e2 0f 	mtcr $icr,%d15
800066bc:	0d 00 c0 04 	isync 
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();

    /* Set the waiting mask */
    p_curr_tcb->wait_mask = Mask;
800066c0:	59 d4 04 00 	st.w [%a13]4,%d4

    p_to = osEE_scheduler_task_block_current(osEE_get_kernel(),
800066c4:	91 00 00 48 	movh.a %a4,32768
800066c8:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
800066cc:	d9 d5 0c 00 	lea %a5,[%a13]12 <80000028 <osEE_kdb_var>>
800066d0:	6d 00 de 08 	call 8000788c <osEE_scheduler_task_block_current>
              &p_curr_tcb->p_own_sn);

    osEE_change_context_from_running(p_curr, p_to);
800066d4:	40 c4       	mov.aa %a4,%a12
800066d6:	40 25       	mov.aa %a5,%a2
800066d8:	6d 00 08 0e 	call 800082e8 <osEE_change_context_from_running>

    /* Reset the waiting mask */
    p_curr_tcb->wait_mask = 0U;
800066dc:	82 0f       	mov %d15,0
800066de:	6c d1       	st.w [%a13]4,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800066e0:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800066e4:	5f 8f 2e 00 	jeq %d15,%d8,80006740 <WaitEvent+0xd4>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800066e8:	cd c8 e2 0f 	mtcr $icr,%d8
800066ec:	0d 00 c0 04 	isync 
800066f0:	3c 28       	j 80006740 <WaitEvent+0xd4>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
800066f2:	02 f2       	mov %d2,%d15
800066f4:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800066f8:	cd c2 e2 0f 	mtcr $icr,%d2
800066fc:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006700:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006704:	df 48 0c 00 	jeq %d8,4,8000671c <WaitEvent+0xb0>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006708:	82 42       	mov %d2,4
8000670a:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
8000670e:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80006712:	02 94       	mov %d4,%d9
80006714:	6d ff 13 ee 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006718:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000671c:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006720:	5f f3 06 00 	jeq %d3,%d15,8000672c <WaitEvent+0xc0>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006724:	cd cf e2 0f 	mtcr $icr,%d15
80006728:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000672c:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006730:	de 11       	jne %d15,1,80006752 <WaitEvent+0xe6>
    p_ccb->service_id            = service_id;
80006732:	da 22       	mov %d15,34
80006734:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006738:	82 0f       	mov %d15,0
8000673a:	e9 ff 23 00 	st.b [%a15]35,%d15
8000673e:	3c 0a       	j 80006752 <WaitEvent+0xe6>
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80006740:	82 09       	mov %d9,0
80006742:	3c f5       	j 8000672c <WaitEvent+0xc0>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006744:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006748:	8f ff 0f 31 	and %d3,%d15,255
8000674c:	ff 23 da ff 	jge.u %d3,2,80006700 <WaitEvent+0x94>
80006750:	3c d1       	j 800066f2 <WaitEvent+0x86>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
80006752:	02 92       	mov %d2,%d9
80006754:	00 90       	ret 

80006756 <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80006756:	40 ae       	mov.aa %a14,%sp
80006758:	20 08       	sub.a %sp,8
8000675a:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
#if (defined(OSEE_HAS_CHECKS)) || (defined(OSEE_HAS_ERRORHOOK)) ||\
    (defined(OSEE_HAS_ORTI))
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb  = p_cdb->p_ccb;
8000675c:	c8 3f       	ld.a %a15,[%a15]12
#if (defined(OSEE_HAS_CHECKS))
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr = p_ccb->p_curr;
8000675e:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006760:	da 1d       	mov %d15,29
80006762:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006766:	82 1f       	mov %d15,1
80006768:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000676c:	4c f8       	ld.w %d15,[%a15]32
8000676e:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
/* SetEvent is callable by Task and ISR2 */
  if (osEE_check_disableint(p_ccb)) {
80006772:	6e 05       	jz %d15,8000677c <SetEvent+0x26>
    ev = E_OS_DISABLEDINT;
80006774:	da 0c       	mov %d15,12
80006776:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000677a:	3c 48       	j 8000680a <SetEvent+0xb4>
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)
8000677c:	39 2f 14 00 	ld.bu %d15,[%a2]20
80006780:	bf 3f 06 80 	jlt.u %d15,3,8000678c <SetEvent+0x36>
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80006784:	82 2f       	mov %d15,2
80006786:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000678a:	3c 40       	j 8000680a <SetEvent+0xb4>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000678c:	91 00 00 28 	movh.a %a2,32768
80006790:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006794:	4c 24       	ld.w %d15,[%a2]16
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80006796:	3f f4 06 80 	jlt.u %d4,%d15,800067a2 <SetEvent+0x4c>
    ev = E_OS_ID;
8000679a:	82 3f       	mov %d15,3
8000679c:	e9 ef ff ff 	st.b [%a14]-1,%d15
800067a0:	3c 35       	j 8000680a <SetEvent+0xb4>
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
800067a2:	91 00 00 28 	movh.a %a2,32768
800067a6:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800067aa:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
800067ae:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
800067b2:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800067b4:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800067b8:	8f f8 0f f1 	and %d15,%d8,255
800067bc:	ff 2f 09 80 	jge.u %d15,2,800067ce <SetEvent+0x78>
    OsEE_icr icr_temp = icr;
800067c0:	02 8f       	mov %d15,%d8
800067c2:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800067c6:	cd cf e2 0f 	mtcr $icr,%d15
800067ca:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
800067ce:	02 54       	mov %d4,%d5
800067d0:	d9 e5 ff ff 	lea %a5,[%a14]-1
800067d4:	6d 00 56 07 	call 80007680 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
800067d8:	bc 2f       	jz.a %a2,800067f6 <SetEvent+0xa0>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
800067da:	91 00 00 48 	movh.a %a4,32768
800067de:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
800067e2:	40 25       	mov.aa %a5,%a2
800067e4:	6d 00 75 08 	call 800078ce <osEE_scheduler_task_unblocked>
800067e8:	76 27       	jz %d2,800067f6 <SetEvent+0xa0>
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
800067ea:	91 00 00 48 	movh.a %a4,32768
800067ee:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
800067f2:	6d 00 0f 09 	call 80007a10 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800067f6:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800067fa:	3e 85       	jeq %d15,%d8,80006804 <SetEvent+0xae>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800067fc:	cd c8 e2 0f 	mtcr $icr,%d8
80006800:	0d 00 c0 04 	isync 
    }
    osEE_end_primitive(flags);
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80006804:	39 ef ff ff 	ld.bu %d15,[%a14]-1
80006808:	6e 23       	jz %d15,8000684e <SetEvent+0xf8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000680a:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000680e:	8f f8 0f f1 	and %d15,%d8,255
80006812:	ff 2f 09 80 	jge.u %d15,2,80006824 <SetEvent+0xce>
    OsEE_icr icr_temp = icr;
80006816:	02 8f       	mov %d15,%d8
80006818:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000681c:	cd cf e2 0f 	mtcr $icr,%d15
80006820:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_set_service_id(p_ccb, OSServiceId_SetEvent);
    osEE_set_api_param1_num_param(p_ccb, TaskID);
    osEE_set_api_param2_num_param(p_ccb, Mask);
    osEE_call_error_hook(p_ccb, ev);
80006824:	39 e4 ff ff 	ld.bu %d4,[%a14]-1
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006828:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
8000682c:	1e 4a       	jeq %d15,4,80006840 <SetEvent+0xea>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
8000682e:	82 42       	mov %d2,4
80006830:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006834:	e9 f4 12 00 	st.b [%a15]18,%d4
    ErrorHook(Error);
80006838:	6d ff 81 ed 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
8000683c:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006840:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006844:	3e 85       	jeq %d15,%d8,8000684e <SetEvent+0xf8>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006846:	cd c8 e2 0f 	mtcr $icr,%d8
8000684a:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000684e:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006852:	5e 17       	jne %d15,1,80006860 <SetEvent+0x10a>
    p_ccb->service_id            = service_id;
80006854:	da 1c       	mov %d15,28
80006856:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000685a:	82 0f       	mov %d15,0
8000685c:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80006860:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80006864:	00 90       	ret 

80006866 <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
80006866:	40 ae       	mov.aa %a14,%sp
80006868:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
#if (defined(OSEE_HAS_CHECKS)) || (defined(OSEE_HAS_ERRORHOOK)) ||\
    (defined(OSEE_HAS_ORTI))
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
8000686a:	c8 3f       	ld.a %a15,[%a15]12
  CONST(OsEE_os_context, AUTOMATIC)
    os_context  = p_ccb->os_context;
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#if (defined(OSEE_HAS_CHECKS))
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000686c:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000686e:	da 21       	mov %d15,33
80006870:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006874:	82 1f       	mov %d15,1
80006876:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000687a:	4c f8       	ld.w %d15,[%a15]32
8000687c:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
80006880:	3b c0 00 90 	mov %d9,12
   *    context AND is currently not inside a Category 1 ISR the Operating
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
80006884:	ee 50       	jnz %d15,80006924 <GetEvent+0xbe>
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)
80006886:	39 2f 14 00 	ld.bu %d15,[%a2]20
        (os_context != OSEE_PRETASKHOOK_CTX) &&
        (os_context != OSEE_POSTTASKHOOK_CTX))
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
8000688a:	82 29       	mov %d9,2
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)
8000688c:	ff 3f 4c 80 	jge.u %d15,3,80006924 <GetEvent+0xbe>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80006890:	91 00 00 28 	movh.a %a2,32768
80006894:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006898:	4c 24       	ld.w %d15,[%a2]16
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000689a:	82 39       	mov %d9,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000689c:	7f f4 44 80 	jge.u %d4,%d15,80006924 <GetEvent+0xbe>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
800068a0:	91 00 00 28 	movh.a %a2,32768
800068a4:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800068a8:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
800068ac:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
800068b0:	d4 22       	ld.a %a2,[%a2]
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
800068b2:	99 23 0c 00 	ld.a %a3,[%a2]12
    /* XXX: We will accept an harmless race condition here for TASKs that want
     *      read events of TASKs allocated in other cores */
#if (defined(OSEE_HAS_CHECKS))
    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
800068b6:	39 2f 14 00 	ld.bu %d15,[%a2]20
      ev = E_OS_ACCESS;
800068ba:	82 19       	mov %d9,1
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
    /* XXX: We will accept an harmless race condition here for TASKs that want
     *      read events of TASKs allocated in other cores */
#if (defined(OSEE_HAS_CHECKS))
    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
800068bc:	df 1f 34 80 	jne %d15,1,80006924 <GetEvent+0xbe>
      ev = E_OS_ACCESS;
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
800068c0:	0c 32       	ld.bu %d15,[%a3]2
      ev = E_OS_STATE;
800068c2:	82 79       	mov %d9,7
     *      read events of TASKs allocated in other cores */
#if (defined(OSEE_HAS_CHECKS))
    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
      ev = E_OS_ACCESS;
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
800068c4:	6e 30       	jz %d15,80006924 <GetEvent+0xbe>
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
800068c6:	bd 04 2d 00 	jz.a %a4,80006920 <GetEvent+0xba>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      (*Event) = p_tcb_event->event_mask;
800068ca:	4c 32       	ld.w %d15,[%a3]8
800068cc:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
800068ce:	82 09       	mov %d9,0
800068d0:	3c 1e       	j 8000690c <GetEvent+0xa6>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
800068d2:	02 f2       	mov %d2,%d15
800068d4:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800068d8:	cd c2 e2 0f 	mtcr $icr,%d2
800068dc:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
800068e0:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
800068e4:	df 48 0c 00 	jeq %d8,4,800068fc <GetEvent+0x96>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
800068e8:	82 42       	mov %d2,4
800068ea:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
800068ee:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
800068f2:	02 94       	mov %d4,%d9
800068f4:	6d ff 23 ed 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
800068f8:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800068fc:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006900:	5f f3 06 00 	jeq %d3,%d15,8000690c <GetEvent+0xa6>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006904:	cd cf e2 0f 	mtcr $icr,%d15
80006908:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000690c:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006910:	de 11       	jne %d15,1,80006932 <GetEvent+0xcc>
    p_ccb->service_id            = service_id;
80006912:	da 20       	mov %d15,32
80006914:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006918:	82 0f       	mov %d15,0
8000691a:	e9 ff 23 00 	st.b [%a15]35,%d15
8000691e:	3c 0a       	j 80006932 <GetEvent+0xcc>
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
80006920:	3b e0 00 90 	mov %d9,14
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006924:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006928:	8f ff 0f 31 	and %d3,%d15,255
8000692c:	ff 23 da ff 	jge.u %d3,2,800068e0 <GetEvent+0x7a>
80006930:	3c d1       	j 800068d2 <GetEvent+0x6c>
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80006932:	02 92       	mov %d2,%d9
80006934:	00 90       	ret 

80006936 <ClearEvent>:
FUNC(StatusType, OS_CODE)
  ClearEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80006936:	40 ae       	mov.aa %a14,%sp
80006938:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
8000693a:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000693c:	c8 02       	ld.a %a2,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000693e:	99 23 0c 00 	ld.a %a3,[%a2]12 <0 <NULL>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006942:	da 1f       	mov %d15,31
80006944:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006948:	82 1f       	mov %d15,1
8000694a:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000694e:	4c f8       	ld.w %d15,[%a15]32
80006950:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
80006954:	3b c0 00 90 	mov %d9,12
   *    context AND is currently not inside a Category 1 ISR the Operating
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
80006958:	ee 37       	jnz %d15,800069c6 <ClearEvent+0x90>
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)
8000695a:	39 2f 14 00 	ld.bu %d15,[%a2]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
      || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
8000695e:	82 29       	mov %d9,2
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)
80006960:	ff 2f 33 80 	jge.u %d15,2,800069c6 <ClearEvent+0x90>
  )
  {
    ev = E_OS_CALLEVEL;
  } else
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_ACCESS;
80006964:	82 19       	mov %d9,1
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
  } else
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
80006966:	df 1f 30 80 	jne %d15,1,800069c6 <ClearEvent+0x90>
    ev = E_OS_ACCESS;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* clear the event */
    p_curr_tcb->event_mask &= ~Mask;
8000696a:	4c 32       	ld.w %d15,[%a3]8
8000696c:	0f 4f e0 40 	andn %d4,%d15,%d4
80006970:	59 34 08 00 	st.w [%a3]8,%d4

    ev = E_OK;
80006974:	82 09       	mov %d9,0
80006976:	3c 1e       	j 800069b2 <ClearEvent+0x7c>
    OsEE_icr icr_temp = icr;
80006978:	02 f2       	mov %d2,%d15
8000697a:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000697e:	cd c2 e2 0f 	mtcr $icr,%d2
80006982:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006986:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
8000698a:	df 48 0c 00 	jeq %d8,4,800069a2 <ClearEvent+0x6c>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
8000698e:	82 42       	mov %d2,4
80006990:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006994:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80006998:	02 94       	mov %d4,%d9
8000699a:	6d ff d0 ec 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
8000699e:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800069a2:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800069a6:	5f f3 06 00 	jeq %d3,%d15,800069b2 <ClearEvent+0x7c>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800069aa:	cd cf e2 0f 	mtcr $icr,%d15
800069ae:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800069b2:	39 ff 23 00 	ld.bu %d15,[%a15]35
800069b6:	5e 1f       	jne %d15,1,800069d4 <ClearEvent+0x9e>
    p_ccb->service_id            = service_id;
800069b8:	da 1e       	mov %d15,30
800069ba:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800069be:	82 0f       	mov %d15,0
800069c0:	e9 ff 23 00 	st.b [%a15]35,%d15
800069c4:	3c 08       	j 800069d4 <ClearEvent+0x9e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800069c6:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800069ca:	8f ff 0f 31 	and %d3,%d15,255
800069ce:	ff 23 dc ff 	jge.u %d3,2,80006986 <ClearEvent+0x50>
800069d2:	3c d3       	j 80006978 <ClearEvent+0x42>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
800069d4:	02 92       	mov %d2,%d9
800069d6:	00 90       	ret 

800069d8 <GetCounterValue>:
  GetCounterValue
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value
)
{
800069d8:	40 ae       	mov.aa %a14,%sp
800069da:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800069dc:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800069de:	da 31       	mov %d15,49
800069e0:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800069e4:	82 1f       	mov %d15,1
800069e6:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (counter_id < p_kdb->p_kcb->free_counter_index);
#else
  return (counter_id < p_kdb->counter_array_size);
800069ea:	91 00 00 28 	movh.a %a2,32768
800069ee:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800069f2:	4c 26       	ld.w %d15,[%a2]24
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
800069f4:	82 39       	mov %d9,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
800069f6:	7f f4 45 80 	jge.u %d4,%d15,80006a80 <GetCounterValue+0xa8>
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
800069fa:	bd 04 41 00 	jz.a %a4,80006a7c <GetCounterValue+0xa4>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
800069fe:	91 00 00 28 	movh.a %a2,32768
80006a02:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006a06:	99 22 14 00 	ld.a %a2,[%a2]20 <80000014 <BootModeHeader0+0x14>>
80006a0a:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006a0e:	d4 22       	ld.a %a2,[%a2]
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80006a10:	4d c0 e1 2f 	mfcr %d2,$core_id
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
80006a14:	39 2f 10 00 	ld.bu %d15,[%a2]16
80006a18:	8f f2 0f 21 	and %d2,%d2,255
      ev = E_OS_CORE;
80006a1c:	3b 70 01 90 	mov %d9,23
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
80006a20:	5f 2f 30 80 	jne %d15,%d2,80006a80 <GetCounterValue+0xa8>
    of hardware timers (which drive counters) in such that the lowest value is
    zero and consecutive reads return an increasing count value until the timer
    wraps at its modulus. (SRS_Frt_00030, SRS_Frt_00031) */
/* EG  TODO: Add support for HARDWARE counters */

      (*Value) = p_counter_db->p_counter_cb->value;
80006a24:	d4 22       	ld.a %a2,[%a2]
80006a26:	4c 21       	ld.w %d15,[%a2]4
80006a28:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
80006a2a:	82 09       	mov %d9,0
80006a2c:	3c 1e       	j 80006a68 <GetCounterValue+0x90>
    OsEE_icr icr_temp = icr;
80006a2e:	02 f2       	mov %d2,%d15
80006a30:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006a34:	cd c2 e2 0f 	mtcr $icr,%d2
80006a38:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006a3c:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006a40:	df 48 0c 00 	jeq %d8,4,80006a58 <GetCounterValue+0x80>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006a44:	82 42       	mov %d2,4
80006a46:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006a4a:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80006a4e:	02 94       	mov %d4,%d9
80006a50:	6d ff 75 ec 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006a54:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006a58:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006a5c:	5f f3 06 00 	jeq %d3,%d15,80006a68 <GetCounterValue+0x90>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006a60:	cd cf e2 0f 	mtcr $icr,%d15
80006a64:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006a68:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006a6c:	de 11       	jne %d15,1,80006a8e <GetCounterValue+0xb6>
    p_ccb->service_id            = service_id;
80006a6e:	da 30       	mov %d15,48
80006a70:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006a74:	82 0f       	mov %d15,0
80006a76:	e9 ff 23 00 	st.b [%a15]35,%d15
80006a7a:	3c 0a       	j 80006a8e <GetCounterValue+0xb6>
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
    ev = E_OS_PARAM_POINTER;
80006a7c:	3b e0 00 90 	mov %d9,14
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006a80:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006a84:	8f ff 0f 31 	and %d3,%d15,255
80006a88:	ff 23 da ff 	jge.u %d3,2,80006a3c <GetCounterValue+0x64>
80006a8c:	3c d1       	j 80006a2e <GetCounterValue+0x56>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetCounterValue);

  return ev;
}
80006a8e:	02 92       	mov %d2,%d9
80006a90:	00 90       	ret 

80006a92 <GetElapsedValue>:
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value,
  VAR(TickRefType, AUTOMATIC) ElapsedValue
)
{
80006a92:	40 ae       	mov.aa %a14,%sp
80006a94:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006a96:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006a98:	da 33       	mov %d15,51
80006a9a:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006a9e:	82 1f       	mov %d15,1
80006aa0:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (counter_id < p_kdb->p_kcb->free_counter_index);
#else
  return (counter_id < p_kdb->counter_array_size);
80006aa4:	91 00 00 28 	movh.a %a2,32768
80006aa8:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006aac:	4c 26       	ld.w %d15,[%a2]24
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
80006aae:	82 39       	mov %d9,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
80006ab0:	7f f4 5a 80 	jge.u %d4,%d15,80006b64 <GetElapsedValue+0xd2>
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
80006ab4:	80 42       	mov.d %d2,%a4
80006ab6:	80 53       	mov.d %d3,%a5
80006ab8:	ba 02       	eq %d15,%d2,0
80006aba:	8b 03 e0 f4 	or.eq %d15,%d3,0
    ev = E_OS_PARAM_POINTER;
80006abe:	3b e0 00 90 	mov %d9,14
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
80006ac2:	ee 51       	jnz %d15,80006b64 <GetElapsedValue+0xd2>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
80006ac4:	91 00 00 28 	movh.a %a2,32768
80006ac8:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006acc:	99 22 14 00 	ld.a %a2,[%a2]20 <80000014 <BootModeHeader0+0x14>>
80006ad0:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006ad4:	d4 22       	ld.a %a2,[%a2]
    CONST(TickType, AUTOMATIC)
      local_value = (*Value);
80006ad6:	54 43       	ld.w %d3,[%a4]
80006ad8:	4d c0 e1 2f 	mfcr %d2,$core_id
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
80006adc:	39 2f 10 00 	ld.bu %d15,[%a2]16
80006ae0:	8f f2 0f 21 	and %d2,%d2,255
      ev = E_OS_CORE;
80006ae4:	3b 70 01 90 	mov %d9,23
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
80006ae8:	5f 2f 3e 80 	jne %d15,%d2,80006b64 <GetElapsedValue+0xd2>
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_CHECKS))
/* [SWS_Os_00391] If the <Value> in a call of GetElapsedValue() is larger than
    the max allowed value of the <CounterID>, GetElapsedValue() shall return
    E_OS_VALUE. */
    if (local_value > p_counter_db->info.maxallowedvalue) {
80006aec:	4c 21       	ld.w %d15,[%a2]4
      ev = E_OS_VALUE;
80006aee:	3b 80 00 90 	mov %d9,8
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_CHECKS))
/* [SWS_Os_00391] If the <Value> in a call of GetElapsedValue() is larger than
    the max allowed value of the <CounterID>, GetElapsedValue() shall return
    E_OS_VALUE. */
    if (local_value > p_counter_db->info.maxallowedvalue) {
80006af2:	3f 3f 39 80 	jlt.u %d15,%d3,80006b64 <GetElapsedValue+0xd2>
/* [SWS_Os_00382] If the input parameters in a call of GetElapsedValue()
     are valid, GetElapsedValue() shall return the number of elapsed ticks
     since the given <Value> value via <ElapsedValue> and shall return
     E_OK. (SRS_Frt_00034) */
      CONST(TickType, AUTOMATIC)
        local_curr_value = p_counter_db->p_counter_cb->value;
80006af6:	d4 22       	ld.a %a2,[%a2]
80006af8:	19 22 04 00 	ld.w %d2,[%a2]4
80006afc:	42 2f       	add %d15,%d2
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
        /* Timer did not pass the <value> yet */
        (local_curr_value - local_value):
80006afe:	c2 1f       	add %d15,1
80006b00:	0b 32 80 40 	sub %d4,%d2,%d3
80006b04:	a2 3f       	sub %d15,%d3
80006b06:	0b 32 30 31 	lt.u %d3,%d2,%d3
80006b0a:	2b 4f 40 f3 	sel %d15,%d3,%d15,%d4

/* [SWS_Os_00533] Caveats of GetElapsedValue(): If the timer already passed the
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
80006b0e:	6c 50       	st.w [%a5]0,%d15
        ((p_counter_db->info.maxallowedvalue -
          (local_value - local_curr_value)) + 1U);

/* [SWS_Os_00460] GetElapsedValue() shall return the current tick value of the
    counter in the <Value> parameter. */
      (*Value) = local_curr_value;
80006b10:	74 42       	st.w [%a4],%d2

      ev = E_OK;
80006b12:	82 09       	mov %d9,0
80006b14:	3c 1e       	j 80006b50 <GetElapsedValue+0xbe>
    OsEE_icr icr_temp = icr;
80006b16:	02 f2       	mov %d2,%d15
80006b18:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006b1c:	cd c2 e2 0f 	mtcr $icr,%d2
80006b20:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006b24:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006b28:	df 48 0c 00 	jeq %d8,4,80006b40 <GetElapsedValue+0xae>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006b2c:	82 42       	mov %d2,4
80006b2e:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006b32:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80006b36:	02 94       	mov %d4,%d9
80006b38:	6d ff 01 ec 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006b3c:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006b40:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006b44:	5f f3 06 00 	jeq %d3,%d15,80006b50 <GetElapsedValue+0xbe>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006b48:	cd cf e2 0f 	mtcr $icr,%d15
80006b4c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006b50:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006b54:	5e 1f       	jne %d15,1,80006b72 <GetElapsedValue+0xe0>
    p_ccb->service_id            = service_id;
80006b56:	da 32       	mov %d15,50
80006b58:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006b5c:	82 0f       	mov %d15,0
80006b5e:	e9 ff 23 00 	st.b [%a15]35,%d15
80006b62:	3c 08       	j 80006b72 <GetElapsedValue+0xe0>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006b64:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006b68:	8f ff 0f 31 	and %d3,%d15,255
80006b6c:	ff 23 dc ff 	jge.u %d3,2,80006b24 <GetElapsedValue+0x92>
80006b70:	3c d3       	j 80006b16 <GetElapsedValue+0x84>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetElapsedValue);

  return ev;
}
80006b72:	02 92       	mov %d2,%d9
80006b74:	00 90       	ret 

80006b76 <IncrementCounter>:
FUNC(StatusType, OS_CODE)
  IncrementCounter
(
  VAR(CounterType, AUTOMATIC) CounterID
)
{
80006b76:	40 ae       	mov.aa %a14,%sp
80006b78:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006b7a:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006b7c:	da 2f       	mov %d15,47
80006b7e:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006b82:	82 1f       	mov %d15,1
80006b84:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (counter_id < p_kdb->p_kcb->free_counter_index);
#else
  return (counter_id < p_kdb->counter_array_size);
80006b88:	91 00 00 28 	movh.a %a2,32768
80006b8c:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006b90:	4c 26       	ld.w %d15,[%a2]24
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
80006b92:	82 39       	mov %d9,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
80006b94:	7f f4 64 80 	jge.u %d4,%d15,80006c5c <IncrementCounter+0xe6>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
80006b98:	91 00 00 28 	movh.a %a2,32768
80006b9c:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006ba0:	99 22 14 00 	ld.a %a2,[%a2]20 <80000014 <BootModeHeader0+0x14>>
80006ba4:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006ba8:	d4 24       	ld.a %a4,[%a2]
80006baa:	4d c0 e1 2f 	mfcr %d2,$core_id
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) current_cpu_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != current_cpu_id) {
80006bae:	39 4f 10 00 	ld.bu %d15,[%a4]16
80006bb2:	8f f2 0f 21 	and %d2,%d2,255
      ev = E_OS_CORE;
80006bb6:	3b 70 01 90 	mov %d9,23
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) current_cpu_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != current_cpu_id) {
80006bba:	5f 2f 51 80 	jne %d15,%d2,80006c5c <IncrementCounter+0xe6>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006bbe:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006bc2:	8f f8 0f f1 	and %d15,%d8,255
80006bc6:	ff 2f 09 80 	jge.u %d15,2,80006bd8 <IncrementCounter+0x62>
    OsEE_icr icr_temp = icr;
80006bca:	02 8f       	mov %d15,%d8
80006bcc:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006bd0:	cd cf e2 0f 	mtcr $icr,%d15
80006bd4:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();

/* N.B. Multi-core critical sections are handled inside
   TODO: Pass flags to osEE_counter_increment so it could re-enable
         interrupts/lower IPL outside critical sections. */
      osEE_counter_increment(p_counter_db);
80006bd8:	6d 00 c2 07 	call 80007b5c <osEE_counter_increment>
80006bdc:	40 92       	mov.aa %a2,%a9
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80006bde:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>

/* [SWS_Os_00529] Caveats of IncrementCounter(): If called from a task,
    rescheduling may take place. */
      if (osEE_get_curr_task()->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80006be2:	d4 22       	ld.a %a2,[%a2]
80006be4:	39 2f 14 00 	ld.bu %d15,[%a2]20 <8000000c <BootModeHeader0+0xc>>
80006be8:	ff 2f 08 80 	jge.u %d15,2,80006bf8 <IncrementCounter+0x82>
        (void)osEE_scheduler_task_preemption_point(p_kdb);
80006bec:	91 00 00 48 	movh.a %a4,32768
80006bf0:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80006bf4:	6d 00 0e 07 	call 80007a10 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006bf8:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006bfc:	5f 8f 2e 00 	jeq %d15,%d8,80006c58 <IncrementCounter+0xe2>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006c00:	cd c8 e2 0f 	mtcr $icr,%d8
80006c04:	0d 00 c0 04 	isync 
80006c08:	3c 28       	j 80006c58 <IncrementCounter+0xe2>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
80006c0a:	02 f2       	mov %d2,%d15
80006c0c:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006c10:	cd c2 e2 0f 	mtcr $icr,%d2
80006c14:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006c18:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006c1c:	df 48 0c 00 	jeq %d8,4,80006c34 <IncrementCounter+0xbe>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006c20:	82 42       	mov %d2,4
80006c22:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006c26:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80006c2a:	02 94       	mov %d4,%d9
80006c2c:	6d ff 87 eb 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006c30:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006c34:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006c38:	5f f3 06 00 	jeq %d3,%d15,80006c44 <IncrementCounter+0xce>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006c3c:	cd cf e2 0f 	mtcr $icr,%d15
80006c40:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006c44:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006c48:	de 11       	jne %d15,1,80006c6a <IncrementCounter+0xf4>
    p_ccb->service_id            = service_id;
80006c4a:	da 2e       	mov %d15,46
80006c4c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006c50:	82 0f       	mov %d15,0
80006c52:	e9 ff 23 00 	st.b [%a15]35,%d15
80006c56:	3c 0a       	j 80006c6a <IncrementCounter+0xf4>
FUNC(StatusType, OS_CODE)
  IncrementCounter
(
  VAR(CounterType, AUTOMATIC) CounterID
)
{
80006c58:	82 09       	mov %d9,0
80006c5a:	3c f5       	j 80006c44 <IncrementCounter+0xce>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006c5c:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006c60:	8f ff 0f 31 	and %d3,%d15,255
80006c64:	ff 23 da ff 	jge.u %d3,2,80006c18 <IncrementCounter+0xa2>
80006c68:	3c d1       	j 80006c0a <IncrementCounter+0x94>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_IncrementCounter);

  return ev;
}
80006c6a:	02 92       	mov %d2,%d9
80006c6c:	00 90       	ret 

80006c6e <StartScheduleTableRel>:
  StartScheduleTableRel
(
  VAR(ScheduleTableType, AUTOMATIC) ScheduleTableID,
  VAR(TickType, AUTOMATIC)          Offset
)
{
80006c6e:	40 ae       	mov.aa %a14,%sp
80006c70:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006c72:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006c74:	da 35       	mov %d15,53
80006c76:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006c7a:	82 1f       	mov %d15,1
80006c7c:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (st_id < p_kdb->p_kcb->free_st_index);
#else
  return (st_id < p_kdb->st_array_size);
80006c80:	91 00 00 28 	movh.a %a2,32768
80006c84:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006c88:	19 22 28 00 	ld.w %d2,[%a2]40 <80000028 <osEE_kdb_var>>
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
    ev = E_OS_ID;
80006c8c:	82 3f       	mov %d15,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
80006c8e:	7f 24 39 80 	jge.u %d4,%d2,80006d00 <StartScheduleTableRel+0x92>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_st_db = (*p_kdb->p_st_ptr_array)[ScheduleTableID];
80006c92:	91 00 00 28 	movh.a %a2,32768
80006c96:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006c9a:	99 22 24 00 	ld.a %a2,[%a2]36 <80000024 <_start+0x4>>
80006c9e:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006ca2:	d4 25       	ld.a %a5,[%a2]
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_st_get_trigger_db(p_st_db)->p_counter_db;
80006ca4:	99 52 04 00 	ld.a %a2,[%a5]4
80006ca8:	99 24 04 00 	ld.a %a4,[%a2]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006cac:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006cb0:	8f f8 0f f1 	and %d15,%d8,255
80006cb4:	ff 2f 09 80 	jge.u %d15,2,80006cc6 <StartScheduleTableRel+0x58>
    OsEE_icr icr_temp = icr;
80006cb8:	02 8f       	mov %d15,%d8
80006cba:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006cbe:	cd cf e2 0f 	mtcr $icr,%d15
80006cc2:	0d 00 c0 04 	isync 
       OsCounterMaxAllowedValue of the underlying counter minus the Initial
       Offset, StartScheduleTableRel() shall return E_OS_VALUE. */
    /* [SWS_Os_00277] If the schedule table <ScheduleTableID> in a call of
        StartScheduleTableRel() is not in the state SCHEDULETABLE_STOPPED,
        StartScheduleTableRel() shall return E_OS_STATE. */
    if (p_st_db->sync_strategy == OSEE_SCHEDTABLE_SYNC_IMPLICIT)
80006cc6:	39 52 10 00 	ld.bu %d2,[%a5]16
    {
      ev = E_OS_ID;
80006cca:	82 3f       	mov %d15,3
       OsCounterMaxAllowedValue of the underlying counter minus the Initial
       Offset, StartScheduleTableRel() shall return E_OS_VALUE. */
    /* [SWS_Os_00277] If the schedule table <ScheduleTableID> in a call of
        StartScheduleTableRel() is not in the state SCHEDULETABLE_STOPPED,
        StartScheduleTableRel() shall return E_OS_STATE. */
    if (p_st_db->sync_strategy == OSEE_SCHEDTABLE_SYNC_IMPLICIT)
80006ccc:	df 12 11 00 	jeq %d2,1,80006cee <StartScheduleTableRel+0x80>
    {
      ev = E_OS_ID;
    } else if ((Offset == 0) || (Offset > p_counter_db->info.maxallowedvalue))
    {
      ev = E_OS_VALUE;
80006cd0:	da 08       	mov %d15,8
        StartScheduleTableRel() is not in the state SCHEDULETABLE_STOPPED,
        StartScheduleTableRel() shall return E_OS_STATE. */
    if (p_st_db->sync_strategy == OSEE_SCHEDTABLE_SYNC_IMPLICIT)
    {
      ev = E_OS_ID;
    } else if ((Offset == 0) || (Offset > p_counter_db->info.maxallowedvalue))
80006cd2:	76 5e       	jz %d5,80006cee <StartScheduleTableRel+0x80>
80006cd4:	19 42 04 00 	ld.w %d2,[%a4]4
80006cd8:	3f 52 0b 80 	jlt.u %d2,%d5,80006cee <StartScheduleTableRel+0x80>
    {
      ev = E_OS_VALUE;
    } else if (osEE_st_get_cb(p_st_db)->st_status != SCHEDULETABLE_STOPPED)
80006cdc:	d4 52       	ld.a %a2,[%a5]
80006cde:	19 22 08 00 	ld.w %d2,[%a2]8
    {
      ev = E_OS_STATE;
80006ce2:	82 7f       	mov %d15,7
    {
      ev = E_OS_ID;
    } else if ((Offset == 0) || (Offset > p_counter_db->info.maxallowedvalue))
    {
      ev = E_OS_VALUE;
    } else if (osEE_st_get_cb(p_st_db)->st_status != SCHEDULETABLE_STOPPED)
80006ce4:	f6 25       	jnz %d2,80006cee <StartScheduleTableRel+0x80>
          processing of a schedule table <ScheduleTableID>.
          The Initial Expiry Point shall be processed after
          <Offset> + Initial Offset ticks have elapsed on the underlying
          counter. The state of <ScheduleTableID> is set to
          SCHEDULETABLE_RUNNING before the service returns to the caller. */
      ev = osEE_st_start_rel(p_counter_db, p_st_db, Offset);
80006ce6:	02 54       	mov %d4,%d5
80006ce8:	6d 00 db 09 	call 8000809e <osEE_st_start_rel>
80006cec:	02 2f       	mov %d15,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006cee:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006cf2:	5f 28 06 00 	jeq %d8,%d2,80006cfe <StartScheduleTableRel+0x90>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006cf6:	cd c8 e2 0f 	mtcr $icr,%d8
80006cfa:	0d 00 c0 04 	isync 
    }
    osEE_end_primitive(flags);
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80006cfe:	6e 24       	jz %d15,80006d46 <StartScheduleTableRel+0xd8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006d00:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006d04:	8f f9 0f 21 	and %d2,%d9,255
80006d08:	ff 22 09 80 	jge.u %d2,2,80006d1a <StartScheduleTableRel+0xac>
    OsEE_icr icr_temp = icr;
80006d0c:	02 92       	mov %d2,%d9
80006d0e:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006d12:	cd c2 e2 0f 	mtcr $icr,%d2
80006d16:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006d1a:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006d1e:	df 48 0c 00 	jeq %d8,4,80006d36 <StartScheduleTableRel+0xc8>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006d22:	82 42       	mov %d2,4
80006d24:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006d28:	e9 ff 12 00 	st.b [%a15]18,%d15
    ErrorHook(Error);
80006d2c:	02 f4       	mov %d4,%d15
80006d2e:	6d ff 06 eb 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006d32:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006d36:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006d3a:	5f 92 06 00 	jeq %d2,%d9,80006d46 <StartScheduleTableRel+0xd8>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006d3e:	cd c9 e2 0f 	mtcr $icr,%d9
80006d42:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006d46:	39 f2 23 00 	ld.bu %d2,[%a15]35
80006d4a:	df 12 09 80 	jne %d2,1,80006d5c <StartScheduleTableRel+0xee>
    p_ccb->service_id            = service_id;
80006d4e:	3b 40 03 20 	mov %d2,52
80006d52:	e9 f2 13 00 	st.b [%a15]19,%d2
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006d56:	82 02       	mov %d2,0
80006d58:	e9 f2 23 00 	st.b [%a15]35,%d2
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartScheduleTableRel);

  return ev;
}
80006d5c:	02 f2       	mov %d2,%d15
80006d5e:	00 90       	ret 

80006d60 <StartScheduleTableAbs>:
  StartScheduleTableAbs
(
  VAR(ScheduleTableType, AUTOMATIC) ScheduleTableID,
  VAR(TickType, AUTOMATIC)          Start
)
{
80006d60:	40 ae       	mov.aa %a14,%sp
80006d62:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006d64:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006d66:	da 37       	mov %d15,55
80006d68:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006d6c:	82 1f       	mov %d15,1
80006d6e:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (st_id < p_kdb->p_kcb->free_st_index);
#else
  return (st_id < p_kdb->st_array_size);
80006d72:	91 00 00 28 	movh.a %a2,32768
80006d76:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006d7a:	19 22 28 00 	ld.w %d2,[%a2]40 <80000028 <osEE_kdb_var>>
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  /* [SWS_Os_00348] If the schedule table <ScheduleTableID> in a call of
      StartScheduleTableAbs() is not valid, StartScheduleTableAbs()
      shall return E_OS_ID. */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
    ev = E_OS_ID;
80006d7e:	82 3f       	mov %d15,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  /* [SWS_Os_00348] If the schedule table <ScheduleTableID> in a call of
      StartScheduleTableAbs() is not valid, StartScheduleTableAbs()
      shall return E_OS_ID. */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
80006d80:	7f 24 33 80 	jge.u %d4,%d2,80006de6 <StartScheduleTableAbs+0x86>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_st_db = (*p_kdb->p_st_ptr_array)[ScheduleTableID];
80006d84:	91 00 00 28 	movh.a %a2,32768
80006d88:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006d8c:	99 22 24 00 	ld.a %a2,[%a2]36 <80000024 <_start+0x4>>
80006d90:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006d94:	d4 25       	ld.a %a5,[%a2]
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_st_get_trigger_db(p_st_db)->p_counter_db;
80006d96:	99 52 04 00 	ld.a %a2,[%a5]4
80006d9a:	99 24 04 00 	ld.a %a4,[%a2]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006d9e:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006da2:	8f f8 0f f1 	and %d15,%d8,255
80006da6:	ff 2f 09 80 	jge.u %d15,2,80006db8 <StartScheduleTableAbs+0x58>
    OsEE_icr icr_temp = icr;
80006daa:	02 8f       	mov %d15,%d8
80006dac:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006db0:	cd cf e2 0f 	mtcr $icr,%d15
80006db4:	0d 00 c0 04 	isync 
        is greater than the OsCounterMaxAllowedValue of the underlying counter,
        StartScheduleTableAbs() shall return E_OS_VALUE. */
    /* [SWS_Os_00350] If the schedule table <ScheduleTableID> in a call of
        StartScheduleTableAbs() is not in the state SCHEDULETABLE_STOPPED,
        StartScheduleTableAbs() shall return E_OS_STATE. */
    if (Start > p_counter_db->info.maxallowedvalue)
80006db8:	19 42 04 00 	ld.w %d2,[%a4]4
    {
      ev = E_OS_VALUE;
80006dbc:	da 08       	mov %d15,8
        is greater than the OsCounterMaxAllowedValue of the underlying counter,
        StartScheduleTableAbs() shall return E_OS_VALUE. */
    /* [SWS_Os_00350] If the schedule table <ScheduleTableID> in a call of
        StartScheduleTableAbs() is not in the state SCHEDULETABLE_STOPPED,
        StartScheduleTableAbs() shall return E_OS_STATE. */
    if (Start > p_counter_db->info.maxallowedvalue)
80006dbe:	3f 52 0b 80 	jlt.u %d2,%d5,80006dd4 <StartScheduleTableAbs+0x74>
    {
      ev = E_OS_VALUE;
    } else if (osEE_st_get_cb(p_st_db)->st_status != SCHEDULETABLE_STOPPED)
80006dc2:	d4 52       	ld.a %a2,[%a5]
80006dc4:	19 22 08 00 	ld.w %d2,[%a2]8
    {
      ev = E_OS_STATE;
80006dc8:	82 7f       	mov %d15,7
        StartScheduleTableAbs() is not in the state SCHEDULETABLE_STOPPED,
        StartScheduleTableAbs() shall return E_OS_STATE. */
    if (Start > p_counter_db->info.maxallowedvalue)
    {
      ev = E_OS_VALUE;
    } else if (osEE_st_get_cb(p_st_db)->st_status != SCHEDULETABLE_STOPPED)
80006dca:	f6 25       	jnz %d2,80006dd4 <StartScheduleTableAbs+0x74>
          - SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS (for implicitly synchronized
            schedule table)
          before returning to the user. (The Initial Expiry Point will be
          processed when the underlying counter next equals
          <Start>+Initial Offset). */
      ev = osEE_st_start_abs(p_counter_db, p_st_db, Start);
80006dcc:	02 54       	mov %d4,%d5
80006dce:	6d 00 bb 09 	call 80008144 <osEE_st_start_abs>
80006dd2:	02 2f       	mov %d15,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006dd4:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006dd8:	5f 28 06 00 	jeq %d8,%d2,80006de4 <StartScheduleTableAbs+0x84>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006ddc:	cd c8 e2 0f 	mtcr $icr,%d8
80006de0:	0d 00 c0 04 	isync 
    }
    osEE_end_primitive(flags);
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80006de4:	6e 24       	jz %d15,80006e2c <StartScheduleTableAbs+0xcc>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006de6:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006dea:	8f f9 0f 21 	and %d2,%d9,255
80006dee:	ff 22 09 80 	jge.u %d2,2,80006e00 <StartScheduleTableAbs+0xa0>
    OsEE_icr icr_temp = icr;
80006df2:	02 92       	mov %d2,%d9
80006df4:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006df8:	cd c2 e2 0f 	mtcr $icr,%d2
80006dfc:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006e00:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006e04:	df 48 0c 00 	jeq %d8,4,80006e1c <StartScheduleTableAbs+0xbc>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006e08:	82 42       	mov %d2,4
80006e0a:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006e0e:	e9 ff 12 00 	st.b [%a15]18,%d15
    ErrorHook(Error);
80006e12:	02 f4       	mov %d4,%d15
80006e14:	6d ff 93 ea 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006e18:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006e1c:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006e20:	5f 92 06 00 	jeq %d2,%d9,80006e2c <StartScheduleTableAbs+0xcc>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006e24:	cd c9 e2 0f 	mtcr $icr,%d9
80006e28:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006e2c:	39 f2 23 00 	ld.bu %d2,[%a15]35
80006e30:	df 12 09 80 	jne %d2,1,80006e42 <StartScheduleTableAbs+0xe2>
    p_ccb->service_id            = service_id;
80006e34:	3b 60 03 20 	mov %d2,54
80006e38:	e9 f2 13 00 	st.b [%a15]19,%d2
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006e3c:	82 02       	mov %d2,0
80006e3e:	e9 f2 23 00 	st.b [%a15]35,%d2
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartScheduleTableAbs);

  return ev;
}
80006e42:	02 f2       	mov %d2,%d15
80006e44:	00 90       	ret 

80006e46 <StopScheduleTable>:
FUNC(StatusType, OS_CODE)
  StopScheduleTable
(
  VAR(ScheduleTableType, AUTOMATIC) ScheduleTableID
)
{
80006e46:	40 ae       	mov.aa %a14,%sp
80006e48:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006e4a:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006e4c:	da 39       	mov %d15,57
80006e4e:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006e52:	82 1f       	mov %d15,1
80006e54:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (st_id < p_kdb->p_kcb->free_st_index);
#else
  return (st_id < p_kdb->st_array_size);
80006e58:	91 00 00 28 	movh.a %a2,32768
80006e5c:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006e60:	4c 2a       	ld.w %d15,[%a2]40
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  /* [SWS_Os_00279] If the schedule table identifier <ScheduleTableID> in a
      call of StopScheduleTable() is not valid, StopScheduleTable()
      shall return E_OS_ID. */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
    ev = E_OS_ID;
80006e62:	82 38       	mov %d8,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  /* [SWS_Os_00279] If the schedule table identifier <ScheduleTableID> in a
      call of StopScheduleTable() is not valid, StopScheduleTable()
      shall return E_OS_ID. */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
80006e64:	7f f4 24 80 	jge.u %d4,%d15,80006eac <StopScheduleTable+0x66>
    /* [SWS_Os_00281] If the input parameters of StopScheduleTable() are valid,
        StopScheduleTable() shall set the state of <ScheduleTableID> to
        SCHEDULETABLE_STOPPED and (stop the schedule table <ScheduleTableID>
        from processing any further expiry points and) shall return E_OK. */
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_st_db  = (*p_kdb->p_st_ptr_array)[ScheduleTableID];
80006e68:	91 00 00 28 	movh.a %a2,32768
80006e6c:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006e70:	99 22 24 00 	ld.a %a2,[%a2]36 <80000024 <_start+0x4>>
80006e74:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80006e78:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006e7a:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006e7e:	8f f9 0f f1 	and %d15,%d9,255
80006e82:	ff 2f 09 80 	jge.u %d15,2,80006e94 <StopScheduleTable+0x4e>
    OsEE_icr icr_temp = icr;
80006e86:	02 9f       	mov %d15,%d9
80006e88:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006e8c:	cd cf e2 0f 	mtcr $icr,%d15
80006e90:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_st_stop(p_st_db);
80006e94:	6d 00 9e 09 	call 800081d0 <osEE_st_stop>
80006e98:	02 28       	mov %d8,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006e9a:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006e9e:	3e 95       	jeq %d15,%d9,80006ea8 <StopScheduleTable+0x62>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006ea0:	cd c9 e2 0f 	mtcr $icr,%d9
80006ea4:	0d 00 c0 04 	isync 

    osEE_end_primitive(flags);
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80006ea8:	df 08 23 00 	jeq %d8,0,80006eee <StopScheduleTable+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006eac:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006eb0:	8f f9 0f f1 	and %d15,%d9,255
80006eb4:	ff 2f 09 80 	jge.u %d15,2,80006ec6 <StopScheduleTable+0x80>
    OsEE_icr icr_temp = icr;
80006eb8:	02 9f       	mov %d15,%d9
80006eba:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006ebe:	cd cf e2 0f 	mtcr $icr,%d15
80006ec2:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006ec6:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006eca:	1e 4b       	jeq %d15,4,80006ee0 <StopScheduleTable+0x9a>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006ecc:	82 42       	mov %d2,4
80006ece:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006ed2:	e9 f8 12 00 	st.b [%a15]18,%d8
    ErrorHook(Error);
80006ed6:	02 84       	mov %d4,%d8
80006ed8:	6d ff 31 ea 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006edc:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006ee0:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006ee4:	3e 95       	jeq %d15,%d9,80006eee <StopScheduleTable+0xa8>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006ee6:	cd c9 e2 0f 	mtcr $icr,%d9
80006eea:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006eee:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006ef2:	5e 17       	jne %d15,1,80006f00 <StopScheduleTable+0xba>
    p_ccb->service_id            = service_id;
80006ef4:	da 38       	mov %d15,56
80006ef6:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006efa:	82 0f       	mov %d15,0
80006efc:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_StopScheduleTable);

  return ev;
}
80006f00:	02 82       	mov %d2,%d8
80006f02:	00 90       	ret 

80006f04 <GetScheduleTableStatus>:
  GetScheduleTableStatus
(
  VAR(ScheduleTableType, AUTOMATIC)           ScheduleTableID,
  VAR(ScheduleTableStatusRefType, AUTOMATIC)  ScheduleStatus
)
{
80006f04:	40 ae       	mov.aa %a14,%sp
80006f06:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ERRORHOOK)) && (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ERRORHOOK && !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
80006f08:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006f0a:	da 3b       	mov %d15,59
80006f0c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006f10:	82 1f       	mov %d15,1
80006f12:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (st_id < p_kdb->p_kcb->free_st_index);
#else
  return (st_id < p_kdb->st_array_size);
80006f16:	91 00 00 28 	movh.a %a2,32768
80006f1a:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006f1e:	4c 2a       	ld.w %d15,[%a2]40
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
    ev = E_OS_ID;
80006f20:	82 39       	mov %d9,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
80006f22:	7f f4 3d 80 	jge.u %d4,%d15,80006f9c <GetScheduleTableStatus+0x98>
    ev = E_OS_ID;
  } else
  if (ScheduleStatus == NULL) {
80006f26:	bd 04 39 00 	jz.a %a4,80006f98 <GetScheduleTableStatus+0x94>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_st_db = (*p_kdb->p_st_ptr_array)[ScheduleTableID];
80006f2a:	91 00 00 28 	movh.a %a2,32768
80006f2e:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006f32:	99 22 24 00 	ld.a %a2,[%a2]36 <80000024 <_start+0x4>>
80006f36:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
80006f3a:	d4 22       	ld.a %a2,[%a2]
        (deviation is not within the precision interval OR the schedule table
        has been set asynchronous), GetScheduleTableStatus() shall pass back
        SCHEDULETABLE_RUNNING via the reference parameter ScheduleStatus AND
        shall return E_OK. */
    /* XXX: ScheduleTableStatusType read MUST Atomic */
    *ScheduleStatus = p_st_cb->st_status & (~SCHEDULETABLE_ASYNC);
80006f3c:	d4 22       	ld.a %a2,[%a2]
80006f3e:	4c 22       	ld.w %d15,[%a2]8
80006f40:	8f 8f c0 f1 	andn %d15,%d15,8
80006f44:	6c 40       	st.w [%a4]0,%d15

    ev = E_OK;
80006f46:	82 09       	mov %d9,0
80006f48:	3c 1e       	j 80006f84 <GetScheduleTableStatus+0x80>
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
80006f4a:	02 f2       	mov %d2,%d15
80006f4c:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006f50:	cd c2 e2 0f 	mtcr $icr,%d2
80006f54:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80006f58:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80006f5c:	df 48 0c 00 	jeq %d8,4,80006f74 <GetScheduleTableStatus+0x70>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80006f60:	82 42       	mov %d2,4
80006f62:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80006f66:	e9 f9 12 00 	st.b [%a15]18,%d9
    ErrorHook(Error);
80006f6a:	02 94       	mov %d4,%d9
80006f6c:	6d ff e7 e9 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80006f70:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006f74:	4d c0 e2 3f 	mfcr %d3,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80006f78:	5f f3 06 00 	jeq %d3,%d15,80006f84 <GetScheduleTableStatus+0x80>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80006f7c:	cd cf e2 0f 	mtcr $icr,%d15
80006f80:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80006f84:	39 ff 23 00 	ld.bu %d15,[%a15]35
80006f88:	de 11       	jne %d15,1,80006faa <GetScheduleTableStatus+0xa6>
    p_ccb->service_id            = service_id;
80006f8a:	da 3a       	mov %d15,58
80006f8c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80006f90:	82 0f       	mov %d15,0
80006f92:	e9 ff 23 00 	st.b [%a15]35,%d15
80006f96:	3c 0a       	j 80006faa <GetScheduleTableStatus+0xa6>
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID)) {
    ev = E_OS_ID;
  } else
  if (ScheduleStatus == NULL) {
    ev = E_OS_PARAM_POINTER;
80006f98:	3b e0 00 90 	mov %d9,14
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006f9c:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006fa0:	8f ff 0f 31 	and %d3,%d15,255
80006fa4:	ff 23 da ff 	jge.u %d3,2,80006f58 <GetScheduleTableStatus+0x54>
80006fa8:	3c d1       	j 80006f4a <GetScheduleTableStatus+0x46>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetScheduleTableStatus);

  return ev;
}
80006faa:	02 92       	mov %d2,%d9
80006fac:	00 90       	ret 

80006fae <NextScheduleTable>:
  NextScheduleTable
(
  VAR(ScheduleTableType, AUTOMATIC) ScheduleTableID_From,
  VAR(ScheduleTableType, AUTOMATIC) ScheduleTableID_To
)
{
80006fae:	40 ae       	mov.aa %a14,%sp
80006fb0:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80006fb2:	c8 3f       	ld.a %a15,[%a15]12
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (st_id < p_kdb->p_kcb->free_st_index);
#else
  return (st_id < p_kdb->st_array_size);
80006fb4:	91 00 00 28 	movh.a %a2,32768
80006fb8:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006fbc:	4c 2a       	ld.w %d15,[%a2]40
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80006fbe:	3b d0 03 20 	mov %d2,61
80006fc2:	e9 f2 13 00 	st.b [%a15]19,%d2
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80006fc6:	82 12       	mov %d2,1
80006fc8:	e9 f2 23 00 	st.b [%a15]35,%d2
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00282] If the input parameter <ScheduleTableID_From> or
    <ScheduleTableID_To> in a call of NextScheduleTable() is not valid,
    NextScheduleTable() shall return E_OS_ID. */
  if ((!valid_st_id_from) || (!valid_st_id_to)) {
80006fcc:	0b f4 50 31 	ge.u %d3,%d4,%d15
80006fd0:	0b f5 c0 32 	or.ge.u %d3,%d5,%d15
    ev = E_OS_ID;
80006fd4:	82 3f       	mov %d15,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00282] If the input parameter <ScheduleTableID_From> or
    <ScheduleTableID_To> in a call of NextScheduleTable() is not valid,
    NextScheduleTable() shall return E_OS_ID. */
  if ((!valid_st_id_from) || (!valid_st_id_to)) {
80006fd6:	df 03 4a 80 	jne %d3,0,8000706a <NextScheduleTable+0xbc>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_from_st_db = (*p_kdb->p_st_ptr_array)[ScheduleTableID_From];
80006fda:	91 00 00 28 	movh.a %a2,32768
80006fde:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
80006fe2:	4c 29       	ld.w %d15,[%a2]36
80006fe4:	60 f3       	mov.a %a3,%d15
80006fe6:	01 34 02 26 	addsc.a %a2,%a3,%d4,2
80006fea:	d4 23       	ld.a %a3,[%a2]
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_to_st_db = (*p_kdb->p_st_ptr_array)[ScheduleTableID_To];
80006fec:	60 f4       	mov.a %a4,%d15
80006fee:	01 45 02 26 	addsc.a %a2,%a4,%d5,2
80006ff2:	d4 22       	ld.a %a2,[%a2]
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
80006ff4:	d4 34       	ld.a %a4,[%a3]
80006ff6:	d4 25       	ld.a %a5,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80006ff8:	4d c0 e2 3f 	mfcr %d3,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80006ffc:	8f f3 0f f1 	and %d15,%d3,255
80007000:	ff 2f 09 80 	jge.u %d15,2,80007012 <NextScheduleTable+0x64>
    OsEE_icr icr_temp = icr;
80007004:	02 3f       	mov %d15,%d3
80007006:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000700a:	cd cf e2 0f 	mtcr $icr,%d15
8000700e:	0d 00 c0 04 	isync 
  /*   XXX: !!! Contradiction with SWS_Os_00324 && SWS_Os_00453 !!!  */
  /* [SWS_Os_00309] If the schedule table <ScheduleTableID_To> in a call of
      NextScheduleTable() is not in state SCHEDULETABLE_STOPPED,
      NextScheduleTable() shall leave the state of <ScheduleTable_From> and
      <ScheduleTable_To> unchanged and return E_OS_STATE. */
    if ((p_from_trigger_db->p_counter_db != p_to_trigger_db->p_counter_db) ||
80007012:	99 37 04 00 	ld.a %a7,[%a3]4
80007016:	99 26 04 00 	ld.a %a6,[%a2]4
8000701a:	19 74 04 00 	ld.w %d4,[%a7]4
8000701e:	19 62 04 00 	ld.w %d2,[%a6]4
        (p_from_st_db->sync_strategy != p_to_st_db->sync_strategy)
      )
    {
      ev = E_OS_ID;
80007022:	82 3f       	mov %d15,3
  /*   XXX: !!! Contradiction with SWS_Os_00324 && SWS_Os_00453 !!!  */
  /* [SWS_Os_00309] If the schedule table <ScheduleTableID_To> in a call of
      NextScheduleTable() is not in state SCHEDULETABLE_STOPPED,
      NextScheduleTable() shall leave the state of <ScheduleTable_From> and
      <ScheduleTable_To> unchanged and return E_OS_STATE. */
    if ((p_from_trigger_db->p_counter_db != p_to_trigger_db->p_counter_db) ||
80007024:	5f 24 1a 80 	jne %d4,%d2,80007058 <NextScheduleTable+0xaa>
80007028:	39 34 10 00 	ld.bu %d4,[%a3]16
8000702c:	39 22 10 00 	ld.bu %d2,[%a2]16
80007030:	5f 24 14 80 	jne %d4,%d2,80007058 <NextScheduleTable+0xaa>
        (p_from_st_db->sync_strategy != p_to_st_db->sync_strategy)
      )
    {
      ev = E_OS_ID;
    } else
    if ((p_from_st_cb->st_status == SCHEDULETABLE_STOPPED) ||
80007034:	19 42 08 00 	ld.w %d2,[%a4]8
      (p_from_st_cb->st_status == SCHEDULETABLE_NEXT))
    {
      ev = E_OS_NOFUNC;
80007038:	82 5f       	mov %d15,5
        (p_from_st_db->sync_strategy != p_to_st_db->sync_strategy)
      )
    {
      ev = E_OS_ID;
    } else
    if ((p_from_st_cb->st_status == SCHEDULETABLE_STOPPED) ||
8000703a:	bf 22 0f 80 	jlt.u %d2,2,80007058 <NextScheduleTable+0xaa>
      (p_from_st_cb->st_status == SCHEDULETABLE_NEXT))
    {
      ev = E_OS_NOFUNC;
    } else
    if (p_to_st_cb->st_status != SCHEDULETABLE_STOPPED) {
8000703e:	19 52 08 00 	ld.w %d2,[%a5]8
      ev = E_OS_STATE;
80007042:	82 7f       	mov %d15,7
    if ((p_from_st_cb->st_status == SCHEDULETABLE_STOPPED) ||
      (p_from_st_cb->st_status == SCHEDULETABLE_NEXT))
    {
      ev = E_OS_NOFUNC;
    } else
    if (p_to_st_cb->st_status != SCHEDULETABLE_STOPPED) {
80007044:	f6 2a       	jnz %d2,80007058 <NextScheduleTable+0xaa>
    synchronization after the start of processing <ScheduleTableID_To>. */
/* [SWS_Os_00453] If the <ScheduleTableID_From> in a call of
    NextScheduleTable() is stopped, NextScheduleTable() shall not start the
    "next" schedule table and change its state to SCHEDULETABLE_STOPPED.
    XXX: !!! Contradiction with SWS_Os_00283 !!! */
      if (p_from_st_cb->p_next_table != NULL) {
80007046:	d4 43       	ld.a %a3,[%a4]
80007048:	bc 34       	jz.a %a3,80007050 <NextScheduleTable+0xa2>
8000704a:	d4 33       	ld.a %a3,[%a3]
        osEE_st_get_cb(p_from_st_cb->p_next_table)->
          st_status = SCHEDULETABLE_STOPPED;
8000704c:	82 0f       	mov %d15,0
8000704e:	6c 32       	st.w [%a3]8,%d15
      }

      p_from_st_cb->p_next_table = p_to_st_db;
80007050:	f4 42       	st.a [%a4],%a2
      p_to_st_cb->st_status = SCHEDULETABLE_NEXT;
80007052:	82 1f       	mov %d15,1
80007054:	6c 52       	st.w [%a5]8,%d15

      ev = E_OK;
80007056:	82 0f       	mov %d15,0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007058:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000705c:	5f 23 06 00 	jeq %d3,%d2,80007068 <NextScheduleTable+0xba>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007060:	cd c3 e2 0f 	mtcr $icr,%d3
80007064:	0d 00 c0 04 	isync 
    }

    osEE_end_primitive(flags);
  }
#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80007068:	6e 24       	jz %d15,800070b0 <NextScheduleTable+0x102>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000706a:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000706e:	8f f9 0f 21 	and %d2,%d9,255
80007072:	ff 22 09 80 	jge.u %d2,2,80007084 <NextScheduleTable+0xd6>
    OsEE_icr icr_temp = icr;
80007076:	02 92       	mov %d2,%d9
80007078:	b7 22 08 20 	insert %d2,%d2,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000707c:	cd c2 e2 0f 	mtcr $icr,%d2
80007080:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80007084:	39 f8 14 00 	ld.bu %d8,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80007088:	df 48 0c 00 	jeq %d8,4,800070a0 <NextScheduleTable+0xf2>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
8000708c:	82 42       	mov %d2,4
8000708e:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80007092:	e9 ff 12 00 	st.b [%a15]18,%d15
    ErrorHook(Error);
80007096:	02 f4       	mov %d4,%d15
80007098:	6d ff 51 e9 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
8000709c:	e9 f8 14 00 	st.b [%a15]20,%d8
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800070a0:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800070a4:	5f 92 06 00 	jeq %d2,%d9,800070b0 <NextScheduleTable+0x102>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800070a8:	cd c9 e2 0f 	mtcr $icr,%d9
800070ac:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800070b0:	39 f2 23 00 	ld.bu %d2,[%a15]35
800070b4:	df 12 09 80 	jne %d2,1,800070c6 <NextScheduleTable+0x118>
    p_ccb->service_id            = service_id;
800070b8:	3b c0 03 20 	mov %d2,60
800070bc:	e9 f2 13 00 	st.b [%a15]19,%d2
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800070c0:	82 02       	mov %d2,0
800070c2:	e9 f2 23 00 	st.b [%a15]35,%d2
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_NextScheduleTable);

  return ev;
}
800070c6:	02 f2       	mov %d2,%d15
800070c8:	00 90       	ret 

800070ca <SyncScheduleTable>:
  SyncScheduleTable
(
  VAR(ScheduleTableType, AUTOMATIC) ScheduleTableID,
  VAR(TickType, AUTOMATIC)          Value
)
{
800070ca:	40 ae       	mov.aa %a14,%sp
800070cc:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800070ce:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800070d0:	da 3f       	mov %d15,63
800070d2:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800070d6:	82 1f       	mov %d15,1
800070d8:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (st_id < p_kdb->p_kcb->free_st_index);
#else
  return (st_id < p_kdb->st_array_size);
800070dc:	91 00 00 28 	movh.a %a2,32768
800070e0:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800070e4:	4c 2a       	ld.w %d15,[%a2]40
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  /* [SWS_Os_00279] If the schedule table identifier <ScheduleTableID> in a
      call of StopScheduleTable() is not valid, StopScheduleTable()
      shall return E_OS_ID. */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID))
800070e6:	7f f4 35 80 	jge.u %d4,%d15,80007150 <SyncScheduleTable+0x86>
  {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
      p_st_db = (*p_kdb->p_st_ptr_array)[ScheduleTableID];
800070ea:	91 00 00 28 	movh.a %a2,32768
800070ee:	d9 22 28 00 	lea %a2,[%a2]40 <80000028 <osEE_kdb_var>>
800070f2:	99 22 24 00 	ld.a %a2,[%a2]36 <80000024 <_start+0x4>>
800070f6:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
800070fa:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800070fc:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80007100:	8f f8 0f f1 	and %d15,%d8,255
80007104:	ff 2f 09 80 	jge.u %d15,2,80007116 <SyncScheduleTable+0x4c>
    OsEE_icr icr_temp = icr;
80007108:	02 8f       	mov %d15,%d8
8000710a:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000710e:	cd cf e2 0f 	mtcr $icr,%d15
80007112:	0d 00 c0 04 	isync 
    greater or equal than the OsScheduleTableDuration, SyncScheduleTable()
    shall return E_OS_VALUE. */
/* [SWS_Os_00456] If the state of the schedule table <ScheduleTableID> in a
    call of SyncScheduleTable() is equal to SCHEDULETABLE_STOPPED or
    SCHEDULETABLE_NEXT SyncScheduleTable() shall return E_OS_STATE. */
    if (p_st_db->sync_strategy != OSEE_SCHEDTABLE_SYNC_EXPLICIT) {
80007116:	39 4f 10 00 	ld.bu %d15,[%a4]16
      ev = E_OS_ID;
8000711a:	82 34       	mov %d4,3
    greater or equal than the OsScheduleTableDuration, SyncScheduleTable()
    shall return E_OS_VALUE. */
/* [SWS_Os_00456] If the state of the schedule table <ScheduleTableID> in a
    call of SyncScheduleTable() is equal to SCHEDULETABLE_STOPPED or
    SCHEDULETABLE_NEXT SyncScheduleTable() shall return E_OS_STATE. */
    if (p_st_db->sync_strategy != OSEE_SCHEDTABLE_SYNC_EXPLICIT) {
8000711c:	5e 2f       	jne %d15,2,8000713a <SyncScheduleTable+0x70>
      ev = E_OS_ID;
    } else
    if (Value >= p_st_db->duration ) {
8000711e:	4c 45       	ld.w %d15,[%a4]20
      ev = E_OS_VALUE;
80007120:	3b 80 00 40 	mov %d4,8
    call of SyncScheduleTable() is equal to SCHEDULETABLE_STOPPED or
    SCHEDULETABLE_NEXT SyncScheduleTable() shall return E_OS_STATE. */
    if (p_st_db->sync_strategy != OSEE_SCHEDTABLE_SYNC_EXPLICIT) {
      ev = E_OS_ID;
    } else
    if (Value >= p_st_db->duration ) {
80007124:	7f f5 0b 80 	jge.u %d5,%d15,8000713a <SyncScheduleTable+0x70>
      ev = E_OS_VALUE;
    } else if ((osEE_st_get_cb(p_st_db)->st_status == SCHEDULETABLE_STOPPED) ||
80007128:	d4 42       	ld.a %a2,[%a4]
8000712a:	4c 22       	ld.w %d15,[%a2]8
      (osEE_st_get_cb(p_st_db)->st_status == SCHEDULETABLE_NEXT)
    ) 
    {
      ev = E_OS_STATE;
8000712c:	82 74       	mov %d4,7
    if (p_st_db->sync_strategy != OSEE_SCHEDTABLE_SYNC_EXPLICIT) {
      ev = E_OS_ID;
    } else
    if (Value >= p_st_db->duration ) {
      ev = E_OS_VALUE;
    } else if ((osEE_st_get_cb(p_st_db)->st_status == SCHEDULETABLE_STOPPED) ||
8000712e:	bf 2f 06 80 	jlt.u %d15,2,8000713a <SyncScheduleTable+0x70>
    {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    {
      ev = osEE_st_syncronize(p_st_db, Value);
80007132:	02 54       	mov %d4,%d5
80007134:	6d 00 93 08 	call 8000825a <osEE_st_syncronize>
80007138:	02 24       	mov %d4,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000713a:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000713e:	5f f8 06 00 	jeq %d8,%d15,8000714a <SyncScheduleTable+0x80>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007142:	cd c8 e2 0f 	mtcr $icr,%d8
80007146:	0d 00 c0 04 	isync 
    }

    osEE_end_primitive(flags);
  }
#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
8000714a:	df 04 24 00 	jeq %d4,0,80007192 <SyncScheduleTable+0xc8>
8000714e:	3c 02       	j 80007152 <SyncScheduleTable+0x88>
  /* [SWS_Os_00279] If the schedule table identifier <ScheduleTableID> in a
      call of StopScheduleTable() is not valid, StopScheduleTable()
      shall return E_OS_ID. */
  if (!osEE_is_valid_st_id(p_kdb, ScheduleTableID))
  {
    ev = E_OS_ID;
80007150:	82 34       	mov %d4,3
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007152:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80007156:	8f f8 0f f1 	and %d15,%d8,255
8000715a:	ff 2f 09 80 	jge.u %d15,2,8000716c <SyncScheduleTable+0xa2>
    OsEE_icr icr_temp = icr;
8000715e:	02 8f       	mov %d15,%d8
80007160:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007164:	cd cf e2 0f 	mtcr $icr,%d15
80007168:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
8000716c:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80007170:	1e 4a       	jeq %d15,4,80007184 <SyncScheduleTable+0xba>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80007172:	82 42       	mov %d2,4
80007174:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80007178:	e9 f4 12 00 	st.b [%a15]18,%d4
    ErrorHook(Error);
8000717c:	6d ff df e8 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80007180:	e9 ff 14 00 	st.b [%a15]20,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007184:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80007188:	3e 85       	jeq %d15,%d8,80007192 <SyncScheduleTable+0xc8>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000718a:	cd c8 e2 0f 	mtcr $icr,%d8
8000718e:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80007192:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007196:	5e 17       	jne %d15,1,800071a4 <SyncScheduleTable+0xda>
    p_ccb->service_id            = service_id;
80007198:	da 3e       	mov %d15,62
8000719a:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000719e:	82 0f       	mov %d15,0
800071a0:	e9 ff 23 00 	st.b [%a15]35,%d15
  }
#endif /* OSEE_HAS_ERRORHOOK */
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SyncScheduleTable);

  return E_OK;
}
800071a4:	82 02       	mov %d2,0
800071a6:	00 90       	ret 

800071a8 <GetISRID>:
FUNC(ISRType, OS_CODE)
  GetISRID
(
  void
)
{
800071a8:	40 ae       	mov.aa %a14,%sp
800071aa:	40 9f       	mov.aa %a15,%a9
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
800071ac:	c8 3f       	ld.a %a15,[%a15]12
800071ae:	c8 0f       	ld.a %a15,[%a15]0
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
800071b0:	39 ff 14 00 	ld.bu %d15,[%a15]20 <0 <NULL>>
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
800071b4:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
800071b6:	5e 22       	jne %d15,2,800071ba <GetISRID+0x12>
    isr_id = p_tdb->tid;
800071b8:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
800071ba:	00 90       	ret 

800071bc <GetNumberOfActivatedCores>:
FUNC(CoreNumType, OS_CODE)
  GetNumberOfActivatedCores
(
  void
)
{
800071bc:	40 ae       	mov.aa %a14,%sp
  /* [SWS_Os_00673] The return value of GetNumberOfActivatedCores shall be less
      or equal to the configured value of "OsNumberOfCores". (SRS_Os_80001) */
  return osEE_get_kernel()->p_kcb->ar_num_core_started;
800071be:	91 00 00 f8 	movh.a %a15,32768
800071c2:	99 ff 28 00 	ld.a %a15,[%a15]40 <80000028 <osEE_kdb_var>>
}
800071c6:	08 c2       	ld.bu %d2,[%a15]12
800071c8:	00 90       	ret 

800071ca <StartCore>:
  StartCore
(
  VAR(CoreIdType, AUTOMATIC)                  CoreID,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  Status
)
{
800071ca:	40 ae       	mov.aa %a14,%sp
800071cc:	40 4c       	mov.aa %a12,%a4
    osEE_unlock_kernel();

    osEE_end_primitive(flags);
  } else {
    /* CoreID >= OS_CORE_ID_ARR_SIZE */
    ev = E_OS_ID;
800071ce:	82 35       	mov %d5,3
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  Status
)
{
  /* Error Value */
  VAR(StatusType, AUTOMATIC) ev = E_OK;
  if (CoreID < OS_CORE_ID_ARR_SIZE) {
800071d0:	ff 34 4b 80 	jge.u %d4,3,80007266 <StartCore+0x9c>
800071d4:	40 9f       	mov.aa %a15,%a9
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
      p_cdb       = osEE_get_curr_core();
    CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
      p_ccb       = p_cdb->p_ccb;
800071d6:	c8 33       	ld.a %a3,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800071d8:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800071dc:	8f f8 0f f1 	and %d15,%d8,255
800071e0:	ff 2f 09 80 	jge.u %d15,2,800071f2 <StartCore+0x28>
    OsEE_icr icr_temp = icr;
800071e4:	02 8f       	mov %d15,%d8
800071e6:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800071ea:	cd cf e2 0f 	mtcr $icr,%d15
800071ee:	0d 00 c0 04 	isync 
 *  \brief Locks the kernel.
 *  
 *  Locks the kernel using the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_lock_kernel(void) {
  osEE_hal_spin_lock(osEE_kdb_var.p_lock);
800071f2:	91 00 00 f8 	movh.a %a15,32768
800071f6:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
800071fa:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
800071fc:	82 12       	mov %d2,1
800071fe:	82 03       	mov %d3,0
80007200:	0b 23 10 68 	mov %e6,%d3,%d2
80007204:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007208:	df 06 fa ff 	jne %d6,0,800071fc <StartCore+0x32>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
8000720c:	91 00 00 28 	movh.a %a2,32768
80007210:	99 22 28 00 	ld.a %a2,[%a2]40 <80000028 <osEE_kdb_var>>
    /* Variable introduced to meet MISRA 12.1 in the next else if statement */
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
80007214:	54 23       	ld.w %d3,[%a2]
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);
80007216:	82 1f       	mov %d15,1
80007218:	0f 4f 00 f0 	sh %d15,%d15,%d4

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
8000721c:	8f 7f 00 21 	and %d2,%d15,7
      ev = E_OS_ID;
80007220:	82 35       	mov %d5,3
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
80007222:	df 02 17 00 	jeq %d2,0,80007250 <StartCore+0x86>
      ev = E_OS_ID;
    } else if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
80007226:	39 32 10 00 	ld.bu %d2,[%a3]16
         If StartCore is called after StartOS it shall return with E_OS_ACCESS
         in extended status. (SRS_Os_80001) */
      /* [SWS_Os_00678] Calls to the StartCore function after StartOS()
         shall return with E_OS_ACCESS and the core shall not be started.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ACCESS;
8000722a:	82 15       	mov %d5,1
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
      ev = E_OS_ID;
    } else if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000722c:	df 02 12 80 	jne %d2,0,80007250 <StartCore+0x86>
         in extended status. (SRS_Os_80001) */
      /* [SWS_Os_00678] Calls to the StartCore function after StartOS()
         shall return with E_OS_ACCESS and the core shall not be started.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ACCESS;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
80007230:	19 22 04 00 	ld.w %d2,[%a2]4
80007234:	a6 32       	or %d2,%d3
80007236:	26 f2       	and %d2,%d15
          (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      /* [SWS_Os_00680] If the parameter CoreID refers to a core that was
         already started by the function StartNonAutosarCore the related core
         is ignored and E_OS_STATE shall be returned.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
80007238:	82 75       	mov %d5,7
         in extended status. (SRS_Os_80001) */
      /* [SWS_Os_00678] Calls to the StartCore function after StartOS()
         shall return with E_OS_ACCESS and the core shall not be started.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ACCESS;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
8000723a:	f6 2b       	jnz %d2,80007250 <StartCore+0x86>
        ++p_kcb->ar_num_core_started;

        osEE_hal_start_core(CoreID);
      }

      ev = E_OK;
8000723c:	82 05       	mov %d5,0
         is ignored and E_OS_STATE shall be returned.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
    } else {
      /* Really start the core if we are not in MASTER core */
      if (CoreID != OS_CORE_ID_MASTER) {
8000723e:	76 49       	jz %d4,80007250 <StartCore+0x86>
        /* [SWS_Os_00677] The function StartCore shall start one core that
           shall run under the control of the AUTOSAR OS.
           (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
        /* Flag that core is started as Autosar core */
        p_kcb->ar_core_mask |= core_id_mask;
80007240:	a6 3f       	or %d15,%d3
80007242:	6c 20       	st.w [%a2]0,%d15
        /* Increment the Autosar Cores counter */
        ++p_kcb->ar_num_core_started;
80007244:	0c 2c       	ld.bu %d15,[%a2]12
80007246:	c2 1f       	add %d15,1
80007248:	2c 2c       	st.b [%a2]12,%d15

        osEE_hal_start_core(CoreID);
8000724a:	6d 00 64 09 	call 80008512 <osEE_hal_start_core>
      }

      ev = E_OK;
8000724e:	82 05       	mov %d5,0
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80007250:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007254:	82 0f       	mov %d15,0
80007256:	68 0f       	st.w [%a15]0,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007258:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
8000725c:	3e 85       	jeq %d15,%d8,80007266 <StartCore+0x9c>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000725e:	cd c8 e2 0f 	mtcr $icr,%d8
80007262:	0d 00 c0 04 	isync 
    /* CoreID >= OS_CORE_ID_ARR_SIZE */
    ev = E_OS_ID;
  }
  /* [SWS_Os_00681] There is no call to the ErrorHook() if an error occurs
       during StartCore(); (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
  if (Status != NULL) {
80007266:	bc c2       	jz.a %a12,8000726a <StartCore+0xa0>
    *Status = ev;
80007268:	34 c5       	st.b [%a12],%d5
8000726a:	00 90       	ret 

8000726c <StartNonAutosarCore>:
  StartNonAutosarCore
(
  VAR(CoreIdType, AUTOMATIC)                  CoreID,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  Status
)
{
8000726c:	40 ae       	mov.aa %a14,%sp
8000726e:	40 4c       	mov.aa %a12,%a4
    osEE_end_primitive(flags);
  } else {
    /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
        function StartNonAutosarCore has no effect and sets "Status" to
        E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
    ev = E_OS_ID;
80007270:	82 35       	mov %d5,3
)
{
  /* Error Value */
  VAR(StatusType, AUTOMATIC) ev;

  if (CoreID < OS_CORE_ID_ARR_SIZE) {
80007272:	ff 34 41 80 	jge.u %d4,3,800072f4 <StartNonAutosarCore+0x88>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007276:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000727a:	8f f8 0f f1 	and %d15,%d8,255
8000727e:	ff 2f 09 80 	jge.u %d15,2,80007290 <StartNonAutosarCore+0x24>
    OsEE_icr icr_temp = icr;
80007282:	02 8f       	mov %d15,%d8
80007284:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007288:	cd cf e2 0f 	mtcr $icr,%d15
8000728c:	0d 00 c0 04 	isync 
80007290:	91 00 00 f8 	movh.a %a15,32768
80007294:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
80007298:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000729a:	82 12       	mov %d2,1
8000729c:	82 03       	mov %d3,0
8000729e:	0b 23 10 68 	mov %e6,%d3,%d2
800072a2:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
800072a6:	df 06 fa ff 	jne %d6,0,8000729a <StartNonAutosarCore+0x2e>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
800072aa:	91 00 00 28 	movh.a %a2,32768
800072ae:	99 22 28 00 	ld.a %a2,[%a2]40 <80000028 <osEE_kdb_var>>
    /* Variable introduced to meet MISRA 12.1 in the next else if statement */
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
800072b2:	54 23       	ld.w %d3,[%a2]
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);
800072b4:	82 1f       	mov %d15,1
800072b6:	0f 4f 00 f0 	sh %d15,%d15,%d4

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
800072ba:	8f 7f 00 21 	and %d2,%d15,7
      /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
          function StartNonAutosarCore has no effect and sets "Status" to
          E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ID;
800072be:	82 35       	mov %d5,3
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
800072c0:	76 2f       	jz %d2,800072de <StartNonAutosarCore+0x72>
      /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
          function StartNonAutosarCore has no effect and sets "Status" to
          E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ID;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
800072c2:	19 26 04 00 	ld.w %d6,[%a2]4
800072c6:	0f 36 a0 20 	or %d2,%d6,%d3
800072ca:	26 f2       	and %d2,%d15
    {
      /* [SWS_Os_00680] If the parameter CoreID refers to a core that was
          already started by the function StartNonAutosarCore the related core
          is ignored and E_OS_STATE shall be returned.
          (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
800072cc:	82 75       	mov %d5,7
    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
      /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
          function StartNonAutosarCore has no effect and sets "Status" to
          E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ID;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
800072ce:	f6 28       	jnz %d2,800072de <StartNonAutosarCore+0x72>
        /* Flag that core is started as non Autosar core */
        p_kcb->not_ar_core_mask |= core_id_mask;
        osEE_hal_start_core(CoreID);
      }

      ev = E_OK;
800072d0:	82 05       	mov %d5,0
          is ignored and E_OS_STATE shall be returned.
          (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
    } else {
      /* Really start the core if we are not in MASTER core */
      if (CoreID != OS_CORE_ID_MASTER) {
800072d2:	76 46       	jz %d4,800072de <StartNonAutosarCore+0x72>
        /* [SWS_Os_00683] The function StartNonAutosarCore shall start a core
            that is not controlled by the AUTOSAR OS.
            (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
        /* Flag that core is started as non Autosar core */
        p_kcb->not_ar_core_mask |= core_id_mask;
800072d4:	a6 6f       	or %d15,%d6
800072d6:	6c 21       	st.w [%a2]4,%d15
        osEE_hal_start_core(CoreID);
800072d8:	6d 00 1d 09 	call 80008512 <osEE_hal_start_core>
      }

      ev = E_OK;
800072dc:	82 05       	mov %d5,0
800072de:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
800072e2:	82 0f       	mov %d15,0
800072e4:	68 0f       	st.w [%a15]0,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800072e6:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800072ea:	3e 85       	jeq %d15,%d8,800072f4 <StartNonAutosarCore+0x88>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800072ec:	cd c8 e2 0f 	mtcr $icr,%d8
800072f0:	0d 00 c0 04 	isync 
        function StartNonAutosarCore has no effect and sets "Status" to
        E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
    ev = E_OS_ID;
  }

  if (Status != NULL) {
800072f4:	bc c2       	jz.a %a12,800072f8 <StartNonAutosarCore+0x8c>
    *Status = ev;
800072f6:	34 c5       	st.b [%a12],%d5
800072f8:	00 90       	ret 

800072fa <ShutdownAllCores>:
FUNC(void, OS_CODE) 
  ShutdownAllCores
(
  VAR(StatusType, AUTOMATIC)  Error
)
{
800072fa:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
800072fc:	40 94       	mov.aa %a4,%a9
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
800072fe:	cc 43       	ld.a %a15,[%a4]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007300:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80007304:	8f ff 0f 51 	and %d5,%d15,255
80007308:	ff 25 09 80 	jge.u %d5,2,8000731a <ShutdownAllCores+0x20>
    OsEE_icr icr_temp = icr;
8000730c:	02 f5       	mov %d5,%d15
8000730e:	b7 25 08 50 	insert %d5,%d5,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007312:	cd c5 e2 0f 	mtcr $icr,%d5
80007316:	0d 00 c0 04 	isync 
 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000731a:	39 f5 10 00 	ld.bu %d5,[%a15]16
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000731e:	3b d0 04 60 	mov %d6,77
80007322:	e9 f6 13 00 	st.b [%a15]19,%d6
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80007326:	82 16       	mov %d6,1
80007328:	e9 f6 23 00 	st.b [%a15]35,%d6
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#ifdef OSEE_HAS_OSAPPLICATIONS
  /* [Os_SWS_00716]: If ShutdownAllCores is called from non trusted code the call
      shall be ignored. (SRS_Os_80007) */
#endif /* EE_HAS_OSAPPLICATIONS__ */
  if ((os_status == OSEE_KERNEL_STARTED) || (os_status == OSEE_KERNEL_STARTING))
8000732c:	c2 f5       	add %d5,-1
8000732e:	8f f5 0f 51 	and %d5,%d5,255
80007332:	ff 25 4c 80 	jge.u %d5,2,800073ca <ShutdownAllCores+0xd0>
 *  \brief Locks the kernel.
 *  
 *  Locks the kernel using the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_lock_kernel(void) {
  osEE_hal_spin_lock(osEE_kdb_var.p_lock);
80007336:	91 00 00 f8 	movh.a %a15,32768
8000733a:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
8000733e:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007340:	82 12       	mov %d2,1
80007342:	82 03       	mov %d3,0
80007344:	0b 23 10 68 	mov %e6,%d3,%d2
80007348:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000734c:	df 06 fa ff 	jne %d6,0,80007340 <ShutdownAllCores+0x46>
  {
    VAR(CoreNumType, AUTOMATIC) i;
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
80007350:	91 00 00 28 	movh.a %a2,32768
80007354:	99 22 28 00 	ld.a %a2,[%a2]40 <80000028 <osEE_kdb_var>>
    /* If the procedure have been already started (by another core), just shut
       this core down, after have released all spinlocks */
    if (p_kcb->ar_shutdown_all_cores_flag) {
80007358:	0c 2e       	ld.bu %d15,[%a2]14
8000735a:	6e 09       	jz %d15,8000736c <ShutdownAllCores+0x72>
8000735c:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007360:	82 0f       	mov %d15,0
80007362:	68 0f       	st.w [%a15]0,%d15
      /* Release the kernel spinlock */
      osEE_unlock_kernel();
      /* This won't never return */
      osEE_shutdown_os(p_cdb, p_kcb->ar_shutdown_all_cores_error);
80007364:	39 24 0d 00 	ld.bu %d4,[%a2]13
80007368:	1d ff 0a f2 	j 8000577c <osEE_shutdown_os>
    } else {
      /* Save the Error parameter to be used in all other cores */
      p_kcb->ar_shutdown_all_cores_error = Error;
8000736c:	e9 24 0d 00 	st.b [%a2]13,%d4
      /* Set ShutdownAllCores global flag */
      p_kcb->ar_shutdown_all_cores_flag = OSEE_TRUE;
80007370:	82 1f       	mov %d15,1
80007372:	2c 2e       	st.b [%a2]14,%d15
80007374:	7b 40 00 5f 	movh %d5,61444
80007378:	1b 05 00 59 	addi %d5,%d5,-28672
8000737c:	82 0f       	mov %d15,0
/* Signal the core "cpu" (0/1/2/3/4/6) by sending an IIRQ. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_signal_core(CoreIdType core_id)
{

  OSEE_TC_SRC_REG(OSEE_TC_GPSR_SRC_OFFSET(OSEE_TC_GPSR_G, core_id)) |=
8000737e:	02 56       	mov %d6,%d5
80007380:	8f ff 0f 21 	and %d2,%d15,255
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80007384:	4d c0 e1 3f 	mfcr %d3,$core_id

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
        if (i != (CoreNumType)osEE_get_curr_core_id()) {
80007388:	8f f3 0f 31 	and %d3,%d3,255
8000738c:	5f 32 0f 00 	jeq %d2,%d3,800073aa <ShutdownAllCores+0xb0>
          if ((p_kcb->ar_core_mask & ((CoreMaskType)1U << i)) != 0U) {
80007390:	54 23       	ld.w %d3,[%a2]
80007392:	57 03 61 3f 	extr.u %d3,%d3,%d15,1
80007396:	76 3a       	jz %d3,800073aa <ShutdownAllCores+0xb0>
80007398:	8b 32 60 22 	lt.u %d2,%d2,3
8000739c:	2b 65 40 22 	sel %d2,%d2,%d5,%d6
800073a0:	60 2f       	mov.a %a15,%d2
800073a2:	48 02       	ld.w %d2,[%a15]0
800073a4:	b7 f2 01 2d 	insert %d2,%d2,15,26,1
800073a8:	68 02       	st.w [%a15]0,%d2
800073aa:	c2 1f       	add %d15,1
800073ac:	c2 45       	add %d5,4
      /* Save the Error parameter to be used in all other cores */
      p_kcb->ar_shutdown_all_cores_error = Error;
      /* Set ShutdownAllCores global flag */
      p_kcb->ar_shutdown_all_cores_flag = OSEE_TRUE;

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
800073ae:	df 3f e9 ff 	jne %d15,3,80007380 <ShutdownAllCores+0x86>
 *  \brief Unlocks the kernel.
 *  
 *  Unlock the kernel by releasing the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_unlock_kernel(void) {
  osEE_hal_spin_unlock(osEE_kdb_var.p_lock);
800073b2:	91 00 00 f8 	movh.a %a15,32768
800073b6:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
800073ba:	c8 1f       	ld.a %a15,[%a15]4
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
800073bc:	0d 00 80 04 	dsync 
800073c0:	82 0f       	mov %d15,0
800073c2:	68 0f       	st.w [%a15]0,%d15

      /* Release the kernel spinlock */
      osEE_unlock_kernel();
      /* After signaling the shutdown all cores status: shut this core down:
         This won't never return */
      osEE_shutdown_os(osEE_get_curr_core(), Error);
800073c4:	40 94       	mov.aa %a4,%a9
800073c6:	1d ff db f1 	j 8000577c <osEE_shutdown_os>
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
800073ca:	3b c0 04 20 	mov %d2,76
800073ce:	e9 f2 13 00 	st.b [%a15]19,%d2
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800073d2:	82 02       	mov %d2,0
800073d4:	e9 f2 23 00 	st.b [%a15]35,%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800073d8:	4d c0 e2 2f 	mfcr %d2,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
800073dc:	5f f2 06 00 	jeq %d2,%d15,800073e8 <ShutdownAllCores+0xee>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800073e0:	cd cf e2 0f 	mtcr $icr,%d15
800073e4:	0d 00 c0 04 	isync 
800073e8:	00 90       	ret 
	...

800073ec <osEE_scheduler_task_wrapper_restore>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_restore
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
800073ec:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
800073ee:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
#endif /* OSEE_HAS_PRETASKHOOK || OSEE_SCHEDULER_GLOBAL || OSEE_HAS_CONTEXT ||
          OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */
#if (defined(OSEE_HAS_PRETASKHOOK)) || (defined(OSEE_SCHEDULER_GLOBAL)) ||\
    (defined(OSEE_HAS_CONTEXT)) || (defined(OSEE_HAS_ORTI))
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
800073f0:	c8 3f       	ld.a %a15,[%a15]12
          OSEE_HAS_ORTI */
#if (defined(OSEE_HAS_STACK_MONITORING))
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_STACK_MONITORING */
#if (defined(OSEE_HAS_ORTI))
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800073f2:	39 ff 23 00 	ld.bu %d15,[%a15]35
800073f6:	5e 1a       	jne %d15,1,8000740a <osEE_scheduler_task_wrapper_restore+0x1e>
/* Reset last bit of service_id to mark OS service exit */
    p_ccb->service_id = (OSServiceIdType)
800073f8:	39 ff 13 00 	ld.bu %d15,[%a15]19
800073fc:	8f 1f c0 f1 	andn %d15,%d15,1
80007400:	e9 ff 13 00 	st.b [%a15]19,%d15
      (((OsEE_reg)p_ccb->service_id) & (~((OsEE_reg)0x1U)));

    p_ccb->orti_service_id_valid = OSEE_FALSE;
80007404:	82 0f       	mov %d15,0
80007406:	e9 ff 23 00 	st.b [%a15]35,%d15
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000740a:	99 42 0c 00 	ld.a %a2,[%a4]12
8000740e:	82 4f       	mov %d15,4
80007410:	2c 22       	st.b [%a2]2,%d15

  /* Call PreTaskHook only if I'm scheduling a real TASK not an ISR2 or the
   * Idle TASK */
#if (defined(OSEE_HAS_PRETASKHOOK)) || (defined(OSEE_HAS_CONTEXT))
  if (p_tdb_to->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80007412:	39 4f 14 00 	ld.bu %d15,[%a4]20
80007416:	ff 2f 06 80 	jge.u %d15,2,80007422 <osEE_scheduler_task_wrapper_restore+0x36>
      p_ccb->p_last_tdb_hook = p_tdb_to;
      osEE_call_pre_task_hook(p_ccb);
    }
#endif /* OSEE_HAS_PRETASKHOOK */
#if (defined(OSEE_HAS_CONTEXT))
    p_ccb->os_context = OSEE_TASK_CTX;
8000741a:	82 2f       	mov %d15,2
8000741c:	e9 ff 14 00 	st.b [%a15]20,%d15
80007420:	00 90       	ret 
#endif /* OSEE_HAS_CONTEXT */
  }
#if (defined(OSEE_HAS_CONTEXT))
  else if (p_tdb_to->task_type == OSEE_TASK_TYPE_ISR2) {
80007422:	5e 25       	jne %d15,2,8000742c <osEE_scheduler_task_wrapper_restore+0x40>
    p_ccb->os_context = OSEE_TASK_ISR2_CTX;
80007424:	82 3f       	mov %d15,3
80007426:	e9 ff 14 00 	st.b [%a15]20,%d15
8000742a:	00 90       	ret 
  } else {
    p_ccb->os_context = OSEE_IDLE_CTX;
8000742c:	82 1f       	mov %d15,1
8000742e:	e9 ff 14 00 	st.b [%a15]20,%d15
80007432:	00 90       	ret 

80007434 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
80007434:	40 ae       	mov.aa %a14,%sp
80007436:	40 4c       	mov.aa %a12,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
80007438:	cc 43       	ld.a %a15,[%a4]12
8000743a:	08 18       	ld.bu %d8,[%a15]1
  osEE_scheduler_task_wrapper_restore(p_tdb_to);
8000743c:	6d ff d8 ff 	call 800073ec <osEE_scheduler_task_wrapper_restore>

  if (task_priority < OSEE_ISR_ALL_PRIO) {
80007440:	8b f8 0f f2 	eq %d15,%d8,255
80007444:	ee 13       	jnz %d15,8000746a <osEE_scheduler_task_wrapper_run+0x36>
80007446:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
8000744a:	37 08 48 30 	extr %d3,%d8,0,8
8000744e:	82 02       	mov %d2,0
80007450:	ce 35       	jgez %d3,8000745a <osEE_scheduler_task_wrapper_run+0x26>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
80007452:	8f f8 07 81 	and %d8,%d8,127
80007456:	1b 18 00 20 	addi %d2,%d8,1
8000745a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000745e:	cd cf e2 0f 	mtcr $icr,%d15
80007462:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80007466:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000746a:	cc c6       	ld.a %a15,[%a12]24
8000746c:	2d 0f 00 00 	calli %a15
80007470:	40 9f       	mov.aa %a15,%a9
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
80007472:	c8 3f       	ld.a %a15,[%a15]12

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
80007474:	82 0f       	mov %d15,0
80007476:	e9 ff 21 00 	st.b [%a15]33,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000747a:	39 ff 20 00 	ld.bu %d15,[%a15]32
8000747e:	6e 09       	jz %d15,80007490 <osEE_scheduler_task_wrapper_run+0x5c>
    p_ccb->s_isr_all_cnt = 0U;
80007480:	82 0f       	mov %d15,0
80007482:	e9 ff 20 00 	st.b [%a15]32,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007486:	4c f6       	ld.w %d15,[%a15]24
80007488:	cd cf e2 0f 	mtcr $icr,%d15
8000748c:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
80007490:	39 ff 22 00 	ld.bu %d15,[%a15]34
80007494:	6e 06       	jz %d15,800074a0 <osEE_scheduler_task_wrapper_run+0x6c>
    p_ccb->d_isr_all_cnt = 0U;
80007496:	82 0f       	mov %d15,0
80007498:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000749c:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800074a0:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800074a4:	8f ff 0f 21 	and %d2,%d15,255
800074a8:	ff 22 08 80 	jge.u %d2,2,800074b8 <osEE_scheduler_task_wrapper_run+0x84>
800074ac:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800074b0:	cd cf e2 0f 	mtcr $icr,%d15
800074b4:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
800074b8:	39 cf 14 00 	ld.bu %d15,[%a12]20
800074bc:	9e 20       	jeq %d15,2,800074dc <osEE_scheduler_task_wrapper_run+0xa8>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
800074be:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
800074c2:	1e 4d       	jeq %d15,4,800074dc <osEE_scheduler_task_wrapper_run+0xa8>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
800074c4:	82 42       	mov %d2,4
800074c6:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
800074ca:	3b b0 00 20 	mov %d2,11
800074ce:	e9 f2 12 00 	st.b [%a15]18,%d2
    ErrorHook(Error);
800074d2:	02 24       	mov %d4,%d2
800074d4:	6d ff 33 e7 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
800074d8:	e9 ff 14 00 	st.b [%a15]20,%d15
800074dc:	99 c4 04 00 	ld.a %a4,[%a12]4
800074e0:	a0 05       	mov.a %a5,0
800074e2:	1d 00 a6 08 	j 8000862e <osEE_hal_terminate_ctx>

800074e6 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
800074e6:	40 ae       	mov.aa %a14,%sp
800074e8:	40 9c       	mov.aa %a12,%a9
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800074ea:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800074ee:	8f f8 0f f1 	and %d15,%d8,255
800074f2:	ff 2f 09 80 	jge.u %d15,2,80007504 <osEE_idle_hook_wrapper+0x1e>
    OsEE_icr icr_temp = icr;
800074f6:	02 8f       	mov %d15,%d8
800074f8:	b7 2f 08 f0 	insert %d15,%d15,2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800074fc:	cd cf e2 0f 	mtcr $icr,%d15
80007500:	0d 00 c0 04 	isync 
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
#if (defined(OSEE_HAS_AUTOSTART_TASK))
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
80007504:	91 00 00 48 	movh.a %a4,32768
80007508:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
8000750c:	6d 00 82 02 	call 80007a10 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80007510:	4d c0 e2 ff 	mfcr %d15,$icr
 * within an IRQ or a task. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr icr = osEE_tc_get_icr();
  if (icr.reg != flags) {
80007514:	3e 85       	jeq %d15,%d8,8000751e <osEE_idle_hook_wrapper+0x38>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80007516:	cd c8 e2 0f 	mtcr $icr,%d8
8000751a:	0d 00 c0 04 	isync 
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000751e:	cc c3       	ld.a %a15,[%a12]12
80007520:	39 ff 10 00 	ld.bu %d15,[%a15]16 <f0030003 <_SMALL_DATA4_+0x40028003>>
80007524:	df 2f fe 7f 	jeq %d15,2,80007520 <osEE_idle_hook_wrapper+0x3a>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
80007528:	99 c4 14 00 	ld.a %a4,[%a12]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
8000752c:	6d 00 02 07 	call 80008330 <osEE_idle_task_terminate>
80007530:	00 90       	ret 

80007532 <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
80007532:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80007534:	99 43 0c 00 	ld.a %a3,[%a4]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
80007538:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_ret_sn = p_ccb->p_stk_sn;
8000753a:	99 32 0c 00 	ld.a %a2,[%a3]12

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000753e:	bd 02 13 00 	jz.a %a2,80007564 <osEE_scheduler_core_rq_preempt_stk+0x32>
    p_ret_tdb = p_ret_sn->p_tdb;
80007542:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
80007546:	bd 0f 1b 00 	jz.a %a15,8000757c <osEE_scheduler_core_rq_preempt_stk+0x4a>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000754a:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000754e:	c8 16       	ld.a %a6,[%a15]4
80007550:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
80007554:	39 42 01 00 	ld.bu %d2,[%a4]1
80007558:	0c 61       	ld.bu %d15,[%a6]1
8000755a:	7f f2 13 80 	jge.u %d2,%d15,80007580 <osEE_scheduler_core_rq_preempt_stk+0x4e>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
8000755e:	82 2f       	mov %d15,2
80007560:	2c 42       	st.b [%a4]2,%d15
80007562:	3c 11       	j 80007584 <osEE_scheduler_core_rq_preempt_stk+0x52>
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
80007564:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
80007566:	bd 0f 1e 00 	jz.a %a15,800075a2 <osEE_scheduler_core_rq_preempt_stk+0x70>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
8000756a:	99 42 14 00 	ld.a %a2,[%a4]20
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000756e:	99 24 0c 00 	ld.a %a4,[%a2]12
80007572:	82 2f       	mov %d15,2
80007574:	2c 42       	st.b [%a4]2,%d15
80007576:	3c 07       	j 80007584 <osEE_scheduler_core_rq_preempt_stk+0x52>
  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
    if (p_tcb->current_prio < dispatch_prio) {
      p_tcb->current_prio = dispatch_prio;
80007578:	2c 51       	st.b [%a5]1,%d15
8000757a:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000757c:	a0 02       	mov.a %a2,0
8000757e:	00 90       	ret 
80007580:	a0 02       	mov.a %a2,0
80007582:	00 90       	ret 
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
80007584:	4c f0       	ld.w %d15,[%a15]0
80007586:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
80007588:	c8 14       	ld.a %a4,[%a15]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000758a:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000758e:	4c 33       	ld.w %d15,[%a3]12
80007590:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
80007592:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
80007594:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
80007596:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000759a:	39 52 01 00 	ld.bu %d2,[%a5]1
8000759e:	3f f2 ed ff 	jlt.u %d2,%d15,80007578 <osEE_scheduler_core_rq_preempt_stk+0x46>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
800075a2:	00 90       	ret 

800075a4 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
800075a4:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
800075a6:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
800075a8:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
800075aa:	76 44       	jz %d4,800075b2 <osEE_sn_priority_insert+0xe>
800075ac:	39 f2 1c 00 	ld.bu %d2,[%a15]28
800075b0:	3c 03       	j 800075b6 <osEE_sn_priority_insert+0x12>
800075b2:	39 22 01 00 	ld.bu %d2,[%a2]1
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
800075b6:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
800075b8:	a0 06       	mov.a %a6,0
800075ba:	7c f3       	jnz.a %a15,800075c0 <osEE_sn_priority_insert+0x1c>
800075bc:	3c 14       	j 800075e4 <osEE_sn_priority_insert+0x40>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
800075be:	60 ff       	mov.a %a15,%d15
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
800075c0:	c8 12       	ld.a %a2,[%a15]4
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
800075c2:	99 23 0c 00 	ld.a %a3,[%a2]12

    if (as_ready) {
800075c6:	76 44       	jz %d4,800075ce <osEE_sn_priority_insert+0x2a>
      prio_to_check = p_cur_tdb->ready_prio;
800075c8:	39 2f 1c 00 	ld.bu %d15,[%a2]28
800075cc:	3c 02       	j 800075d0 <osEE_sn_priority_insert+0x2c>
    } else {
      prio_to_check = p_cur_tcb->current_prio;
800075ce:	0c 31       	ld.bu %d15,[%a3]1
    }

    if (new_task_prio <= prio_to_check)
800075d0:	3f 2f 06 80 	jlt.u %d15,%d2,800075dc <osEE_sn_priority_insert+0x38>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
800075d4:	4c f0       	ld.w %d15,[%a15]0
800075d6:	40 f6       	mov.aa %a6,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
800075d8:	ee f3       	jnz %d15,800075be <osEE_sn_priority_insert+0x1a>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
800075da:	60 ff       	mov.a %a15,%d15
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
800075dc:	bc 64       	jz.a %a6,800075e4 <osEE_sn_priority_insert+0x40>
    p_prev->p_next = p_sn_new;
800075de:	f4 65       	st.a [%a6],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
800075e0:	82 02       	mov %d2,0
800075e2:	3c 03       	j 800075e8 <osEE_sn_priority_insert+0x44>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
800075e4:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
800075e6:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
800075e8:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
800075ea:	00 90       	ret 

800075ec <osEE_scheduler_rq_insert>:
(
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
800075ec:	40 ae       	mov.aa %a14,%sp
  p_sn_new->p_tdb = p_tdb_new;
800075ee:	b5 56 04 00 	st.a [%a5]4,%a6

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
800075f2:	82 14       	mov %d4,1
800075f4:	6d ff d8 ff 	call 800075a4 <osEE_sn_priority_insert>
#else
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_FALSE);
#endif /* !OSEE_SCHEDULER_GLOBAL */
}
800075f8:	00 90       	ret 

800075fa <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
800075fa:	40 ae       	mov.aa %a14,%sp
800075fc:	40 4d       	mov.aa %a13,%a4
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
800075fe:	cc 43       	ld.a %a15,[%a4]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
80007600:	c8 3c       	ld.a %a12,[%a15]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
80007602:	54 c3       	ld.w %d3,[%a12]
80007604:	68 33       	st.w [%a15]12,%d3
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
80007606:	6d ff 96 ff 	call 80007532 <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
8000760a:	4c f3       	ld.w %d15,[%a15]12

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
8000760c:	7c 29       	jnz.a %a2,8000761e <osEE_scheduler_core_pop_running+0x24>
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
8000760e:	80 d3       	mov.d %d3,%a13
80007610:	1b 43 01 20 	addi %d2,%d3,20
80007614:	92 43       	add %d3,%d15,4
80007616:	6a 23       	cmovn %d3,%d15,%d2
80007618:	60 3d       	mov.a %a13,%d3
8000761a:	4c d0       	ld.w %d15,[%a13]0
8000761c:	68 0f       	st.w [%a15]0,%d15
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
8000761e:	40 c2       	mov.aa %a2,%a12
80007620:	00 90       	ret 

80007622 <osEE_task_activated>:

FUNC(StatusType, OS_CODE) osEE_task_activated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80007622:	40 ae       	mov.aa %a14,%sp
80007624:	40 4c       	mov.aa %a12,%a4
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
80007626:	99 4d 0c 00 	ld.a %a13,[%a4]12
 *  \return The function returns a pointer to the CDB pointer
 */
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE
  osEE_lock_and_get_core(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000762a:	39 44 1f 00 	ld.bu %d4,[%a4]31
8000762e:	6d 00 5c 07 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
80007632:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007634:	82 18       	mov %d8,1
80007636:	82 09       	mov %d9,0
80007638:	0b 89 10 28 	mov %e2,%d9,%d8
8000763c:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007640:	df 02 fa ff 	jne %d2,0,80007634 <osEE_task_activated+0x12>
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
80007644:	0c d0       	ld.bu %d15,[%a13]0
80007646:	39 c3 1e 00 	ld.bu %d3,[%a12]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
8000764a:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000764c:	7f 3f 05 80 	jge.u %d15,%d3,80007656 <osEE_task_activated+0x34>
    ++p_tcb_act->current_num_of_act;
80007650:	c2 1f       	add %d15,1
80007652:	2c d0       	st.b [%a13]0,%d15
    ev = E_OK;
80007654:	82 02       	mov %d2,0
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007656:	cc 24       	ld.a %a15,[%a2]16
80007658:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000765c:	82 0f       	mov %d15,0
8000765e:	68 0f       	st.w [%a15]0,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
80007660:	00 90       	ret 

80007662 <osEE_task_end>:
FUNC(void, OS_CODE)
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
80007662:	40 ae       	mov.aa %a14,%sp
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
80007664:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
80007666:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000766a:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
8000766c:	0c f0       	ld.bu %d15,[%a15]0
8000766e:	c2 ff       	add %d15,-1
80007670:	16 ff       	and %d15,255
80007672:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
80007674:	ee 03       	jnz %d15,8000767a <osEE_task_end+0x18>
    p_tcb->status = OSEE_TASK_SUSPENDED;
80007676:	28 2f       	st.b [%a15]2,%d15
80007678:	00 90       	ret 
  } else {
    p_tcb->status = OSEE_TASK_READY;
8000767a:	82 1f       	mov %d15,1
8000767c:	28 2f       	st.b [%a15]2,%d15
8000767e:	00 90       	ret 

80007680 <osEE_task_event_set_mask>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)    p_tdb_waking_up,
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev  
)
{
80007680:	40 ae       	mov.aa %a14,%sp
80007682:	40 4d       	mov.aa %a13,%a4
80007684:	02 4a       	mov %d10,%d4
80007686:	80 5b       	mov.d %d11,%a5
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
80007688:	99 4c 0c 00 	ld.a %a12,[%a4]12
 *  \return The function returns a pointer to the CDB pointer
 */
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE
  osEE_lock_and_get_core(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000768c:	39 44 1f 00 	ld.bu %d4,[%a4]31
80007690:	6d 00 2b 07 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
80007694:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007696:	82 18       	mov %d8,1
80007698:	82 09       	mov %d9,0
8000769a:	0b 89 10 28 	mov %e2,%d9,%d8
8000769e:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
800076a2:	df 02 fa ff 	jne %d2,0,80007696 <osEE_task_event_set_mask+0x16>
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

#if (defined(OSEE_HAS_CHECKS))
  if (p_tdb_waking_up->task_type != OSEE_TASK_TYPE_EXTENDED) {
800076a6:	39 df 14 00 	ld.bu %d15,[%a13]20
800076aa:	1e 16       	jeq %d15,1,800076b6 <osEE_task_event_set_mask+0x36>
    *p_ev = E_OS_ACCESS;
800076ac:	82 1f       	mov %d15,1
800076ae:	60 bf       	mov.a %a15,%d11
800076b0:	28 0f       	st.b [%a15]0,%d15
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev  
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
800076b2:	a0 0f       	mov.a %a15,0
800076b4:	3c 17       	j 800076e2 <osEE_task_event_set_mask+0x62>

#if (defined(OSEE_HAS_CHECKS))
  if (p_tdb_waking_up->task_type != OSEE_TASK_TYPE_EXTENDED) {
    *p_ev = E_OS_ACCESS;
  } else
  if (p_tcb_waking_up->status == OSEE_TASK_SUSPENDED) {
800076b6:	0c c2       	ld.bu %d15,[%a12]2
800076b8:	ee 06       	jnz %d15,800076c4 <osEE_task_event_set_mask+0x44>
    *p_ev = E_OS_STATE;
800076ba:	82 7f       	mov %d15,7
800076bc:	60 bf       	mov.a %a15,%d11
800076be:	28 0f       	st.b [%a15]0,%d15
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev  
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
800076c0:	a0 0f       	mov.a %a15,0
800076c2:	3c 10       	j 800076e2 <osEE_task_event_set_mask+0x62>
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
800076c4:	02 ac       	mov %d12,%d10
800076c6:	02 ad       	mov %d13,%d10
800076c8:	49 cc 48 08 	ldmst [%a12]8,%e12

    *p_ev = E_OK;
800076cc:	82 0f       	mov %d15,0
800076ce:	60 bf       	mov.a %a15,%d11
800076d0:	28 0f       	st.b [%a15]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
800076d2:	4c c1       	ld.w %d15,[%a12]4
800076d4:	26 fa       	and %d10,%d15
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev  
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
800076d6:	a0 0f       	mov.a %a15,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
800076d8:	76 a5       	jz %d10,800076e2 <osEE_task_event_set_mask+0x62>
      p_own_sn = p_tcb_waking_up->p_own_sn;
800076da:	cc c3       	ld.a %a15,[%a12]12

      if (p_own_sn != NULL) {
800076dc:	bc f3       	jz.a %a15,800076e2 <osEE_task_event_set_mask+0x62>
        p_tcb_waking_up->p_own_sn = NULL;
800076de:	82 0f       	mov %d15,0
800076e0:	6c c3       	st.w [%a12]12,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
800076e2:	99 22 10 00 	ld.a %a2,[%a2]16
800076e6:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
800076ea:	82 0f       	mov %d15,0
800076ec:	6c 20       	st.w [%a2]0,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
800076ee:	40 f2       	mov.aa %a2,%a15
800076f0:	00 90       	ret 

800076f2 <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
800076f2:	40 ae       	mov.aa %a14,%sp
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
800076f4:	91 00 00 48 	movh.a %a4,32768
800076f8:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
800076fc:	cc 43       	ld.a %a15,[%a4]12
800076fe:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80007702:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated */
    ++p_act_tdb->p_tcb->current_num_of_act;
80007704:	cc 53       	ld.a %a15,[%a5]12
80007706:	0c f0       	ld.bu %d15,[%a15]0
80007708:	c2 1f       	add %d15,1
8000770a:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000770c:	a0 06       	mov.a %a6,0
8000770e:	6d 00 a0 01 	call 80007a4e <osEE_scheduler_task_set_running>
80007712:	00 90       	ret 

80007714 <osEE_scheduler_task_insert_rq>:
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act,
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb_act
)
{
80007714:	40 ae       	mov.aa %a14,%sp
80007716:	40 5f       	mov.aa %a15,%a5
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
80007718:	0c 62       	ld.bu %d15,[%a6]2
8000771a:	ee 05       	jnz %d15,80007724 <osEE_scheduler_task_insert_rq+0x10>
    p_tcb_act->status = OSEE_TASK_READY;
8000771c:	82 1f       	mov %d15,1
8000771e:	2c 62       	st.b [%a6]2,%d15
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
80007720:	82 0f       	mov %d15,0
80007722:	6c 62       	st.w [%a6]8,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80007724:	99 45 08 00 	ld.a %a5,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
80007728:	4c 50       	ld.w %d15,[%a5]0
8000772a:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
8000772c:	82 0f       	mov %d15,0
8000772e:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80007730:	b0 44       	add.a %a4,4
80007732:	40 f6       	mov.aa %a6,%a15
80007734:	6d ff 5c ff 	call 800075ec <osEE_scheduler_rq_insert>
    osEE_sn_alloc(&p_ccb->p_free_sn), p_tdb_act);

  return rq_head_changed;
}
80007738:	00 90       	ret 

8000773a <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000773a:	40 ae       	mov.aa %a14,%sp
8000773c:	40 5c       	mov.aa %a12,%a5
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
8000773e:	19 5a 0c 00 	ld.w %d10,[%a5]12
#if (defined(OSEE_SINGLECORE))
  /* Touch unused parameter */
  (void)p_tdb;
  return osEE_get_curr_core();
#else
  return osEE_get_core(p_tdb->orig_core_id);
80007742:	39 54 1f 00 	ld.bu %d4,[%a5]31
80007746:	6d 00 d0 06 	call 800084e6 <osEE_get_core>
8000774a:	40 2d       	mov.aa %a13,%a2
{
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000774c:	99 24 0c 00 	ld.a %a4,[%a2]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
80007750:	d4 42       	ld.a %a2,[%a4]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
80007752:	99 23 0c 00 	ld.a %a3,[%a2]12
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007756:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007758:	82 18       	mov %d8,1
8000775a:	82 09       	mov %d9,0
8000775c:	0b 89 10 28 	mov %e2,%d9,%d8
80007760:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007764:	df 02 fa ff 	jne %d2,0,80007758 <osEE_scheduler_task_activated+0x1e>
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80007768:	4d c0 e1 2f 	mfcr %d2,$core_id
  osEE_lock_core(p_cdb);

#if (!defined(OSEE_SINGLECORE))
  /* Check if this is a remote activation */
  curr_core_id = osEE_get_curr_core_id();
  if (p_tdb_act->orig_core_id != curr_core_id) {
8000776c:	39 cf 1f 00 	ld.bu %d15,[%a12]31
80007770:	8f f2 0f 21 	and %d2,%d2,255
80007774:	5f 2f 21 00 	jeq %d15,%d2,800077b6 <osEE_scheduler_task_activated+0x7c>
    CONST(OsEE_bool, AUTOMATIC) rq_head_changed =
80007778:	40 c5       	mov.aa %a5,%a12
8000777a:	60 a6       	mov.a %a6,%d10
8000777c:	5c cc       	call 80007714 <osEE_scheduler_task_insert_rq>
8000777e:	02 2f       	mov %d15,%d2
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007780:	cc d4       	ld.a %a15,[%a13]16
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80007782:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007786:	82 02       	mov %d2,0
80007788:	68 02       	st.w [%a15]0,%d2
      osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    if (rq_head_changed) {
8000778a:	6e 40       	jz %d15,8000780a <osEE_scheduler_task_activated+0xd0>
      /* if RQ Head is changed, signal the remote core, it needs to
         reschedule */
      osEE_hal_signal_core(p_tdb_act->orig_core_id);
8000778c:	39 cf 1f 00 	ld.bu %d15,[%a12]31
80007790:	91 40 00 ff 	movh.a %a15,61444
80007794:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
80007798:	ff 3f 09 80 	jge.u %d15,3,800077aa <osEE_scheduler_task_activated+0x70>
8000779c:	60 f2       	mov.a %a2,%d15
8000779e:	d9 2f 40 0e 	lea %a15,[%a2]-7168
800077a2:	11 1f c0 f3 	addih.a %a15,%a15,15361
800077a6:	30 ff       	add.a %a15,%a15
800077a8:	30 ff       	add.a %a15,%a15
800077aa:	4c f0       	ld.w %d15,[%a15]0
800077ac:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
800077b0:	68 0f       	st.w [%a15]0,%d15
    }
    is_preemption = OSEE_FALSE;
800077b2:	82 02       	mov %d2,0
800077b4:	00 90       	ret 
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
800077b6:	39 32 01 00 	ld.bu %d2,[%a3]1
800077ba:	60 af       	mov.a %a15,%d10
800077bc:	0c f1       	ld.bu %d15,[%a15]1
800077be:	7f f2 1d 80 	jge.u %d2,%d15,800077f8 <osEE_scheduler_task_activated+0xbe>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
800077c2:	cc 42       	ld.a %a15,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
800077c4:	48 02       	ld.w %d2,[%a15]0
800077c6:	59 42 08 00 	st.w [%a4]8,%d2
  p_sn_allocated->p_next  = NULL;
800077ca:	82 0f       	mov %d15,0
800077cc:	68 0f       	st.w [%a15]0,%d15
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
800077ce:	82 22       	mov %d2,2
800077d0:	e9 32 02 00 	st.b [%a3]2,%d2

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
800077d4:	e8 1c       	st.a [%a15]4,%a12
    p_new_stk->p_next           = p_ccb->p_stk_sn;
800077d6:	19 43 0c 00 	ld.w %d3,[%a4]12
800077da:	68 03       	st.w [%a15]0,%d3
    p_ccb->p_stk_sn             = p_new_stk;
800077dc:	ec 43       	st.a [%a4]12,%a15
    p_ccb->p_curr               = p_tdb_act;
800077de:	f4 4c       	st.a [%a4],%a12
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
800077e0:	cc c3       	ld.a %a15,[%a12]12
800077e2:	68 2f       	st.w [%a15]8,%d15
800077e4:	cc d4       	ld.a %a15,[%a13]16
800077e6:	0d 00 80 04 	dsync 
800077ea:	68 0f       	st.w [%a15]0,%d15

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
800077ec:	40 24       	mov.aa %a4,%a2
800077ee:	40 c5       	mov.aa %a5,%a12
800077f0:	6d 00 7c 05 	call 800082e8 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
800077f4:	82 12       	mov %d2,1
800077f6:	00 90       	ret 
  } else {
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
800077f8:	40 c5       	mov.aa %a5,%a12
800077fa:	60 a6       	mov.a %a6,%d10
800077fc:	5c 8c       	call 80007714 <osEE_scheduler_task_insert_rq>
800077fe:	cc d4       	ld.a %a15,[%a13]16
80007800:	0d 00 80 04 	dsync 
80007804:	82 0f       	mov %d15,0
80007806:	68 0f       	st.w [%a15]0,%d15
    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
80007808:	82 02       	mov %d2,0
  }

  return is_preemption;
}
8000780a:	00 90       	ret 

8000780c <osEE_scheduler_task_insert>:
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000780c:	40 ae       	mov.aa %a14,%sp
8000780e:	40 5c       	mov.aa %a12,%a5
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
80007810:	19 5a 0c 00 	ld.w %d10,[%a5]12
#if (defined(OSEE_SINGLECORE))
  /* Touch unused parameter */
  (void)p_tdb;
  return osEE_get_curr_core();
#else
  return osEE_get_core(p_tdb->orig_core_id);
80007814:	39 54 1f 00 	ld.bu %d4,[%a5]31
80007818:	6d 00 67 06 	call 800084e6 <osEE_get_core>
8000781c:	40 2d       	mov.aa %a13,%a2
{
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000781e:	99 24 0c 00 	ld.a %a4,[%a2]12
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007822:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007824:	82 18       	mov %d8,1
80007826:	82 09       	mov %d9,0
80007828:	0b 89 10 28 	mov %e2,%d9,%d8
8000782c:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007830:	df 02 fa ff 	jne %d2,0,80007824 <osEE_scheduler_task_insert+0x18>
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80007834:	4d c0 e1 2f 	mfcr %d2,$core_id
  osEE_lock_core(p_cdb);

#if (!defined(OSEE_SINGLECORE))
  /* Check if this is a remote activation */
  curr_core_id = osEE_get_curr_core_id();
  if (p_tdb_act->orig_core_id != curr_core_id) {
80007838:	39 cf 1f 00 	ld.bu %d15,[%a12]31
8000783c:	8f f2 0f 21 	and %d2,%d2,255
80007840:	be 2c       	jeq %d15,%d2,80007878 <osEE_scheduler_task_insert+0x6c>
    head_changed = osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
80007842:	40 c5       	mov.aa %a5,%a12
80007844:	60 a6       	mov.a %a6,%d10
80007846:	6d ff 67 ff 	call 80007714 <osEE_scheduler_task_insert_rq>
    if (head_changed) {
8000784a:	df 02 1b 00 	jeq %d2,0,80007880 <osEE_scheduler_task_insert+0x74>
      /* if RQ Head is changed, signal the remote core, it needs to
         reschedule */
      osEE_hal_signal_core(p_tdb_act->orig_core_id);
8000784e:	39 cf 1f 00 	ld.bu %d15,[%a12]31
80007852:	91 40 00 ff 	movh.a %a15,61444
80007856:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
8000785a:	ff 3f 09 80 	jge.u %d15,3,8000786c <osEE_scheduler_task_insert+0x60>
8000785e:	60 f2       	mov.a %a2,%d15
80007860:	d9 2f 40 0e 	lea %a15,[%a2]-7168
80007864:	11 1f c0 f3 	addih.a %a15,%a15,15361
80007868:	30 ff       	add.a %a15,%a15
8000786a:	30 ff       	add.a %a15,%a15
8000786c:	4c f0       	ld.w %d15,[%a15]0
8000786e:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80007872:	68 0f       	st.w [%a15]0,%d15
      head_changed = OSEE_FALSE;
80007874:	82 02       	mov %d2,0
80007876:	3c 05       	j 80007880 <osEE_scheduler_task_insert+0x74>
    }
  } else
#endif /* !OSEE_SINGLECORE */
  {
    /* Actually Insert the activated in READY Queue */
    head_changed  = osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
80007878:	40 c5       	mov.aa %a5,%a12
8000787a:	60 a6       	mov.a %a6,%d10
8000787c:	6d ff 4c ff 	call 80007714 <osEE_scheduler_task_insert_rq>
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007880:	cc d4       	ld.a %a15,[%a13]16
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80007882:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007886:	82 0f       	mov %d15,0
80007888:	68 0f       	st.w [%a15]0,%d15
  }

  osEE_unlock_core(p_cdb);

  return head_changed;
}
8000788a:	00 90       	ret 

8000788c <osEE_scheduler_task_block_current>:
  osEE_scheduler_task_block_current
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_SN *,  AUTOMATIC, OS_APPL_DATA)  p_sn_blocked
)
{
8000788c:	40 ae       	mov.aa %a14,%sp
8000788e:	80 58       	mov.d %d8,%a5
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007890:	40 9c       	mov.aa %a12,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
80007892:	99 cd 0c 00 	ld.a %a13,[%a12]12 <f003000c <_SMALL_DATA4_+0x4002800c>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_blocked = p_ccb->p_curr;
80007896:	54 d9       	ld.w %d9,[%a13]
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007898:	cc c4       	ld.a %a15,[%a12]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000789a:	82 12       	mov %d2,1
8000789c:	82 03       	mov %d3,0
8000789e:	0b 23 10 48 	mov %e4,%d3,%d2
800078a2:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
800078a6:	df 04 fa ff 	jne %d4,0,8000789a <osEE_scheduler_task_block_current+0xe>

  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);

  (*p_sn_blocked) = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
800078aa:	40 c4       	mov.aa %a4,%a12
800078ac:	d9 d5 04 00 	lea %a5,[%a13]4
800078b0:	6d ff a5 fe 	call 800075fa <osEE_scheduler_core_pop_running>
800078b4:	60 8f       	mov.a %a15,%d8
800078b6:	e8 02       	st.a [%a15]0,%a2

  p_tdb_blocked->p_tcb->status = OSEE_TASK_WAITING;
800078b8:	60 92       	mov.a %a2,%d9
800078ba:	cc 23       	ld.a %a15,[%a2]12
800078bc:	82 3f       	mov %d15,3
800078be:	28 2f       	st.b [%a15]2,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
800078c0:	cc c4       	ld.a %a15,[%a12]16
800078c2:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
800078c6:	82 0f       	mov %d15,0
800078c8:	68 0f       	st.w [%a15]0,%d15

  osEE_unlock_core(p_cdb);

  return p_ccb->p_curr;
}
800078ca:	d4 d2       	ld.a %a2,[%a13]
800078cc:	00 90       	ret 

800078ce <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
800078ce:	40 ae       	mov.aa %a14,%sp
800078d0:	80 5b       	mov.d %d11,%a5
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
800078d2:	99 5c 04 00 	ld.a %a12,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
800078d6:	19 ca 0c 00 	ld.w %d10,[%a12]12
#if (defined(OSEE_SINGLECORE))
  /* Touch unused parameter */
  (void)p_tdb;
  return osEE_get_curr_core();
#else
  return osEE_get_core(p_tdb->orig_core_id);
800078da:	39 c4 1f 00 	ld.bu %d4,[%a12]31
800078de:	6d 00 04 06 	call 800084e6 <osEE_get_core>
800078e2:	40 2d       	mov.aa %a13,%a2
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
800078e4:	19 2c 0c 00 	ld.w %d12,[%a2]12

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
800078e8:	82 2f       	mov %d15,2
800078ea:	60 a2       	mov.a %a2,%d10
800078ec:	2c 22       	st.b [%a2]2,%d15
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
800078ee:	39 cf 1c 00 	ld.bu %d15,[%a12]28
800078f2:	2c 21       	st.b [%a2]1,%d15
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
800078f4:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
800078f6:	82 18       	mov %d8,1
800078f8:	82 09       	mov %d9,0
800078fa:	0b 89 10 28 	mov %e2,%d9,%d8
800078fe:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007902:	df 02 fa ff 	jne %d2,0,800078f6 <osEE_scheduler_task_unblocked+0x28>
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80007906:	60 c4       	mov.a %a4,%d12
80007908:	b0 44       	add.a %a4,4
8000790a:	60 b5       	mov.a %a5,%d11
8000790c:	40 c6       	mov.aa %a6,%a12
8000790e:	6d ff 6f fe 	call 800075ec <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
80007912:	82 03       	mov %d3,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
80007914:	df 12 0a 80 	jne %d2,1,80007928 <osEE_scheduler_task_unblocked+0x5a>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
80007918:	60 c2       	mov.a %a2,%d12
8000791a:	cc 20       	ld.a %a15,[%a2]0
8000791c:	c8 3f       	ld.a %a15,[%a15]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
8000791e:	60 a2       	mov.a %a2,%d10
80007920:	0c 21       	ld.bu %d15,[%a2]1
80007922:	08 13       	ld.bu %d3,[%a15]1
80007924:	0b f3 30 31 	lt.u %d3,%d3,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007928:	cc d4       	ld.a %a15,[%a13]16
8000792a:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000792e:	82 0f       	mov %d15,0
80007930:	68 0f       	st.w [%a15]0,%d15

  osEE_unlock_core(p_cdb);

#if (!defined(OSEE_SINGLECORE))
  {
    CONST(CoreIdType, AUTOMATIC) tdb_core_id = p_tdb_released->orig_core_id;
80007932:	39 cf 1f 00 	ld.bu %d15,[%a12]31
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80007936:	4d c0 e1 2f 	mfcr %d2,$core_id
    /* Check if this is a remote release */
    if (tdb_core_id != osEE_get_curr_core_id()) {
8000793a:	8f f2 0f 21 	and %d2,%d2,255
      if (is_preemption) {
8000793e:	0b 2f 10 21 	ne %d2,%d15,%d2
80007942:	26 32       	and %d2,%d3
80007944:	df 02 13 00 	jeq %d2,0,8000796a <osEE_scheduler_task_unblocked+0x9c>
80007948:	91 40 00 ff 	movh.a %a15,61444
8000794c:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
80007950:	ff 3f 08 80 	jge.u %d15,3,80007960 <osEE_scheduler_task_unblocked+0x92>
80007954:	1b 0f 40 fe 	addi %d15,%d15,-7168
80007958:	9b 1f c0 f3 	addih %d15,%d15,15361
8000795c:	06 2f       	sh %d15,2
8000795e:	60 ff       	mov.a %a15,%d15
80007960:	4c f0       	ld.w %d15,[%a15]0
80007962:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80007966:	68 0f       	st.w [%a15]0,%d15
        osEE_hal_signal_core(tdb_core_id);
        /* If this is a remote release, it is not a preemption for this core */
        is_preemption = OSEE_FALSE;
80007968:	82 03       	mov %d3,0
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
8000796a:	02 32       	mov %d2,%d3
8000796c:	00 90       	ret 

8000796e <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
8000796e:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007970:	40 9d       	mov.aa %a13,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80007972:	99 dc 0c 00 	ld.a %a12,[%a13]12
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007976:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007978:	82 12       	mov %d2,1
8000797a:	82 03       	mov %d3,0
8000797c:	0b 23 10 48 	mov %e4,%d3,%d2
80007980:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007984:	df 04 fa ff 	jne %d4,0,80007978 <osEE_scheduler_task_terminated+0xa>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
80007988:	4c c0       	ld.w %d15,[%a12]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
8000798a:	60 f2       	mov.a %a2,%d15
8000798c:	cc 23       	ld.a %a15,[%a2]12

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
8000798e:	6c 50       	st.w [%a5]0,%d15

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
80007990:	08 22       	ld.bu %d2,[%a15]2
80007992:	df 42 18 80 	jne %d2,4,800079c2 <osEE_scheduler_task_terminated+0x54>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
80007996:	40 d4       	mov.aa %a4,%a13
80007998:	d9 c5 04 00 	lea %a5,[%a12]4
8000799c:	6d ff 2f fe 	call 800075fa <osEE_scheduler_core_pop_running>
800079a0:	80 29       	mov.d %d9,%a2

      p_tdb_to = p_ccb->p_curr;
800079a2:	54 c8       	ld.w %d8,[%a12]

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
800079a4:	3e 85       	jeq %d15,%d8,800079ae <osEE_scheduler_task_terminated+0x40>
        osEE_task_end(p_tdb_term);
800079a6:	60 f4       	mov.a %a4,%d15
800079a8:	6d ff 5d fe 	call 80007662 <osEE_task_end>
800079ac:	3c 04       	j 800079b4 <osEE_scheduler_task_terminated+0x46>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
800079ae:	0c f0       	ld.bu %d15,[%a15]0
800079b0:	c2 ff       	add %d15,-1
800079b2:	28 0f       	st.b [%a15]0,%d15
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
800079b4:	19 c2 08 00 	ld.w %d2,[%a12]8
800079b8:	60 92       	mov.a %a2,%d9
800079ba:	74 22       	st.w [%a2],%d2
  (*pp_first)       = p_to_free;
800079bc:	59 c9 08 00 	st.w [%a12]8,%d9
800079c0:	3c 21       	j 80007a02 <osEE_scheduler_task_terminated+0x94>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
800079c2:	99 c5 0c 00 	ld.a %a5,[%a12]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
800079c6:	54 52       	ld.w %d2,[%a5]
800079c8:	59 c2 0c 00 	st.w [%a12]12,%d2
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
800079cc:	60 f2       	mov.a %a2,%d15
800079ce:	39 22 1c 00 	ld.bu %d2,[%a2]28
800079d2:	28 12       	st.b [%a15]1,%d2
      p_tcb_term->status = OSEE_TASK_READY;
800079d4:	82 12       	mov %d2,1
800079d6:	28 22       	st.b [%a15]2,%d2
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
800079d8:	08 02       	ld.bu %d2,[%a15]0
800079da:	df 12 04 80 	jne %d2,1,800079e2 <osEE_scheduler_task_terminated+0x74>
800079de:	82 02       	mov %d2,0
800079e0:	68 22       	st.w [%a15]8,%d2
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
800079e2:	d9 cf 04 00 	lea %a15,[%a12]4
800079e6:	40 f4       	mov.aa %a4,%a15
800079e8:	60 f6       	mov.a %a6,%d15
800079ea:	6d ff 01 fe 	call 800075ec <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
800079ee:	40 d4       	mov.aa %a4,%a13
800079f0:	40 f5       	mov.aa %a5,%a15
800079f2:	6d ff a0 fd 	call 80007532 <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
800079f6:	7c 25       	jnz.a %a2,80007a00 <osEE_scheduler_task_terminated+0x92>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
800079f8:	cc c3       	ld.a %a15,[%a12]12
800079fa:	48 18       	ld.w %d8,[%a15]4
          p_ccb->p_curr           = p_tdb_to;
800079fc:	74 c8       	st.w [%a12],%d8
800079fe:	3c 02       	j 80007a02 <osEE_scheduler_task_terminated+0x94>
        } else {
          p_tdb_to = p_ccb->p_curr;
80007a00:	54 c8       	ld.w %d8,[%a12]
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007a02:	cc d4       	ld.a %a15,[%a13]16
  __asm__ volatile ("wait" : : : "memory");
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80007a04:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007a08:	82 0f       	mov %d15,0
80007a0a:	68 0f       	st.w [%a15]0,%d15
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
80007a0c:	60 82       	mov.a %a2,%d8
80007a0e:	00 90       	ret 

80007a10 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
80007a10:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007a12:	40 9c       	mov.aa %a12,%a9
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80007a14:	99 cd 0c 00 	ld.a %a13,[%a12]12
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007a18:	cc c4       	ld.a %a15,[%a12]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007a1a:	82 12       	mov %d2,1
80007a1c:	82 03       	mov %d3,0
80007a1e:	0b 23 10 48 	mov %e4,%d3,%d2
80007a22:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
80007a26:	02 4f       	mov %d15,%d4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007a28:	df 04 f9 ff 	jne %d4,0,80007a1a <osEE_scheduler_task_preemption_point+0xa>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
80007a2c:	40 c4       	mov.aa %a4,%a12
80007a2e:	d9 d5 04 00 	lea %a5,[%a13]4
80007a32:	6d ff 80 fd 	call 80007532 <osEE_scheduler_core_rq_preempt_stk>
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007a36:	cc c4       	ld.a %a15,[%a12]16
80007a38:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007a3c:	68 0f       	st.w [%a15]0,%d15

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
80007a3e:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
80007a40:	bc 26       	jz.a %a2,80007a4c <osEE_scheduler_task_preemption_point+0x3c>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
80007a42:	40 24       	mov.aa %a4,%a2
80007a44:	d4 d5       	ld.a %a5,[%a13]
80007a46:	6d 00 51 04 	call 800082e8 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
80007a4a:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
80007a4c:	00 90       	ret 

80007a4e <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
80007a4e:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007a50:	40 92       	mov.aa %a2,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80007a52:	cc 23       	ld.a %a15,[%a2]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
80007a54:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
80007a56:	48 34       	ld.w %d4,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
80007a58:	99 43 0c 00 	ld.a %a3,[%a4]12
80007a5c:	0c 32       	ld.bu %d15,[%a3]2
80007a5e:	5e 43       	jne %d15,4,80007a64 <osEE_scheduler_task_set_running+0x16>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
80007a60:	82 2f       	mov %d15,2
80007a62:	2c 32       	st.b [%a3]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
80007a64:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
80007a66:	bd 06 17 80 	jnz.a %a6,80007a94 <osEE_scheduler_task_set_running+0x46>
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007a6a:	99 23 10 00 	ld.a %a3,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007a6e:	82 12       	mov %d2,1
80007a70:	82 03       	mov %d3,0
80007a72:	0b 23 10 68 	mov %e6,%d3,%d2
80007a76:	49 36 c0 08 	cmpswap.w [%a3]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007a7a:	df 06 fa ff 	jne %d6,0,80007a6e <osEE_scheduler_task_set_running+0x20>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80007a7e:	c8 23       	ld.a %a3,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80007a80:	54 37       	ld.w %d7,[%a3]
80007a82:	68 27       	st.w [%a15]8,%d7
  p_sn_allocated->p_next  = NULL;
80007a84:	74 36       	st.w [%a3],%d6
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
80007a86:	e8 33       	st.a [%a15]12,%a3
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007a88:	99 22 10 00 	ld.a %a2,[%a2]16
80007a8c:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007a90:	74 26       	st.w [%a2],%d6
80007a92:	3c 02       	j 80007a96 <osEE_scheduler_task_set_running+0x48>
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
80007a94:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
80007a96:	c8 32       	ld.a %a2,[%a15]12
80007a98:	b5 25 04 00 	st.a [%a2]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
80007a9c:	c8 3f       	ld.a %a15,[%a15]12
80007a9e:	68 04       	st.w [%a15]0,%d4

  osEE_change_context_from_running(p_preempted, p_tdb);
80007aa0:	6d 00 24 04 	call 800082e8 <osEE_change_context_from_running>
80007aa4:	00 90       	ret 
	...

80007aa8 <osEE_counter_insert_abs_trigger>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       when
)
{
80007aa8:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
80007aaa:	d4 42       	ld.a %a2,[%a4]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
80007aac:	4c 20       	ld.w %d15,[%a2]0
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
80007aae:	19 25 04 00 	ld.w %d5,[%a2]4
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
80007ab2:	cc 50       	ld.a %a15,[%a5]0
80007ab4:	68 14       	st.w [%a15]4,%d4
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
80007ab6:	82 13       	mov %d3,1
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
80007ab8:	a0 03       	mov.a %a3,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
80007aba:	0b 45 50 61 	ge.u %d6,%d5,%d4
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
80007abe:	82 07       	mov %d7,0
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
80007ac0:	3c 17       	j 80007aee <osEE_counter_insert_abs_trigger+0x46>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
80007ac2:	60 f4       	mov.a %a4,%d15
80007ac4:	cc 40       	ld.a %a15,[%a4]0
80007ac6:	48 12       	ld.w %d2,[%a15]4

    if (current_when > counter_value) {
80007ac8:	7f 25 09 80 	jge.u %d5,%d2,80007ada <osEE_counter_insert_abs_trigger+0x32>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
80007acc:	02 60       	mov %d0,%d6
80007ace:	0b 24 c0 02 	or.ge.u %d0,%d4,%d2
80007ad2:	76 0b       	jz %d0,80007ae8 <osEE_counter_insert_abs_trigger+0x40>
80007ad4:	60 f3       	mov.a %a3,%d15
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
80007ad6:	4c f0       	ld.w %d15,[%a15]0
80007ad8:	3c 0b       	j 80007aee <osEE_counter_insert_abs_trigger+0x46>
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
80007ada:	0b 24 50 21 	ge.u %d2,%d4,%d2
80007ade:	26 62       	and %d2,%d6
80007ae0:	76 26       	jz %d2,80007aec <osEE_counter_insert_abs_trigger+0x44>
80007ae2:	60 f3       	mov.a %a3,%d15
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
80007ae4:	4c f0       	ld.w %d15,[%a15]0
80007ae6:	3c 04       	j 80007aee <osEE_counter_insert_abs_trigger+0x46>
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
80007ae8:	02 73       	mov %d3,%d7
80007aea:	3c 02       	j 80007aee <osEE_counter_insert_abs_trigger+0x46>
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
80007aec:	02 73       	mov %d3,%d7
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
80007aee:	8b 0f 20 22 	ne %d2,%d15,0
80007af2:	8b 03 20 24 	and.ne %d2,%d3,0
80007af6:	df 02 e6 ff 	jne %d2,0,80007ac2 <osEE_counter_insert_abs_trigger+0x1a>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
80007afa:	bc 34       	jz.a %a3,80007b02 <osEE_counter_insert_abs_trigger+0x5a>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
80007afc:	cc 30       	ld.a %a15,[%a3]0
80007afe:	e8 05       	st.a [%a15]0,%a5
80007b00:	3c 02       	j 80007b04 <osEE_counter_insert_abs_trigger+0x5c>
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
80007b02:	f4 25       	st.a [%a2],%a5
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
80007b04:	cc 50       	ld.a %a15,[%a5]0
80007b06:	68 0f       	st.w [%a15]0,%d15
80007b08:	00 90       	ret 

80007b0a <osEE_counter_insert_rel_trigger>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       delta
)
{
80007b0a:	40 ae       	mov.aa %a14,%sp
{
  VAR(TickType, AUTOMATIC) when;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
80007b0c:	19 42 04 00 	ld.w %d2,[%a4]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
80007b10:	cc 40       	ld.a %a15,[%a4]0
80007b12:	4c f1       	ld.w %d15,[%a15]4

  if ((maxallowedvalue - delta) >= value) {
80007b14:	0b 42 80 50 	sub %d5,%d2,%d4
80007b18:	46 02       	not %d2
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
80007b1a:	42 f2       	add %d2,%d15
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
80007b1c:	12 43       	add %d3,%d15,%d4
80007b1e:	42 24       	add %d4,%d2
80007b20:	0b f5 30 f1 	lt.u %d15,%d5,%d15
  osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
80007b24:	6a 34       	cmovn %d4,%d15,%d3
80007b26:	6d ff c1 ff 	call 80007aa8 <osEE_counter_insert_abs_trigger>
80007b2a:	00 90       	ret 

80007b2c <osEE_counter_cancel_trigger>:
  osEE_counter_cancel_trigger
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db
)
{
80007b2c:	40 ae       	mov.aa %a14,%sp
80007b2e:	80 53       	mov.d %d3,%a5
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
80007b30:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb  = p_trigger_db->p_trigger_cb;
80007b32:	d4 52       	ld.a %a2,[%a5]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
80007b34:	4c f0       	ld.w %d15,[%a15]0

  if (p_current == p_trigger_db) {
80007b36:	7e 34       	jne %d15,%d3,80007b3e <osEE_counter_cancel_trigger+0x12>
    /* The trigger to be removed is the first one in the queue */
    p_counter_cb->trigger_queue = p_trigger_cb->p_next;
80007b38:	4c 20       	ld.w %d15,[%a2]0
80007b3a:	68 0f       	st.w [%a15]0,%d15
80007b3c:	00 90       	ret 
  } else {
    P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_previous;
    do {
      p_previous = p_current;
      p_current  = p_current->p_trigger_cb->p_next;
80007b3e:	60 f3       	mov.a %a3,%d15
80007b40:	cc 30       	ld.a %a15,[%a3]0
80007b42:	4c f0       	ld.w %d15,[%a15]0
    } while ((p_current != NULL) && (p_current != p_trigger_db));
80007b44:	8b 0f 20 42 	ne %d4,%d15,0
80007b48:	0b 3f 10 21 	ne %d2,%d15,%d3
80007b4c:	8b 0f 20 24 	and.ne %d2,%d15,0
80007b50:	df 02 f7 ff 	jne %d2,0,80007b3e <osEE_counter_cancel_trigger+0x12>

    if (p_current != NULL) {
80007b54:	76 43       	jz %d4,80007b5a <osEE_counter_cancel_trigger+0x2e>
      /* Remove p_trigger_db from the list */
      p_previous->p_trigger_cb->p_next = p_trigger_cb->p_next;
80007b56:	4c 20       	ld.w %d15,[%a2]0
80007b58:	68 0f       	st.w [%a15]0,%d15
80007b5a:	00 90       	ret 

80007b5c <osEE_counter_increment>:
FUNC(void, OS_CODE)
  osEE_counter_increment
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
80007b5c:	40 ae       	mov.aa %a14,%sp
80007b5e:	20 18       	sub.a %sp,24
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb = p_counter_db->p_counter_cb;
80007b60:	d4 43       	ld.a %a3,[%a4]
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007b62:	40 95       	mov.aa %a5,%a9
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
80007b64:	19 34 04 00 	ld.w %d4,[%a3]4
80007b68:	4c 41       	ld.w %d15,[%a4]4
80007b6a:	3f f4 06 80 	jlt.u %d4,%d15,80007b76 <osEE_counter_increment+0x1a>
      counter_value       = 0U;
      p_counter_cb->value = 0U;
80007b6e:	82 0f       	mov %d15,0
80007b70:	6c 31       	st.w [%a3]4,%d15
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
      counter_value       = 0U;
80007b72:	82 04       	mov %d4,0
80007b74:	3c 04       	j 80007b7c <osEE_counter_increment+0x20>
      p_counter_cb->value = 0U;
    } else {
      ++p_counter_cb->value;
80007b76:	c2 14       	add %d4,1
80007b78:	59 34 04 00 	st.w [%a3]4,%d4
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007b7c:	cc 54       	ld.a %a15,[%a5]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007b7e:	82 12       	mov %d2,1
80007b80:	82 03       	mov %d3,0
80007b82:	0b 23 10 68 	mov %e6,%d3,%d2
80007b86:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007b8a:	df 06 fa ff 	jne %d6,0,80007b7e <osEE_counter_increment+0x22>
            to not have nested critical sections.
            To handle possible races due to cycling triggers a state
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;
80007b8e:	d4 3c       	ld.a %a12,[%a3]

    if (p_triggered_db != NULL) {
80007b90:	bd 0c 31 01 	jz.a %a12,80007df2 <osEE_counter_increment+0x296>
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;

      if (p_triggered_cb->when == counter_value) {
80007b94:	cc c0       	ld.a %a15,[%a12]0
80007b96:	4c f1       	ld.w %d15,[%a15]4
80007b98:	40 c2       	mov.aa %a2,%a12
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
80007b9a:	82 33       	mov %d3,3

    if (p_triggered_db != NULL) {
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;

      if (p_triggered_cb->when == counter_value) {
80007b9c:	3e 44       	jeq %d15,%d4,80007ba4 <osEE_counter_increment+0x48>
80007b9e:	1d 00 24 01 	j 80007de6 <osEE_counter_increment+0x28a>
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
80007ba2:	40 f2       	mov.aa %a2,%a15
          p_previous;

        do {
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
80007ba4:	cc 20       	ld.a %a15,[%a2]0
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
80007ba6:	28 83       	st.b [%a15]8,%d3
          p_current = p_current_cb->p_next;
80007ba8:	c8 0f       	ld.a %a15,[%a15]0
        } while ((p_current != NULL) &&
          (p_current->p_trigger_cb->when == counter_value));
80007baa:	bc f6       	jz.a %a15,80007bb6 <osEE_counter_increment+0x5a>
80007bac:	c8 06       	ld.a %a6,[%a15]0
80007bae:	19 62 04 00 	ld.w %d2,[%a6]4
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
80007bb2:	5f 2f f8 7f 	jeq %d15,%d2,80007ba2 <osEE_counter_increment+0x46>
80007bb6:	b5 e4 e8 ff 	st.a [%a14]-24,%a4
          (p_current->p_trigger_cb->when == counter_value));

        /* I set the end of handled queue */
        p_previous->p_trigger_cb->p_next = NULL;
80007bba:	d4 22       	ld.a %a2,[%a2]
80007bbc:	82 0f       	mov %d15,0
80007bbe:	6c 20       	st.w [%a2]0,%d15
        /* I set the head of the trigger queue to the current value
           (maybe NULL) */
        p_counter_cb->trigger_queue = p_current;
80007bc0:	ec 30       	st.a [%a3]0,%a15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007bc2:	cc 54       	ld.a %a15,[%a5]16
80007bc4:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007bc8:	68 0f       	st.w [%a15]0,%d15
          p_st_db = NULL;
        }
      }
    } else {
      /* Exit From The Loop */
      p_st_db = NULL;
80007bca:	59 ef f0 ff 	st.w [%a14]-16,%d15
            p_trigger_to_be_handled_db = p_triggered_db;

          /* Prepare next trigger to be handled here, before actually handle
           * the current one, otherwise cycling triggers will mess with the
           * list of triggers that have to be handled now */
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
80007bce:	cc c0       	ld.a %a15,[%a12]0
80007bd0:	4c f0       	ld.w %d15,[%a15]0
80007bd2:	59 ef ec ff 	st.w [%a14]-20,%d15
(
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_CONST) p_trigger_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_trigger_db->p_alarm_db;
80007bd6:	99 c4 08 00 	ld.a %a4,[%a12]8
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
          {
            CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) 
              p_alarm_db =
                osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db);
            if (p_alarm_db != NULL) {
80007bda:	bd 04 29 00 	jz.a %a4,80007c2c <osEE_counter_increment+0xd0>
)
{
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)       p_cdb;
  P2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)  p_trigger_to_be_handled_cb;

  (void)osEE_handle_action(
80007bde:	d9 44 08 00 	lea %a4,[%a4]8
80007be2:	6d 00 14 01 	call 80007e0a <osEE_handle_action>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007be6:	40 9d       	mov.aa %a13,%a9
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE
  osEE_lock_and_get_curr_core(void)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();

  osEE_hal_spin_lock(p_cdb->p_lock);
80007be8:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007bea:	82 1c       	mov %d12,1
80007bec:	82 0d       	mov %d13,0
80007bee:	0b cd 10 28 	mov %e2,%d13,%d12
80007bf2:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007bf6:	df 02 fa ff 	jne %d2,0,80007bea <osEE_counter_increment+0x8e>
  );

  /* Re-enter in critical section to reinsert alarm-trigger if needed */
  p_cdb = osEE_lock_and_get_curr_core();

  p_trigger_to_be_handled_cb = p_trigger_to_be_handled_db->p_trigger_cb;
80007bfa:	cc c0       	ld.a %a15,[%a12]0

  if (p_trigger_to_be_handled_cb->status == OSEE_TRIGGER_EXPIRED) {
80007bfc:	0c f8       	ld.bu %d15,[%a15]8
80007bfe:	de 30       	jne %d15,3,80007c1e <osEE_counter_increment+0xc2>
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_alarm_cb;
80007c00:	99 c2 08 00 	ld.a %a2,[%a12]8
    CONST(TickType, AUTOMATIC) cycle = osEE_alarm_get_cb(
80007c04:	d4 22       	ld.a %a2,[%a2]
80007c06:	54 24       	ld.w %d4,[%a2]
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
80007c08:	76 49       	jz %d4,80007c1a <osEE_counter_increment+0xbe>
      /* Reinsert the trigger in timer wheel as relative with delta equal to
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
80007c0a:	82 23       	mov %d3,2
80007c0c:	28 83       	st.b [%a15]8,%d3
      osEE_counter_insert_rel_trigger(p_counter_db,
80007c0e:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80007c12:	40 c5       	mov.aa %a5,%a12
80007c14:	6d ff 7b ff 	call 80007b0a <osEE_counter_insert_rel_trigger>
80007c18:	3c 03       	j 80007c1e <osEE_counter_increment+0xc2>
        p_trigger_to_be_handled_db, cycle);
    } else {
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_INACTIVE;
80007c1a:	82 0f       	mov %d15,0
80007c1c:	28 8f       	st.b [%a15]8,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007c1e:	cc d4       	ld.a %a15,[%a13]16
80007c20:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007c24:	82 04       	mov %d4,0
80007c26:	68 04       	st.w [%a15]0,%d4
80007c28:	1d 00 da 00 	j 80007ddc <osEE_counter_increment+0x280>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007c2c:	40 9f       	mov.aa %a15,%a9
80007c2e:	b5 ef f8 ff 	st.a [%a14]-8,%a15
(
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_CONST) p_trigger_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_trigger_db->p_st_db;
80007c32:	cc c3       	ld.a %a15,[%a12]12
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
80007c34:	c8 0d       	ld.a %a13,[%a15]0
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007c36:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80007c3a:	99 32 10 00 	ld.a %a2,[%a3]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007c3e:	82 18       	mov %d8,1
80007c40:	82 09       	mov %d9,0
80007c42:	0b 89 10 28 	mov %e2,%d9,%d8
80007c46:	49 22 c0 08 	cmpswap.w [%a2]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007c4a:	df 02 fa ff 	jne %d2,0,80007c3e <osEE_counter_increment+0xe2>
    /* When the new trigger has to expire */
    VAR(TickType, AUTOMATIC)  next_when = 0U;

    /* Enter in Critical Section to Handle Expiry Point */
    osEE_lock_core(p_cdb);
    if (osEE_st_get_trigger_db(p_st_db)->p_trigger_cb->status ==
80007c4e:	c8 12       	ld.a %a2,[%a15]4
80007c50:	d4 22       	ld.a %a2,[%a2]
80007c52:	0c 28       	ld.bu %d15,[%a2]8
80007c54:	df 3f d5 80 	jne %d15,3,80007dfe <osEE_counter_increment+0x2a2>
         OSEE_TRIGGER_EXPIRED)
    {
      /* Utility local var to handle expiry point */
      VAR(TickType, AUTOMATIC)  nextOffset;
      VAR(MemSize, AUTOMATIC)   expiry_position = p_st_cb->position;
80007c58:	4c d3       	ld.w %d15,[%a13]12
80007c5a:	59 ef fc ff 	st.w [%a14]-4,%d15

      /* This can happen:
          - If a Next Schedule Table is activated, to stop the original
            Schedule Table after the final delay.
          - IF Original Schedule Table is repeating */
      if (expiry_position == INVALID_SCHEDULETABLE_POSITION) {
80007c5e:	df ff 32 80 	jne %d15,-1,80007cc2 <osEE_counter_increment+0x166>
        /* Get the next Schedule Table */
        CONSTP2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)
          p_next_st_db = p_st_cb->p_next_table;
80007c62:	d4 d2       	ld.a %a2,[%a13]

        if (p_next_st_db != NULL) {
80007c64:	bd 02 1e 00 	jz.a %a2,80007ca0 <osEE_counter_increment+0x144>
          /* Turn-off Orig Schedule Table */
          p_st_cb->st_status    = SCHEDULETABLE_STOPPED;
80007c68:	82 02       	mov %d2,0
80007c6a:	59 d2 08 00 	st.w [%a13]8,%d2
          osEE_st_get_trigger_db(p_st_db)->p_trigger_cb->
80007c6e:	c8 1f       	ld.a %a15,[%a15]4
80007c70:	c8 0f       	ld.a %a15,[%a15]0
            status = OSEE_TRIGGER_INACTIVE;
80007c72:	28 82       	st.b [%a15]8,%d2
80007c74:	d4 2d       	ld.a %a13,[%a2]

          /* Next ST Handling */
          p_st_db = p_next_st_db;
          p_st_cb = osEE_st_get_cb(p_next_st_db);

          p_st_cb->st_status = SCHEDULETABLE_RUNNING;
80007c76:	82 33       	mov %d3,3
80007c78:	59 d3 08 00 	st.w [%a13]8,%d3

          p_st_cb->position = 0U;
80007c7c:	59 d2 0c 00 	st.w [%a13]12,%d2
          /* Set Next ST Start value */
          p_st_cb->start    = p_counter_db->p_counter_cb->value;
80007c80:	99 e3 e8 ff 	ld.a %a3,[%a14]-24
80007c84:	cc 30       	ld.a %a15,[%a3]0
80007c86:	48 14       	ld.w %d4,[%a15]4
80007c88:	59 d4 04 00 	st.w [%a13]4,%d4

          nextOffset = (*p_st_db->p_expiry_point_array)[0U].offset;
80007c8c:	cc 22       	ld.a %a15,[%a2]8
80007c8e:	4c f0       	ld.w %d15,[%a15]0
          p_st_cb->st_status    = SCHEDULETABLE_STOPPED;
          osEE_st_get_trigger_db(p_st_db)->p_trigger_cb->
            status = OSEE_TRIGGER_INACTIVE;

          /* Next ST Handling */
          p_st_db = p_next_st_db;
80007c90:	40 2f       	mov.aa %a15,%a2

          nextOffset = (*p_st_db->p_expiry_point_array)[0U].offset;

          /* Handle special case of some expiry points with offset equal to
             zero */
          if (nextOffset > 0U) {
80007c92:	df 0f 9b 00 	jeq %d15,0,80007dc8 <osEE_counter_increment+0x26c>
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_trigger_db;
80007c96:	99 25 04 00 	ld.a %a5,[%a2]4
            /* Schedule the trigger tied to the next Schedule Table */
            p_trigger_to_reinsert = osEE_st_get_trigger_db(p_st_db);
            next_when = p_st_cb->start + nextOffset;
80007c9a:	42 f4       	add %d4,%d15
80007c9c:	1d 00 8a 00 	j 80007db0 <osEE_counter_increment+0x254>
            p_st_db = NULL;
          }
          /* else first expiry point is handled immediately */
        } else {
          /* Repeating Schedule Table */
          p_st_cb->position = 0U;
80007ca0:	82 02       	mov %d2,0
80007ca2:	59 d2 0c 00 	st.w [%a13]12,%d2
          /* Set Repeating ST Start value */
          p_st_cb->start    = p_counter_db->p_counter_cb->value;
80007ca6:	99 e3 e8 ff 	ld.a %a3,[%a14]-24
80007caa:	d4 32       	ld.a %a2,[%a3]
80007cac:	19 24 04 00 	ld.w %d4,[%a2]4
80007cb0:	59 d4 04 00 	st.w [%a13]4,%d4
          nextOffset        = (*p_st_db->p_expiry_point_array)[0U].offset;
80007cb4:	c8 22       	ld.a %a2,[%a15]8
80007cb6:	4c 20       	ld.w %d15,[%a2]0

          if (nextOffset > 0U) {
80007cb8:	df 0f 88 00 	jeq %d15,0,80007dc8 <osEE_counter_increment+0x26c>
80007cbc:	c8 15       	ld.a %a5,[%a15]4
            /* Trigger CB "when" field is used to hold next trigger value, for
               next expiry point */
            p_trigger_to_reinsert = osEE_st_get_trigger_db(p_st_db);
            next_when = p_st_cb->start + nextOffset;
80007cbe:	42 f4       	add %d4,%d15
80007cc0:	3c 78       	j 80007db0 <osEE_counter_increment+0x254>
      } else {
        /* Get the Expiry point */
        VAR(MemSize, AUTOMATIC) i;
        /* Expiry point description */
        CONSTP2VAR(OsEE_st_exipiry_point, AUTOMATIC, OS_APPL_CONST)
          p_expiry_point = &(*p_st_db->p_expiry_point_array)[expiry_position];
80007cc2:	4c f2       	ld.w %d15,[%a15]8
80007cc4:	59 ef f4 ff 	st.w [%a14]-12,%d15
        CONST(MemSize, AUTOMATIC)
          action_array_size = p_expiry_point->action_array_size;
80007cc8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80007ccc:	13 42 21 2f 	madd %d2,%d15,%d2,20
80007cd0:	60 22       	mov.a %a2,%d2
80007cd2:	19 2e 08 00 	ld.w %d14,[%a2]8
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007cd6:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80007cda:	99 32 10 00 	ld.a %a2,[%a3]16
80007cde:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007ce2:	82 02       	mov %d2,0
80007ce4:	74 22       	st.w [%a2],%d2

        /* Handle expiry point actions outside the Critical Section */
        osEE_unlock_core(p_cdb);

        for (i = 0U; i < action_array_size; ++i) {
80007ce6:	df 0e 16 00 	jeq %d14,0,80007d12 <osEE_counter_increment+0x1b6>
80007cea:	19 ef f0 ff 	ld.w %d15,[%a14]-16
          (void)osEE_handle_action(&(*p_expiry_point->p_action_array)[i]);
80007cee:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80007cf2:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
80007cf6:	13 43 21 24 	madd %d2,%d4,%d3,20
80007cfa:	60 2c       	mov.a %a12,%d2
80007cfc:	b0 4c       	add.a %a12,4
80007cfe:	d4 c4       	ld.a %a4,[%a12]
80007d00:	53 4f 21 60 	mul %d6,%d15,20
80007d04:	01 46 00 46 	addsc.a %a4,%a4,%d6,0
80007d08:	6d 00 81 00 	call 80007e0a <osEE_handle_action>
          action_array_size = p_expiry_point->action_array_size;

        /* Handle expiry point actions outside the Critical Section */
        osEE_unlock_core(p_cdb);

        for (i = 0U; i < action_array_size; ++i) {
80007d0c:	c2 1f       	add %d15,1
80007d0e:	5f ef f8 ff 	jne %d15,%d14,80007cfe <osEE_counter_increment+0x1a2>
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
80007d12:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80007d16:	99 32 10 00 	ld.a %a2,[%a3]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007d1a:	82 1a       	mov %d10,1
80007d1c:	82 0b       	mov %d11,0
80007d1e:	0b ab 10 28 	mov %e2,%d11,%d10
80007d22:	49 22 c0 08 	cmpswap.w [%a2]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007d26:	df 02 fa ff 	jne %d2,0,80007d1a <osEE_counter_increment+0x1be>

        /* Reenter in critical section after handling actions */
        osEE_lock_core(p_cdb);

        /* if the trigger is still valid... */
        if (osEE_st_get_trigger_db(p_st_db)->p_trigger_cb->status ==
80007d2a:	c8 12       	ld.a %a2,[%a15]4
80007d2c:	d4 22       	ld.a %a2,[%a2]
80007d2e:	0c 28       	ld.bu %d15,[%a2]8
80007d30:	df 3f 6a 80 	jne %d15,3,80007e04 <osEE_counter_increment+0x2a8>
            OSEE_TRIGGER_EXPIRED)
        {
          /* Handle next expiry point insertion in alarm queue */
          /* if it is the last expiry point and if this is not a repeating
             schedule table, handle next schedule table or stop it */
          if (expiry_position == (p_st_db->expiry_point_array_size - 1U)) {
80007d34:	4c f3       	ld.w %d15,[%a15]12
80007d36:	c2 ff       	add %d15,-1
80007d38:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80007d3c:	5f f3 23 80 	jne %d3,%d15,80007d82 <osEE_counter_increment+0x226>
            /* We reached the end of schedule table so we stop it */
            if ((p_st_cb->p_next_table == NULL) && (!p_st_db->repeated)) {
80007d40:	4c d0       	ld.w %d15,[%a13]0
80007d42:	ee 0d       	jnz %d15,80007d5c <osEE_counter_increment+0x200>
80007d44:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80007d48:	ee 0a       	jnz %d15,80007d5c <osEE_counter_increment+0x200>
              /* [SWS_Os_00009] If the schedule table is single-shot, the
                  Operating System module shall stop the processing of the
                  schedule table Final Delay ticks after the Final Expiry Point
                  is processed. */
              p_st_cb->st_status  = SCHEDULETABLE_STOPPED;
80007d4a:	82 04       	mov %d4,0
80007d4c:	59 d4 08 00 	st.w [%a13]8,%d4
              /*  This is needed to stop the underlying Trigger tied to the
                  Schedule Table, otherwise the Trigger will reschedule this
                  trigger on the next occurrence of counter.value == when */
              osEE_st_get_trigger_db(p_st_db)->p_trigger_cb->status =
80007d50:	c8 1f       	ld.a %a15,[%a15]4
80007d52:	c8 0f       	ld.a %a15,[%a15]0
80007d54:	28 84       	st.b [%a15]8,%d4
                OSEE_TRIGGER_INACTIVE;
              /* Exit From The Loop */
              p_st_db = NULL;
80007d56:	99 ef f0 ff 	ld.a %a15,[%a14]-16
80007d5a:	3c 37       	j 80007dc8 <osEE_counter_increment+0x26c>
            } else {
              /* Schedule the final delay for original schedule table */
              p_st_cb->position = INVALID_SCHEDULETABLE_POSITION;
80007d5c:	82 f6       	mov %d6,-1
80007d5e:	59 d6 0c 00 	st.w [%a13]12,%d6
              /* [SWS_Os_0427] If the schedule table is single-shot,
                  the Operating System module shall allow a Final Delay between
                  0 .. OsCounterMaxAllowedValue of the underlying counter. */
              if (p_st_db->duration > p_expiry_point->offset) {
80007d62:	4c f5       	ld.w %d15,[%a15]20
80007d64:	19 e7 fc ff 	ld.w %d7,[%a14]-4
80007d68:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80007d6c:	13 47 21 72 	madd %d7,%d2,%d7,20
80007d70:	60 72       	mov.a %a2,%d7
80007d72:	54 22       	ld.w %d2,[%a2]
80007d74:	7f f2 2a 80 	jge.u %d2,%d15,80007dc8 <osEE_counter_increment+0x26c>
80007d78:	c8 15       	ld.a %a5,[%a15]4
                p_trigger_to_reinsert = osEE_st_get_trigger_db(p_st_db);
                next_when = p_st_cb->start + p_st_db->duration;
80007d7a:	19 d4 04 00 	ld.w %d4,[%a13]4
80007d7e:	42 f4       	add %d4,%d15
80007d80:	3c 18       	j 80007db0 <osEE_counter_increment+0x254>
          } else {
            if (p_st_db->sync_strategy == OSEE_SCHEDTABLE_SYNC_EXPLICIT) {
              /* *** TODO: HANDLE SYNCRONIZATION *** */
            }
            /* Schedule the next expiry point */
            ++expiry_position;
80007d82:	19 ef fc ff 	ld.w %d15,[%a14]-4
80007d86:	c2 1f       	add %d15,1
            p_st_cb->position = expiry_position;
80007d88:	6c d3       	st.w [%a13]12,%d15

            nextOffset = (*p_st_db->p_expiry_point_array)[expiry_position].
80007d8a:	48 22       	ld.w %d2,[%a15]8
80007d8c:	13 4f 21 32 	madd %d3,%d2,%d15,20
80007d90:	60 32       	mov.a %a2,%d3
80007d92:	4c 20       	ld.w %d15,[%a2]0
              offset;

            /* Check if new expiry point is not simultaneous of the
               previous one */
            if (nextOffset > p_expiry_point->offset) {
80007d94:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80007d98:	19 e6 f4 ff 	ld.w %d6,[%a14]-12
80007d9c:	13 44 21 46 	madd %d4,%d6,%d4,20
80007da0:	60 42       	mov.a %a2,%d4
80007da2:	54 22       	ld.w %d2,[%a2]
80007da4:	7f f2 12 80 	jge.u %d2,%d15,80007dc8 <osEE_counter_increment+0x26c>
80007da8:	c8 15       	ld.a %a5,[%a15]4
              p_trigger_to_reinsert = osEE_st_get_trigger_db(p_st_db);
              next_when = p_st_cb->start + nextOffset;
80007daa:	19 d4 04 00 	ld.w %d4,[%a13]4
80007dae:	42 f4       	add %d4,%d15
      /* Exit From The Loop */
      p_st_db = NULL;
    }

    /* Reinsert the trigger in queue if needed */
    if (p_trigger_to_reinsert != NULL) {
80007db0:	99 ef f0 ff 	ld.a %a15,[%a14]-16
80007db4:	bc 5a       	jz.a %a5,80007dc8 <osEE_counter_increment+0x26c>
      p_trigger_to_reinsert->p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
80007db6:	cc 50       	ld.a %a15,[%a5]0
80007db8:	82 27       	mov %d7,2
80007dba:	28 87       	st.b [%a15]8,%d7
      osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_to_reinsert,
80007dbc:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80007dc0:	6d ff 74 fe 	call 80007aa8 <osEE_counter_insert_abs_trigger>
80007dc4:	99 ef f0 ff 	ld.a %a15,[%a14]-16
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
80007dc8:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80007dcc:	99 32 10 00 	ld.a %a2,[%a3]16
80007dd0:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007dd4:	82 02       	mov %d2,0
80007dd6:	74 22       	st.w [%a2],%d2
        next_when);
    }
    /* exit critical section for this loop */
    osEE_unlock_core(p_cdb);
  } while (p_st_db != NULL);
80007dd8:	bd 0f 2f ff 	jnz.a %a15,80007c36 <osEE_counter_increment+0xda>
            p_trigger_to_be_handled_db = p_triggered_db;

          /* Prepare next trigger to be handled here, before actually handle
           * the current one, otherwise cycling triggers will mess with the
           * list of triggers that have to be handled now */
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
80007ddc:	99 ec ec ff 	ld.a %a12,[%a14]-20
#elif (defined(OSEE_HAS_SCHEDULE_TABLES))
          osEE_counter_handle_st_expiry_point(p_counter_db,
            p_trigger_to_be_handled_db);
#endif /* OSEE_COUNTER_TRIGGER_TYPES elif OSEE_HAS_ALARMS elif
          OSEE_HAS_SCHEDULE_TABLES */
        } while (p_triggered_db != NULL);
80007de0:	bd 0c f7 fe 	jnz.a %a12,80007bce <osEE_counter_increment+0x72>
80007de4:	00 90       	ret 
80007de6:	cc 54       	ld.a %a15,[%a5]16
80007de8:	0d 00 80 04 	dsync 
80007dec:	82 0f       	mov %d15,0
80007dee:	68 0f       	st.w [%a15]0,%d15
80007df0:	00 90       	ret 
80007df2:	cc 54       	ld.a %a15,[%a5]16
80007df4:	0d 00 80 04 	dsync 
80007df8:	82 0f       	mov %d15,0
80007dfa:	68 0f       	st.w [%a15]0,%d15
80007dfc:	00 90       	ret 
          p_st_db = NULL;
        }
      }
    } else {
      /* Exit From The Loop */
      p_st_db = NULL;
80007dfe:	99 ef f0 ff 	ld.a %a15,[%a14]-16
80007e02:	3c e3       	j 80007dc8 <osEE_counter_increment+0x26c>
            }
            /* else handle the next expiry point immediately */
          }
        } else {
          /* Exit From The Loop */
          p_st_db = NULL;
80007e04:	99 ef f0 ff 	ld.a %a15,[%a14]-16
80007e08:	3c e0       	j 80007dc8 <osEE_counter_increment+0x26c>

80007e0a <osEE_handle_action>:
static FUNC(StatusType, OS_CODE)
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
80007e0a:	40 ae       	mov.aa %a14,%sp
80007e0c:	20 08       	sub.a %sp,8
80007e0e:	40 4f       	mov.aa %a15,%a4
  VAR(StatusType, AUTOMATIC) ev = E_OK;
80007e10:	82 0f       	mov %d15,0
80007e12:	e9 ef ff ff 	st.b [%a14]-1,%d15
  switch (p_action->type) {
80007e16:	39 4f 10 00 	ld.bu %d15,[%a4]16
80007e1a:	ff 4f 4c 80 	jge.u %d15,4,80007eb2 <osEE_handle_action+0xa8>
80007e1e:	91 00 00 28 	movh.a %a2,32768
80007e22:	d9 22 ec 87 	lea %a2,[%a2]32300 <80007e2c <osEE_handle_action+0x22>>
80007e26:	90 22       	addsc.a %a2,%a2,%d15,2
80007e28:	dc 02       	ji %a2
80007e2a:	00 00       	nop 
80007e2c:	1d 00 08 00 	j 80007e3c <osEE_handle_action+0x32>
80007e30:	1d 00 16 00 	j 80007e5c <osEE_handle_action+0x52>
80007e34:	1d 00 25 00 	j 80007e7e <osEE_handle_action+0x74>
80007e38:	1d 00 2b 00 	j 80007e8e <osEE_handle_action+0x84>
    case OSEE_ACTION_TASK:
    {
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb     = p_action->param.p_tdb;
80007e3c:	cc 41       	ld.a %a15,[%a4]4

      ev = osEE_task_activated(p_tdb);
80007e3e:	40 f4       	mov.aa %a4,%a15
80007e40:	6d ff f1 fb 	call 80007622 <osEE_task_activated>
80007e44:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      if (ev == E_OK) {
80007e48:	df 02 38 80 	jne %d2,0,80007eb8 <osEE_handle_action+0xae>
        (void)osEE_scheduler_task_insert(osEE_get_kernel(), p_tdb);
80007e4c:	91 00 00 48 	movh.a %a4,32768
80007e50:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80007e54:	40 f5       	mov.aa %a5,%a15
80007e56:	6d ff db fc 	call 8000780c <osEE_scheduler_task_insert>
80007e5a:	3c 2c       	j 80007eb2 <osEE_handle_action+0xa8>
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb = p_action->param.p_tdb;
      CONST(EventMaskType, AUTOMATIC)
        mask = p_action->param.mask;

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);
80007e5c:	99 44 04 00 	ld.a %a4,[%a4]4
80007e60:	48 34       	ld.w %d4,[%a15]12
80007e62:	d9 e5 ff ff 	lea %a5,[%a14]-1
80007e66:	6d ff 0d fc 	call 80007680 <osEE_task_event_set_mask>

      if (p_sn != NULL) {
80007e6a:	bd 02 24 00 	jz.a %a2,80007eb2 <osEE_handle_action+0xa8>
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
80007e6e:	91 00 00 48 	movh.a %a4,32768
80007e72:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80007e76:	40 25       	mov.aa %a5,%a2
80007e78:	6d ff 2b fd 	call 800078ce <osEE_scheduler_task_unblocked>
80007e7c:	3c 1b       	j 80007eb2 <osEE_handle_action+0xa8>
      }
    }
    break;
#endif /* OSEE_HAS_EVENTS */
    case OSEE_ACTION_COUNTER:
      osEE_counter_increment(p_action->param.p_counter_db);
80007e7e:	99 44 08 00 	ld.a %a4,[%a4]8
80007e82:	6d ff 6d fe 	call 80007b5c <osEE_counter_increment>
      ev = E_OK;
80007e86:	82 0f       	mov %d15,0
80007e88:	e9 ef ff ff 	st.b [%a14]-1,%d15
    break;
80007e8c:	3c 26       	j 80007ed8 <osEE_handle_action+0xce>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80007e8e:	40 92       	mov.aa %a2,%a9
    case OSEE_ACTION_CALLBACK:
    {
#if (defined(OSEE_HAS_CONTEXT))
      CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
        p_ccb = osEE_get_curr_core()->p_ccb;
80007e90:	99 2c 0c 00 	ld.a %a12,[%a2]12
      CONST(OsEE_os_context, AUTOMATIC)
        prev_os_context = p_ccb->os_context;
80007e94:	39 cf 14 00 	ld.bu %d15,[%a12]20

      p_ccb->os_context = OSEE_ALARMCALLBACK_CTX;
80007e98:	3b a0 00 20 	mov %d2,10
80007e9c:	e9 c2 14 00 	st.b [%a12]20,%d2
#endif /* OSEE_HAS_CONTEXT */
      p_action->param.f();
80007ea0:	cc 40       	ld.a %a15,[%a4]0
80007ea2:	2d 0f 00 00 	calli %a15
#if (defined(OSEE_HAS_CONTEXT))
      p_ccb->os_context = prev_os_context;
80007ea6:	e9 cf 14 00 	st.b [%a12]20,%d15
#endif /* OSEE_HAS_CONTEXT */

      ev = E_OK;
80007eaa:	82 0f       	mov %d15,0
80007eac:	e9 ef ff ff 	st.b [%a14]-1,%d15
    }
    break;
80007eb0:	3c 14       	j 80007ed8 <osEE_handle_action+0xce>
      ev = E_OK;
    break;
  }

#if (defined(OSEE_HAS_ERRORHOOK))
  if (ev != E_OK) {
80007eb2:	39 ef ff ff 	ld.bu %d15,[%a14]-1
80007eb6:	6e 11       	jz %d15,80007ed8 <osEE_handle_action+0xce>
80007eb8:	40 9f       	mov.aa %a15,%a9
    CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
      p_ccb = osEE_get_curr_core()->p_ccb;
80007eba:	c8 3f       	ld.a %a15,[%a15]12
    osEE_set_service_id(p_ccb, OSId_Action);
    osEE_call_error_hook(p_ccb, ev);
80007ebc:	39 e4 ff ff 	ld.bu %d4,[%a14]-1
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)    p_ccb,
  VAR(StatusType, AUTOMATIC)                  Error
)
{
  VAR(OsEE_os_context, AUTOMATIC) prev_os_ctx = p_ccb->os_context;
80007ec0:	39 ff 14 00 	ld.bu %d15,[%a15]20
  if (prev_os_ctx != OSEE_ERRORHOOK_CTX) {
80007ec4:	1e 4a       	jeq %d15,4,80007ed8 <osEE_handle_action+0xce>
    p_ccb->os_context = OSEE_ERRORHOOK_CTX;
80007ec6:	82 42       	mov %d2,4
80007ec8:	e9 f2 14 00 	st.b [%a15]20,%d2
    p_ccb->last_error = Error;
80007ecc:	e9 f4 12 00 	st.b [%a15]18,%d4
    ErrorHook(Error);
80007ed0:	6d ff 35 e2 	call 8000433a <ErrorHook>
    p_ccb->os_context = prev_os_ctx;
80007ed4:	e9 ff 14 00 	st.b [%a15]20,%d15
  }
#endif /* OSEE_HAS_ERRORHOOK */

  return ev;
}
80007ed8:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80007edc:	00 90       	ret 
	...

80007ee0 <osEE_alarm_set_rel>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      increment,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
80007ee0:	40 ae       	mov.aa %a14,%sp
80007ee2:	40 4d       	mov.aa %a13,%a4
80007ee4:	02 4d       	mov %d13,%d4
80007ee6:	02 5e       	mov %d14,%d5
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_alarm_cb;
80007ee8:	54 5c       	ld.w %d12,[%a5]
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_trigger_db;
80007eea:	19 5a 04 00 	ld.w %d10,[%a5]4
  CONSTP2VAR(OsEE_AlarmCB, AUTOMATIC, OS_APPL_DATA)
    p_alarm_cb = osEE_alarm_get_cb(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
80007eee:	60 af       	mov.a %a15,%d10
80007ef0:	c8 0c       	ld.a %a12,[%a15]0
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
80007ef2:	39 4b 10 00 	ld.bu %d11,[%a4]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80007ef6:	02 b4       	mov %d4,%d11
80007ef8:	6d 00 f7 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
80007efc:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007efe:	82 18       	mov %d8,1
80007f00:	82 09       	mov %d9,0
80007f02:	0b 89 10 28 	mov %e2,%d9,%d8
80007f06:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007f0a:	df 02 fa ff 	jne %d2,0,80007efe <osEE_alarm_set_rel+0x1e>
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
80007f0e:	0c c8       	ld.bu %d15,[%a12]8
    ev = E_OS_STATE;
80007f10:	82 78       	mov %d8,7
    counter_core_id = p_counter_db->core_id;
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
80007f12:	ff 2f 22 80 	jge.u %d15,2,80007f56 <osEE_alarm_set_rel+0x76>
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
80007f16:	de 16       	jne %d15,1,80007f42 <osEE_alarm_set_rel+0x62>
    p_alarm_cb->cycle = cycle;
80007f18:	60 cf       	mov.a %a15,%d12
80007f1a:	68 0e       	st.w [%a15]0,%d14
{
  VAR(TickType, AUTOMATIC) when;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
80007f1c:	19 d2 04 00 	ld.w %d2,[%a13]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
80007f20:	cc d0       	ld.a %a15,[%a13]0
80007f22:	4c f1       	ld.w %d15,[%a15]4

  if ((maxallowedvalue - delta) >= value) {
80007f24:	0b d2 80 40 	sub %d4,%d2,%d13
80007f28:	46 02       	not %d2
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
80007f2a:	42 f2       	add %d2,%d15
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
80007f2c:	12 d3       	add %d3,%d15,%d13
80007f2e:	42 2d       	add %d13,%d2
80007f30:	0b f4 30 f1 	lt.u %d15,%d4,%d15
80007f34:	2b 3d 40 ff 	sel %d15,%d15,%d13,%d3
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       'here' when based on increment */
    p_trigger_cb->when   = osEE_counter_eval_when(p_counter_db, increment);
80007f38:	6c c1       	st.w [%a12]4,%d15
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
80007f3a:	82 4f       	mov %d15,4
80007f3c:	2c c8       	st.b [%a12]8,%d15

    ev = E_OK;
80007f3e:	82 08       	mov %d8,0
80007f40:	3c 0b       	j 80007f56 <osEE_alarm_set_rel+0x76>
  } else {
    p_alarm_cb->cycle = cycle;
80007f42:	60 cf       	mov.a %a15,%d12
80007f44:	68 0e       	st.w [%a15]0,%d14
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
80007f46:	82 2f       	mov %d15,2
80007f48:	2c c8       	st.b [%a12]8,%d15
 
    osEE_counter_insert_rel_trigger(
80007f4a:	40 d4       	mov.aa %a4,%a13
80007f4c:	60 a5       	mov.a %a5,%d10
80007f4e:	02 d4       	mov %d4,%d13
80007f50:	6d ff dd fd 	call 80007b0a <osEE_counter_insert_rel_trigger>
      p_counter_db, p_trigger_db, increment
    );
 
    ev = E_OK;
80007f54:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80007f56:	02 b4       	mov %d4,%d11
80007f58:	6d 00 c7 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
80007f5c:	cc 24       	ld.a %a15,[%a2]16
80007f5e:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007f62:	82 0f       	mov %d15,0
80007f64:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
80007f66:	02 82       	mov %d2,%d8
80007f68:	00 90       	ret 

80007f6a <osEE_alarm_set_abs>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      start,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
80007f6a:	40 ae       	mov.aa %a14,%sp
80007f6c:	80 4b       	mov.d %d11,%a4
80007f6e:	02 4d       	mov %d13,%d4
80007f70:	02 5e       	mov %d14,%d5
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_alarm_cb;
80007f72:	54 5c       	ld.w %d12,[%a5]
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_trigger_db;
80007f74:	99 5d 04 00 	ld.a %a13,[%a5]4
  CONSTP2VAR(OsEE_AlarmCB, AUTOMATIC, OS_APPL_DATA)
    p_alarm_cb = osEE_alarm_get_cb(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
80007f78:	d4 dc       	ld.a %a12,[%a13]
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
80007f7a:	39 4a 10 00 	ld.bu %d10,[%a4]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80007f7e:	02 a4       	mov %d4,%d10
80007f80:	6d 00 b3 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
80007f84:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007f86:	82 18       	mov %d8,1
80007f88:	82 09       	mov %d9,0
80007f8a:	0b 89 10 28 	mov %e2,%d9,%d8
80007f8e:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007f92:	df 02 fa ff 	jne %d2,0,80007f86 <osEE_alarm_set_abs+0x1c>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
80007f96:	0c c8       	ld.bu %d15,[%a12]8
    ev = E_OS_STATE;
80007f98:	82 78       	mov %d8,7
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
80007f9a:	ff 2f 15 80 	jge.u %d15,2,80007fc4 <osEE_alarm_set_abs+0x5a>
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
80007f9e:	5e 19       	jne %d15,1,80007fb0 <osEE_alarm_set_abs+0x46>
    p_alarm_cb->cycle = cycle;
80007fa0:	60 cf       	mov.a %a15,%d12
80007fa2:	68 0e       	st.w [%a15]0,%d14
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       here 'when' based on start */
    p_trigger_cb->when   = start;
80007fa4:	59 cd 04 00 	st.w [%a12]4,%d13
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
80007fa8:	82 4f       	mov %d15,4
80007faa:	2c c8       	st.b [%a12]8,%d15

    ev = E_OK;
80007fac:	82 08       	mov %d8,0
80007fae:	3c 0b       	j 80007fc4 <osEE_alarm_set_abs+0x5a>
  } else {
    p_alarm_cb->cycle = cycle;
80007fb0:	60 cf       	mov.a %a15,%d12
80007fb2:	68 0e       	st.w [%a15]0,%d14
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
80007fb4:	82 2f       	mov %d15,2
80007fb6:	2c c8       	st.b [%a12]8,%d15

    osEE_counter_insert_abs_trigger(
80007fb8:	60 b4       	mov.a %a4,%d11
80007fba:	40 d5       	mov.aa %a5,%a13
80007fbc:	02 d4       	mov %d4,%d13
80007fbe:	6d ff 75 fd 	call 80007aa8 <osEE_counter_insert_abs_trigger>
      p_counter_db, p_trigger_db, start
    );

    ev = E_OK;
80007fc2:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80007fc4:	02 a4       	mov %d4,%d10
80007fc6:	6d 00 90 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
80007fca:	cc 24       	ld.a %a15,[%a2]16
80007fcc:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80007fd0:	82 0f       	mov %d15,0
80007fd2:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
80007fd4:	02 82       	mov %d2,%d8
80007fd6:	00 90       	ret 

80007fd8 <osEE_alarm_cancel>:
FUNC(StatusType, OS_CODE)
  osEE_alarm_cancel
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db
)
{
80007fd8:	40 ae       	mov.aa %a14,%sp
80007fda:	99 4c 04 00 	ld.a %a12,[%a4]4
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
80007fde:	d4 cd       	ld.a %a13,[%a12]
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
80007fe0:	19 ca 04 00 	ld.w %d10,[%a12]4
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
80007fe4:	60 af       	mov.a %a15,%d10
80007fe6:	39 fb 10 00 	ld.bu %d11,[%a15]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80007fea:	02 b4       	mov %d4,%d11
80007fec:	6d 00 7d 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
80007ff0:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80007ff2:	82 18       	mov %d8,1
80007ff4:	82 09       	mov %d9,0
80007ff6:	0b 89 10 28 	mov %e2,%d9,%d8
80007ffa:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80007ffe:	df 02 fa ff 	jne %d2,0,80007ff2 <osEE_alarm_cancel+0x1a>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
80008002:	0c d8       	ld.bu %d15,[%a13]8
    ev = E_OS_NOFUNC;
80008004:	82 58       	mov %d8,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
80008006:	bf 2f 0f 80 	jlt.u %d15,2,80008024 <_SMALL_DATA2_+0x24>
    ev = E_OS_NOFUNC;
  } else if (p_trigger_cb->status >= OSEE_TRIGGER_EXPIRED) {
8000800a:	bf 3f 06 80 	jlt.u %d15,3,80008016 <_SMALL_DATA2_+0x16>
    p_trigger_cb->status = OSEE_TRIGGER_CANCELED;
8000800e:	82 1f       	mov %d15,1
80008010:	2c d8       	st.b [%a13]8,%d15
    ev = E_OK;
80008012:	82 08       	mov %d8,0
80008014:	3c 08       	j 80008024 <_SMALL_DATA2_+0x24>
  } else {
    p_trigger_cb->status = OSEE_TRIGGER_INACTIVE;
80008016:	82 0f       	mov %d15,0
80008018:	2c d8       	st.b [%a13]8,%d15
    osEE_counter_cancel_trigger(p_counter_db, p_trigger_db);
8000801a:	60 a4       	mov.a %a4,%d10
8000801c:	40 c5       	mov.aa %a5,%a12
8000801e:	6d ff 87 fd 	call 80007b2c <osEE_counter_cancel_trigger>
    ev = E_OK;
80008022:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80008024:	02 b4       	mov %d4,%d11
80008026:	6d 00 60 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
8000802a:	cc 24       	ld.a %a15,[%a2]16
8000802c:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80008030:	82 0f       	mov %d15,0
80008032:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
80008034:	02 82       	mov %d2,%d8
80008036:	00 90       	ret 

80008038 <osEE_alarm_get>:
  osEE_alarm_get
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  P2VAR(TickType, AUTOMATIC, OS_APPL_DATA)        p_tick
)
{
80008038:	40 ae       	mov.aa %a14,%sp
8000803a:	80 5b       	mov.d %d11,%a5
8000803c:	cc 41       	ld.a %a15,[%a4]4
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000803e:	c8 0d       	ld.a %a13,[%a15]0
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
80008040:	c8 1c       	ld.a %a12,[%a15]4
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
80008042:	39 ca 10 00 	ld.bu %d10,[%a12]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80008046:	02 a4       	mov %d4,%d10
80008048:	6d 00 4f 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000804c:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000804e:	82 18       	mov %d8,1
80008050:	82 09       	mov %d9,0
80008052:	0b 89 10 28 	mov %e2,%d9,%d8
80008056:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000805a:	df 02 fa ff 	jne %d2,0,8000804e <osEE_alarm_get+0x16>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000805e:	0c d8       	ld.bu %d15,[%a13]8
    ev = E_OS_NOFUNC;
80008060:	82 58       	mov %d8,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
80008062:	bf 2f 14 80 	jlt.u %d15,2,8000808a <osEE_alarm_get+0x52>
    ev = E_OS_NOFUNC;
  } else {
    *p_tick = osEE_counter_eval_delta(p_counter_db, p_trigger_cb->when);
80008066:	19 d2 04 00 	ld.w %d2,[%a13]4
{
  VAR(TickType, AUTOMATIC) delta;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
8000806a:	19 c3 04 00 	ld.w %d3,[%a12]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000806e:	cc c0       	ld.a %a15,[%a12]0
80008070:	4c f1       	ld.w %d15,[%a15]4
80008072:	42 23       	add %d3,%d2

  if (when > value) {
    delta = when - value;
  } else {
    delta = (maxallowedvalue - value) + when + 1U;
80008074:	c2 13       	add %d3,1
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if (when > value) {
    delta = when - value;
80008076:	0b f2 80 40 	sub %d4,%d2,%d15
8000807a:	a2 f3       	sub %d3,%d15
8000807c:	0b 2f 50 f1 	ge.u %d15,%d15,%d2
80008080:	2b 43 40 ff 	sel %d15,%d15,%d3,%d4
80008084:	60 bf       	mov.a %a15,%d11
80008086:	68 0f       	st.w [%a15]0,%d15
    ev = E_OK;
80008088:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000808a:	02 a4       	mov %d4,%d10
8000808c:	6d 00 2d 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
80008090:	cc 24       	ld.a %a15,[%a2]16
80008092:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80008096:	82 0f       	mov %d15,0
80008098:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000809a:	02 82       	mov %d2,%d8
8000809c:	00 90       	ret 

8000809e <osEE_st_start_rel>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_DATA) p_st_db,
  VAR(TickType,   AUTOMATIC)                      offset
)
{
8000809e:	40 ae       	mov.aa %a14,%sp
800080a0:	40 4d       	mov.aa %a13,%a4
800080a2:	40 5c       	mov.aa %a12,%a5
800080a4:	02 4e       	mov %d14,%d4
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
800080a6:	54 5b       	ld.w %d11,[%a5]
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_trigger_db;
800080a8:	19 5c 04 00 	ld.w %d12,[%a5]4
  CONSTP2VAR(OsEE_SchedTabCB, AUTOMATIC, OS_APPL_DATA)
    p_st_cb = osEE_st_get_cb(p_st_db);
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_st_get_trigger_db(p_st_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
800080ac:	60 cf       	mov.a %a15,%d12
800080ae:	48 0a       	ld.w %d10,[%a15]0
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
800080b0:	39 4d 10 00 	ld.bu %d13,[%a4]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
800080b4:	02 d4       	mov %d4,%d13
800080b6:	6d 00 18 02 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
800080ba:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
800080bc:	82 18       	mov %d8,1
800080be:	82 09       	mov %d9,0
800080c0:	0b 89 10 28 	mov %e2,%d9,%d8
800080c4:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
800080c8:	df 02 fa ff 	jne %d2,0,800080bc <osEE_st_start_rel+0x1e>
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
800080cc:	60 af       	mov.a %a15,%d10
800080ce:	0c f8       	ld.bu %d15,[%a15]8
    ev = E_OS_STATE;
800080d0:	82 78       	mov %d8,7
    counter_core_id = p_counter_db->core_id;
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
800080d2:	ff 2f 2f 80 	jge.u %d15,2,80008130 <osEE_st_start_rel+0x92>
    ev = E_OS_STATE;
  } else {
/* Initialize ST data structure
    (Even though the ST is Reenabled it has to restart from the beginning) */
    
    p_st_cb->p_next_table = NULL;
800080d6:	82 0f       	mov %d15,0
800080d8:	60 bf       	mov.a %a15,%d11
800080da:	68 0f       	st.w [%a15]0,%d15
    p_st_cb->position     = 0U;
800080dc:	82 02       	mov %d2,0
800080de:	68 32       	st.w [%a15]12,%d2
    p_st_cb->deviation    = 0;
800080e0:	82 03       	mov %d3,0
800080e2:	68 43       	st.w [%a15]16,%d3
    p_st_cb->st_status    = SCHEDULETABLE_RUNNING;
800080e4:	82 32       	mov %d2,3
800080e6:	68 22       	st.w [%a15]8,%d2
{
  VAR(TickType, AUTOMATIC) when;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
800080e8:	19 d2 04 00 	ld.w %d2,[%a13]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
800080ec:	cc d0       	ld.a %a15,[%a13]0
800080ee:	4c f1       	ld.w %d15,[%a15]4

  if ((maxallowedvalue - delta) >= value) {
800080f0:	0b e2 80 40 	sub %d4,%d2,%d14
800080f4:	46 02       	not %d2
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
800080f6:	42 f2       	add %d2,%d15
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
800080f8:	12 e3       	add %d3,%d15,%d14
800080fa:	42 e2       	add %d2,%d14
800080fc:	0b f4 30 f1 	lt.u %d15,%d4,%d15
80008100:	2b 32 40 ff 	sel %d15,%d15,%d2,%d3
    p_st_cb->start        = osEE_counter_eval_when(p_counter_db, offset);
80008104:	60 bf       	mov.a %a15,%d11
80008106:	68 1f       	st.w [%a15]4,%d15

    if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
80008108:	60 af       	mov.a %a15,%d10
8000810a:	08 83       	ld.bu %d3,[%a15]8
8000810c:	df 13 07 80 	jne %d3,1,8000811a <osEE_st_start_rel+0x7c>
      /* Re-turn on the trigger, that is in handling, since is handling I'll set
         'here' when based on offset */
      p_trigger_cb->when   = p_st_cb->start;
80008110:	68 1f       	st.w [%a15]4,%d15
      p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
80008112:	82 4f       	mov %d15,4
80008114:	28 8f       	st.b [%a15]8,%d15

      osEE_counter_insert_rel_trigger(p_counter_db, p_trigger_db,
        offset  + (*p_st_db->p_expiry_point_array)[0].offset
      );
    }
    ev = E_OK;
80008116:	82 08       	mov %d8,0
80008118:	3c 0c       	j 80008130 <osEE_st_start_rel+0x92>
         'here' when based on offset */
      p_trigger_cb->when   = p_st_cb->start;
      p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
    } else {
      /* Turn On the Trigger */
      p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000811a:	82 2f       	mov %d15,2
8000811c:	60 af       	mov.a %a15,%d10
8000811e:	28 8f       	st.b [%a15]8,%d15

      osEE_counter_insert_rel_trigger(p_counter_db, p_trigger_db,
        offset  + (*p_st_db->p_expiry_point_array)[0].offset
80008120:	cc c2       	ld.a %a15,[%a12]8
      p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
    } else {
      /* Turn On the Trigger */
      p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;

      osEE_counter_insert_rel_trigger(p_counter_db, p_trigger_db,
80008122:	48 04       	ld.w %d4,[%a15]0
80008124:	40 d4       	mov.aa %a4,%a13
80008126:	60 c5       	mov.a %a5,%d12
80008128:	42 e4       	add %d4,%d14
8000812a:	6d ff f0 fc 	call 80007b0a <osEE_counter_insert_rel_trigger>
        offset  + (*p_st_db->p_expiry_point_array)[0].offset
      );
    }
    ev = E_OK;
8000812e:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80008130:	02 d4       	mov %d4,%d13
80008132:	6d 00 da 01 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
80008136:	cc 24       	ld.a %a15,[%a2]16
80008138:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000813c:	82 0f       	mov %d15,0
8000813e:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
80008140:	02 82       	mov %d2,%d8
80008142:	00 90       	ret 

80008144 <osEE_st_start_abs>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_DATA) p_st_db,
  VAR(TickType,   AUTOMATIC)                      start
)
{
80008144:	40 ae       	mov.aa %a14,%sp
80008146:	80 4d       	mov.d %d13,%a4
80008148:	40 5c       	mov.aa %a12,%a5
8000814a:	02 4e       	mov %d14,%d4
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
8000814c:	54 5a       	ld.w %d10,[%a5]
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_trigger_db;
8000814e:	19 5b 04 00 	ld.w %d11,[%a5]4
  CONSTP2VAR(OsEE_SchedTabCB, AUTOMATIC, OS_APPL_DATA)
    p_st_cb = osEE_st_get_cb(p_st_db);
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_st_get_trigger_db(p_st_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
80008152:	60 bf       	mov.a %a15,%d11
80008154:	c8 0d       	ld.a %a13,[%a15]0
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
80008156:	39 4c 10 00 	ld.bu %d12,[%a4]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000815a:	02 c4       	mov %d4,%d12
8000815c:	6d 00 c5 01 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
80008160:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80008162:	82 18       	mov %d8,1
80008164:	82 09       	mov %d9,0
80008166:	0b 89 10 28 	mov %e2,%d9,%d8
8000816a:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000816e:	df 02 fa ff 	jne %d2,0,80008162 <osEE_st_start_abs+0x1e>
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
80008172:	0c d8       	ld.bu %d15,[%a13]8
    ev = E_OS_STATE;
80008174:	82 78       	mov %d8,7
    counter_core_id = p_counter_db->core_id;
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
80008176:	ff 2f 23 80 	jge.u %d15,2,800081bc <osEE_st_start_abs+0x78>
    ev = E_OS_STATE;
  } else {
/* Initialize ST data structure
   (Even though the ST is Reenabled it has to restart from the beginning) */
    p_st_cb->p_next_table = NULL;
8000817a:	82 0f       	mov %d15,0
8000817c:	60 af       	mov.a %a15,%d10
8000817e:	68 0f       	st.w [%a15]0,%d15
    p_st_cb->position     = 0U;
80008180:	82 02       	mov %d2,0
80008182:	68 32       	st.w [%a15]12,%d2
    p_st_cb->deviation    = 0;
80008184:	82 03       	mov %d3,0
80008186:	68 43       	st.w [%a15]16,%d3
    p_st_cb->st_status    =
80008188:	39 cf 10 00 	ld.bu %d15,[%a12]16
8000818c:	ba 1f       	eq %d15,%d15,1
8000818e:	82 72       	mov %d2,7
80008190:	ab 32 80 ff 	sel %d15,%d15,%d2,3
80008194:	68 2f       	st.w [%a15]8,%d15
      (p_st_db->sync_strategy == OSEE_SCHEDTABLE_SYNC_IMPLICIT)?
        SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS:
        SCHEDULETABLE_RUNNING;
    p_st_cb->start        = start;
80008196:	68 1e       	st.w [%a15]4,%d14

    if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
80008198:	0c d8       	ld.bu %d15,[%a13]8
8000819a:	5e 17       	jne %d15,1,800081a8 <osEE_st_start_abs+0x64>
      /* Re-turn on the trigger, that is in handling, since is handling I'll set
         here 'when' based on start */
      p_trigger_cb->when   = start;
8000819c:	59 de 04 00 	st.w [%a13]4,%d14
      p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
800081a0:	82 4f       	mov %d15,4
800081a2:	2c d8       	st.b [%a13]8,%d15
      osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
        start + (*p_st_db->p_expiry_point_array)[0].offset
      );
    }

    ev = E_OK;
800081a4:	82 08       	mov %d8,0
800081a6:	3c 0b       	j 800081bc <osEE_st_start_abs+0x78>
         here 'when' based on start */
      p_trigger_cb->when   = start;
      p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
    } else {
      /* Turn On the Trigger */
      p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
800081a8:	82 2f       	mov %d15,2
800081aa:	2c d8       	st.b [%a13]8,%d15

      osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
        start + (*p_st_db->p_expiry_point_array)[0].offset
800081ac:	cc c2       	ld.a %a15,[%a12]8
      p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
    } else {
      /* Turn On the Trigger */
      p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;

      osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
800081ae:	48 04       	ld.w %d4,[%a15]0
800081b0:	60 d4       	mov.a %a4,%d13
800081b2:	60 b5       	mov.a %a5,%d11
800081b4:	42 e4       	add %d4,%d14
800081b6:	6d ff 79 fc 	call 80007aa8 <osEE_counter_insert_abs_trigger>
        start + (*p_st_db->p_expiry_point_array)[0].offset
      );
    }

    ev = E_OK;
800081ba:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
800081bc:	02 c4       	mov %d4,%d12
800081be:	6d 00 94 01 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
800081c2:	cc 24       	ld.a %a15,[%a2]16
800081c4:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
800081c8:	82 0f       	mov %d15,0
800081ca:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
800081cc:	02 82       	mov %d2,%d8
800081ce:	00 90       	ret 

800081d0 <osEE_st_stop>:
FUNC(StatusType, OS_CODE)
  osEE_st_stop
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)  p_st_db
)
{
800081d0:	40 ae       	mov.aa %a14,%sp
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
800081d2:	54 4a       	ld.w %d10,[%a4]
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_trigger_db;
800081d4:	99 4c 04 00 	ld.a %a12,[%a4]4
  CONSTP2VAR(OsEE_SchedTabCB, AUTOMATIC, OS_APPL_DATA)
    p_st_cb = osEE_st_get_cb(p_st_db);
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_st_get_trigger_db(p_st_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
800081d8:	d4 cd       	ld.a %a13,[%a12]
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
800081da:	19 cb 04 00 	ld.w %d11,[%a12]4
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
800081de:	60 b2       	mov.a %a2,%d11
800081e0:	39 2c 10 00 	ld.bu %d12,[%a2]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
800081e4:	02 c4       	mov %d4,%d12
800081e6:	6d 00 80 01 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
800081ea:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
800081ec:	82 18       	mov %d8,1
800081ee:	82 09       	mov %d9,0
800081f0:	0b 89 10 28 	mov %e2,%d9,%d8
800081f4:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
800081f8:	df 02 fa ff 	jne %d2,0,800081ec <osEE_st_stop+0x1c>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
800081fc:	0c d8       	ld.bu %d15,[%a13]8
/* [SWS_Os_00280] If the schedule table with identifier <ScheduleTableID> is
   in state SCHEDULETABLE_STOPPED when calling StopScheduleTable(),
   StopScheduleTable() shall return E_OS_NOFUNC. */
    ev = E_OS_NOFUNC;
800081fe:	82 58       	mov %d8,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
80008200:	bf 2f 23 80 	jlt.u %d15,2,80008246 <osEE_st_stop+0x76>
/* [SWS_Os_00280] If the schedule table with identifier <ScheduleTableID> is
   in state SCHEDULETABLE_STOPPED when calling StopScheduleTable(),
   StopScheduleTable() shall return E_OS_NOFUNC. */
    ev = E_OS_NOFUNC;
  } else if (p_trigger_cb->status >= OSEE_TRIGGER_EXPIRED) {
80008204:	bf 3f 10 80 	jlt.u %d15,3,80008224 <osEE_st_stop+0x54>
    p_trigger_cb->status = OSEE_TRIGGER_CANCELED;
80008208:	82 1f       	mov %d15,1
8000820a:	2c d8       	st.b [%a13]8,%d15

    /* Stop Next ST if needed */
    if (p_st_cb->p_next_table != NULL) {
8000820c:	60 a2       	mov.a %a2,%d10
8000820e:	cc 20       	ld.a %a15,[%a2]0
80008210:	bc f4       	jz.a %a15,80008218 <osEE_st_stop+0x48>
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
80008212:	c8 0f       	ld.a %a15,[%a15]0
      osEE_st_get_cb(p_st_cb->p_next_table)->st_status = SCHEDULETABLE_STOPPED;
80008214:	82 0f       	mov %d15,0
80008216:	68 2f       	st.w [%a15]8,%d15
    }

    p_st_cb->st_status = SCHEDULETABLE_STOPPED;
80008218:	82 02       	mov %d2,0
8000821a:	60 a2       	mov.a %a2,%d10
8000821c:	59 22 08 00 	st.w [%a2]8,%d2

    ev = E_OK;
80008220:	82 08       	mov %d8,0
80008222:	3c 12       	j 80008246 <osEE_st_stop+0x76>
  } else {
    p_trigger_cb->status = OSEE_TRIGGER_INACTIVE;
80008224:	82 0f       	mov %d15,0
80008226:	2c d8       	st.b [%a13]8,%d15

    /* Stop Next ST if needed */
    if (p_st_cb->p_next_table != NULL) {
80008228:	60 a2       	mov.a %a2,%d10
8000822a:	cc 20       	ld.a %a15,[%a2]0
8000822c:	bc f4       	jz.a %a15,80008234 <osEE_st_stop+0x64>
8000822e:	c8 0f       	ld.a %a15,[%a15]0
      osEE_st_get_cb(p_st_cb->p_next_table)->st_status = SCHEDULETABLE_STOPPED;
80008230:	82 0f       	mov %d15,0
80008232:	68 2f       	st.w [%a15]8,%d15
    }

    p_st_cb->st_status = SCHEDULETABLE_STOPPED;
80008234:	82 02       	mov %d2,0
80008236:	60 a2       	mov.a %a2,%d10
80008238:	59 22 08 00 	st.w [%a2]8,%d2

    osEE_counter_cancel_trigger(p_counter_db, p_trigger_db);
8000823c:	60 b4       	mov.a %a4,%d11
8000823e:	40 c5       	mov.aa %a5,%a12
80008240:	6d ff 76 fc 	call 80007b2c <osEE_counter_cancel_trigger>

    ev = E_OK;
80008244:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
80008246:	02 c4       	mov %d4,%d12
80008248:	6d 00 4f 01 	call 800084e6 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
8000824c:	cc 24       	ld.a %a15,[%a2]16
8000824e:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80008252:	82 0f       	mov %d15,0
80008254:	68 0f       	st.w [%a15]0,%d15
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  return ev;
}
80008256:	02 82       	mov %d2,%d8
80008258:	00 90       	ret 

8000825a <osEE_st_syncronize>:
  osEE_st_syncronize
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST)  p_st_db,
  VAR(TickType, AUTOMATIC)                          value
)
{
8000825a:	40 ae       	mov.aa %a14,%sp
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_trigger_db;
8000825c:	99 4c 04 00 	ld.a %a12,[%a4]4
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_CONST)
    p_trigger_db = osEE_st_get_trigger_db(p_st_db);
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
    p_counter_db = p_trigger_db->p_counter_db;
80008260:	19 c8 04 00 	ld.w %d8,[%a12]4
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
80008264:	d4 c2       	ld.a %a2,[%a12]
(
  P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_st_db->p_st_cb;
80008266:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_SchedTabCB, AUTOMATIC, OS_APPL_DATA)
    p_st_cb = osEE_st_get_cb(p_st_db);

/* Check if the ScheduleTable is Started */
  if ((p_st_cb->st_status & SCHEDULETABLE_RUNNING) == SCHEDULETABLE_RUNNING) {
80008268:	4c f2       	ld.w %d15,[%a15]8
8000826a:	16 03       	and %d15,3
8000826c:	df 3f 3c 80 	jne %d15,3,800082e4 <osEE_st_syncronize+0x8a>
80008270:	40 4d       	mov.aa %a13,%a4
/* Schedule Table position locals */
    VAR(TickType, AUTOMATIC)      st_pos;
    VAR(TickType, AUTOMATIC)      next_when;
    VAR(TickType, AUTOMATIC)      temp_deviation_unsigned; /* MISRA C 10.8 */
    VAR(TickDeltaType, AUTOMATIC) temp_deviation;
    CONST(MemSize, AUTOMATIC) position = p_st_cb->position;
80008272:	48 35       	ld.w %d5,[%a15]12
    valid, SyncScheduleTable() shall provide the Operating System module
    with the current synchronization count for the given schedule table.
    (It is used to synchronize the processing of the schedule table to the
     synchronization counter.) */
/* Evaluate ST "tick position" */
    next_when = p_trigger_cb->when;
80008274:	19 23 04 00 	ld.w %d3,[%a2]4
    st_pos = next_when - p_st_cb->start;
80008278:	48 12       	ld.w %d2,[%a15]4
8000827a:	0b 23 80 20 	sub %d2,%d3,%d2

/* Evaluate Schedule Table Deviation before synchronization */
    temp_deviation_unsigned = st_pos - value;
8000827e:	a2 42       	sub %d2,%d4
    temp_deviation = (TickDeltaType)temp_deviation_unsigned;
80008280:	02 2f       	mov %d15,%d2
    is adjustable AND the table is ahead of the sync counter
    (TableTicksAheadOfSyncCounter > TableTicksBehindOfSyncCounter)
    THEN the OS shall set the next EP to expire delay +
    min(MaxLengthen, Deviation) ticks from the current expiry. */
    /* Try to synchronize */
    if (temp_deviation != 0) {
80008282:	df 02 24 00 	jeq %d2,0,800082ca <osEE_st_syncronize+0x70>
      if (temp_deviation > 0) {
80008286:	8e 2c       	jlez %d2,8000829e <osEE_st_syncronize+0x44>
        CONST(TickType, AUTOMATIC)
          abs_temp_dev = (TickType)temp_deviation;
        CONST(TickType, AUTOMATIC)
          max_shorten = (*p_st_db->p_expiry_point_array)[position].max_shorten;
80008288:	4c 42       	ld.w %d15,[%a4]8
8000828a:	13 45 21 4f 	madd %d4,%d15,%d5,20
8000828e:	60 42       	mov.a %a2,%d4
        CONST(TickType, AUTOMATIC)
          shortening =
80008290:	4c 23       	ld.w %d15,[%a2]12
80008292:	0b f2 90 f1 	min.u %d15,%d2,%d15
            (max_shorten < abs_temp_dev)? max_shorten: abs_temp_dev;

        /* Evaluate Next-When */
        next_when      -= shortening;
80008296:	0b f3 80 90 	sub %d9,%d3,%d15
        /* Adjust deviation */
        temp_deviation -= (TickDeltaType)shortening; 
8000829a:	5a f2       	sub %d15,%d2,%d15
8000829c:	3c 0e       	j 800082b8 <osEE_st_syncronize+0x5e>
      } else {
        CONST(TickType, AUTOMATIC)
          abs_temp_dev = (TickType)(-temp_deviation);
8000829e:	8b 02 00 f1 	rsub %d15,%d2,0
        VAR(TickType, AUTOMATIC)
          max_lengthen = (*p_st_db->p_expiry_point_array)[position].
800082a2:	19 44 08 00 	ld.w %d4,[%a4]8
800082a6:	13 45 21 64 	madd %d6,%d4,%d5,20
800082aa:	60 62       	mov.a %a2,%d6
            max_lengthen;
        CONST(TickType, AUTOMATIC)
          lengthening =
800082ac:	19 24 10 00 	ld.w %d4,[%a2]16
800082b0:	0b 4f 90 f1 	min.u %d15,%d15,%d4
            (max_lengthen < abs_temp_dev)? max_lengthen: abs_temp_dev;

        /* Evaluate Next-When */
        next_when       += lengthening;
800082b4:	12 39       	add %d9,%d15,%d3
        /* Adjust deviation */
        temp_deviation  -= (TickDeltaType)lengthening;
800082b6:	5a f2       	sub %d15,%d2,%d15
      }

      /* Cancel the alarm related with the schedule table */
      osEE_counter_cancel_trigger(p_counter_db, p_trigger_db);
800082b8:	60 84       	mov.a %a4,%d8
800082ba:	40 c5       	mov.aa %a5,%a12
800082bc:	6d ff 38 fc 	call 80007b2c <osEE_counter_cancel_trigger>
      /* Restart the alarm related with the schedule table */
      osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
800082c0:	60 84       	mov.a %a4,%d8
800082c2:	40 c5       	mov.aa %a5,%a12
800082c4:	02 94       	mov %d4,%d9
800082c6:	6d ff f1 fb 	call 80007aa8 <osEE_counter_insert_abs_trigger>
        next_when);
    }

    /* if st abs(deviation) < st precision -> synchronized! */  
    if ((temp_deviation < p_st_db->precision) &&
800082ca:	19 d2 18 00 	ld.w %d2,[%a13]24
800082ce:	7f 2f 08 00 	jge %d15,%d2,800082de <osEE_st_syncronize+0x84>
        (temp_deviation > -p_st_db->precision))
800082d2:	32 52       	rsub %d2
      osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
        next_when);
    }

    /* if st abs(deviation) < st precision -> synchronized! */  
    if ((temp_deviation < p_st_db->precision) &&
800082d4:	7f f2 05 00 	jge %d2,%d15,800082de <osEE_st_syncronize+0x84>
    {
      /* [SWS_Os_00418]: The Operating System module shall set the state of
          an explicitly synchronized schedule table to
          "running and synchronous" if the deviation is less than or equal to
          the configured OsScheduleTblExplicitPrecision threshold. */
      p_st_cb->st_status  = SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS;
800082d8:	82 72       	mov %d2,7
800082da:	68 22       	st.w [%a15]8,%d2
800082dc:	3c 03       	j 800082e2 <osEE_st_syncronize+0x88>
      /* Try to synchronize */
      /* [SWS_Os_00419]: The Operating System module shall set the state of
          an explicitly synchronized schedule table to "running" if the
          deviation is greater than the configured
          OsScheduleTblExplicitPrecision threshold. */
      p_st_cb->st_status  = SCHEDULETABLE_RUNNING;
800082de:	82 32       	mov %d2,3
800082e0:	68 22       	st.w [%a15]8,%d2
    }

    p_st_cb->deviation = temp_deviation;
800082e2:	68 4f       	st.w [%a15]16,%d15
       (p_schedule_table_RAM->status == SCHEDULETABLE_WAITING) */
    /* TODO: handle Schedule Table Synchronous Start */
  }

  return E_OK;
}
800082e4:	82 02       	mov %d2,0
800082e6:	00 90       	ret 

800082e8 <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
800082e8:	40 ae       	mov.aa %a14,%sp
800082ea:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
800082ec:	99 52 0c 00 	ld.a %a2,[%a5]12
800082f0:	0c 22       	ld.bu %d15,[%a2]2
800082f2:	5e 28       	jne %d15,2,80008302 <osEE_change_context_from_running+0x1a>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
800082f4:	40 54       	mov.aa %a4,%a5
800082f6:	99 55 04 00 	ld.a %a5,[%a5]4
800082fa:	c8 16       	ld.a %a6,[%a15]4
800082fc:	6d 00 43 01 	call 80008582 <osEE_hal_save_ctx_and_restore_ctx>
80008300:	00 90       	ret 
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
80008302:	40 54       	mov.aa %a4,%a5
80008304:	99 55 04 00 	ld.a %a5,[%a5]4
80008308:	c8 16       	ld.a %a6,[%a15]4
8000830a:	6d 00 5b 01 	call 800085c0 <osEE_hal_save_ctx_and_ready2stacked>
8000830e:	00 90       	ret 

80008310 <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
80008310:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80008312:	cc 53       	ld.a %a15,[%a5]12
80008314:	0c f2       	ld.bu %d15,[%a15]2
80008316:	5e 27       	jne %d15,2,80008324 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
80008318:	40 54       	mov.aa %a4,%a5
8000831a:	99 55 04 00 	ld.a %a5,[%a5]4
8000831e:	6d 00 44 01 	call 800085a6 <osEE_hal_restore_ctx>
80008322:	00 90       	ret 
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
80008324:	40 54       	mov.aa %a4,%a5
80008326:	99 55 04 00 	ld.a %a5,[%a5]4
8000832a:	6d 00 5d 01 	call 800085e4 <osEE_hal_ready2stacked>
8000832e:	00 90       	ret 

80008330 <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
80008330:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
80008332:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
80008336:	cc 40       	ld.a %a15,[%a4]0
80008338:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000833a:	cc 50       	ld.a %a15,[%a5]0
8000833c:	3c 02       	j 80008340 <osEE_idle_task_terminate+0x10>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000833e:	60 ff       	mov.a %a15,%d15
80008340:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
80008342:	8b 0f 20 22 	ne %d2,%d15,0
80008346:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000834a:	df 02 fa ff 	jne %d2,0,8000833e <osEE_idle_task_terminate+0xe>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000834e:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
80008350:	6d 00 2b 01 	call 800085a6 <osEE_hal_restore_ctx>
80008354:	00 90       	ret 

80008356 <osEE_cpu_startos>:
}
#endif /* OSEE_SINGLECORE */
#endif /* OSEE_TC_HAS_ISR1_TO_CONF */

OsEE_bool osEE_cpu_startos(void)
{
80008356:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008358:	4d c0 e1 8f 	mfcr %d8,$core_id
8000835c:	8f f8 0f 81 	and %d8,%d8,255
  MemSize tdb_size;
  OsEE_KDB * const p_kdb = osEE_get_kernel();
  CoreIdType const curr_core_id = osEE_get_curr_core_id();

#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_0) {
80008360:	df 08 19 80 	jne %d8,0,80008392 <osEE_cpu_startos+0x3c>
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_SYSTEM_TIMER))
    osEE_tc_stm_set_clockpersec();
80008364:	6d ff 33 e9 	call 800055ca <osEE_tc_stm_set_clockpersec>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80008368:	3b 10 40 f0 	mov %d15,1025
8000836c:	91 40 00 ff 	movh.a %a15,61444
80008370:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
80008374:	68 0f       	st.w [%a15]0,%d15
80008376:	3b 10 c0 f0 	mov %d15,3073
8000837a:	91 40 00 ff 	movh.a %a15,61444
8000837e:	d9 ff 04 09 	lea %a15,[%a15]-28668 <f0039004 <_SMALL_DATA4_+0x40031004>>
80008382:	68 0f       	st.w [%a15]0,%d15
80008384:	3b 10 40 f1 	mov %d15,5121
80008388:	91 40 00 ff 	movh.a %a15,61444
8000838c:	d9 ff 08 09 	lea %a15,[%a15]-28664 <f0039008 <_SMALL_DATA4_+0x40031008>>
80008390:	68 0f       	st.w [%a15]0,%d15
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
80008392:	91 00 00 f8 	movh.a %a15,32768
80008396:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
8000839a:	48 49       	ld.w %d9,[%a15]16
8000839c:	c2 f9       	add %d9,-1
  for (i = 0U; i < tdb_size; ++i) {
8000839e:	df 09 37 00 	jeq %d9,0,8000840c <osEE_cpu_startos+0xb6>
800083a2:	8f 38 00 f1 	and %d15,%d8,3
800083a6:	8f bf 00 b0 	sh %d11,%d15,11
800083aa:	82 0f       	mov %d15,0
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
800083ac:	91 00 00 f8 	movh.a %a15,32768
800083b0:	d9 ff 28 00 	lea %a15,[%a15]40 <80000028 <osEE_kdb_var>>
800083b4:	48 3a       	ld.w %d10,[%a15]12
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
800083b6:	7b 00 00 d8 	movh %d13,32768
800083ba:	1b ed 27 d5 	addi %d13,%d13,21118
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
800083be:	bb f0 ff cf 	mov.u %d12,65535
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
800083c2:	60 a2       	mov.a %a2,%d10
800083c4:	90 2f       	addsc.a %a15,%a2,%d15,2
800083c6:	c8 04       	ld.a %a4,[%a15]0
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
800083c8:	39 42 1f 00 	ld.bu %d2,[%a4]31
800083cc:	5f 82 1d 80 	jne %d2,%d8,80008406 <osEE_cpu_startos+0xb0>
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
800083d0:	39 42 14 00 	ld.bu %d2,[%a4]20
800083d4:	df 22 19 80 	jne %d2,2,80008406 <osEE_cpu_startos+0xb0>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
800083d8:	19 42 18 00 	ld.w %d2,[%a4]24
800083dc:	5f d2 05 80 	jne %d2,%d13,800083e6 <osEE_cpu_startos+0x90>
          osEE_tc_initialize_system_timer(p_tdb);
800083e0:	6d ff 67 e7 	call 800052ae <osEE_tc_initialize_system_timer>
800083e4:	3c 11       	j 80008406 <osEE_cpu_startos+0xb0>
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
800083e6:	b9 42 08 00 	ld.hu %d2,[%a4]8
800083ea:	5f c2 0e 00 	jeq %d2,%d12,80008406 <osEE_cpu_startos+0xb0>
800083ee:	60 22       	mov.a %a2,%d2
800083f0:	d9 2f 00 08 	lea %a15,[%a2]-32768
800083f4:	11 4f 00 ff 	addih.a %a15,%a15,61444
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
800083f8:	39 42 1c 00 	ld.bu %d2,[%a4]28
800083fc:	c2 12       	add %d2,1
800083fe:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80008402:	a6 b2       	or %d2,%d11
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80008404:	68 02       	st.w [%a15]0,%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
80008406:	c2 1f       	add %d15,1
80008408:	5f f9 dd ff 	jne %d9,%d15,800083c2 <osEE_cpu_startos+0x6c>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000840c:	40 94       	mov.aa %a4,%a9
8000840e:	40 43       	mov.aa %a3,%a4
  {
    OsEE_stack * p_stack;
    OsEE_CDB   * const p_cdb = osEE_get_curr_core();

    /* number of stacks excluded the system stack which is the last one */
    MemSize const stack_number = p_cdb->chdb.stack_num - 1U;
80008410:	99 42 08 00 	ld.a %a2,[%a4]8
80008414:	b0 f2       	add.a %a2,-1
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
80008416:	bd 02 16 00 	jz.a %a2,80008442 <osEE_cpu_startos+0xec>
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);

      p_stack = (OsEE_stack *)(*p_cdb->chdb.p_sdb_array)[i].p_bos;
      for (j = 0U; j <= stack_words; ++j)
8000841a:	82 05       	mov %d5,0
      {
        (*p_stack) = OSEE_FILL_PATTERN;
8000841c:	7b 60 5a 3a 	movh %d3,42406
80008420:	1b 53 5a 3a 	addi %d3,%d3,-23131
80008424:	82 04       	mov %d4,0
80008426:	b0 f2       	add.a %a2,-1
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
      MemSize j;
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);
80008428:	cc 30       	ld.a %a15,[%a3]0
8000842a:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
    MemSize const stack_number = p_cdb->chdb.stack_num - 1U;
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
      MemSize j;
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
8000842e:	48 12       	ld.w %d2,[%a15]4
80008430:	06 e2       	sh %d2,-2
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);

      p_stack = (OsEE_stack *)(*p_cdb->chdb.p_sdb_array)[i].p_bos;
80008432:	c8 0f       	ld.a %a15,[%a15]0
      for (j = 0U; j <= stack_words; ++j)
80008434:	02 5f       	mov %d15,%d5
      {
        (*p_stack) = OSEE_FILL_PATTERN;
80008436:	64 f3       	st.w [%a15+],%d3
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);

      p_stack = (OsEE_stack *)(*p_cdb->chdb.p_sdb_array)[i].p_bos;
      for (j = 0U; j <= stack_words; ++j)
80008438:	c2 1f       	add %d15,1
8000843a:	7f f2 fe ff 	jge.u %d2,%d15,80008436 <osEE_cpu_startos+0xe0>
    OsEE_CDB   * const p_cdb = osEE_get_curr_core();

    /* number of stacks excluded the system stack which is the last one */
    MemSize const stack_number = p_cdb->chdb.stack_num - 1U;
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
8000843e:	c2 14       	add %d4,1
80008440:	fc 24       	loop %a2,80008428 <osEE_cpu_startos+0xd2>
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
80008442:	40 af       	mov.aa %a15,%sp
80008444:	80 ff       	mov.d %d15,%a15
      }
    }
    /* Initialize System Stack */
    {
      OsEE_stack const * const p_curr_sp = osEE_get_SP();
      p_stack = (OsEE_stack *)
80008446:	54 42       	ld.w %d2,[%a4]
80008448:	19 43 08 00 	ld.w %d3,[%a4]8
8000844c:	60 22       	mov.a %a2,%d2
8000844e:	01 23 03 f6 	addsc.a %a15,%a2,%d3,3
80008452:	99 ff f8 ff 	ld.a %a15,[%a15]-8
        (*p_cdb->chdb.p_sdb_array)[(p_cdb->chdb.stack_num - 1U)].p_bos;

      while (p_stack < p_curr_sp) {
80008456:	80 f2       	mov.d %d2,%a15
80008458:	7f f2 0a 80 	jge.u %d2,%d15,8000846c <osEE_cpu_startos+0x116>
        (*p_stack) = OSEE_FILL_PATTERN;
8000845c:	7b 60 5a 2a 	movh %d2,42406
80008460:	1b 52 5a 2a 	addi %d2,%d2,-23131
80008464:	64 f2       	st.w [%a15+],%d2
    {
      OsEE_stack const * const p_curr_sp = osEE_get_SP();
      p_stack = (OsEE_stack *)
        (*p_cdb->chdb.p_sdb_array)[(p_cdb->chdb.stack_num - 1U)].p_bos;

      while (p_stack < p_curr_sp) {
80008466:	80 f3       	mov.d %d3,%a15
80008468:	3f f3 fe ff 	jlt.u %d3,%d15,80008464 <osEE_cpu_startos+0x10e>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000846c:	82 12       	mov %d2,1
8000846e:	00 90       	ret 

80008470 <osEE_hal_sync_barrier>:
#include "ee_internal.h"

#if (!defined(OSEE_SINGLECORE))
void osEE_hal_sync_barrier(OsEE_barrier * p_bar,
  OsEE_reg const volatile * p_wait_mask, OsEE_kernel_cb p_synch_cb)
{
80008470:	40 ae       	mov.aa %a14,%sp
80008472:	40 4f       	mov.aa %a15,%a4
80008474:	40 5d       	mov.aa %a13,%a5
80008476:	40 6c       	mov.aa %a12,%a6
  CoreMaskType const exit_mask  = (0xFFFFFFFFU ^
    (((CoreMaskType)0x1U << OS_CORE_ID_ARR_SIZE) - 1U));

  OsEE_reg wait_mask, all_exited;

  if ((p_bar != NULL) && (p_wait_mask != NULL)) {
80008478:	80 52       	mov.d %d2,%a5
8000847a:	80 43       	mov.d %d3,%a4
8000847c:	8b 02 20 f2 	ne %d15,%d2,0
80008480:	8b 03 20 f4 	and.ne %d15,%d3,0
80008484:	ee 05       	jnz %d15,8000848e <osEE_hal_sync_barrier+0x1e>
80008486:	00 90       	ret 
    /* If not all cores have left the previous use of this barrier
       wait for it. */
    while ((p_bar->value & exit_mask) != 0U) {
      if (p_synch_cb != NULL) {
80008488:	bc c3       	jz.a %a12,8000848e <osEE_hal_sync_barrier+0x1e>
        p_synch_cb();
8000848a:	2d 0c 00 00 	calli %a12
  OsEE_reg wait_mask, all_exited;

  if ((p_bar != NULL) && (p_wait_mask != NULL)) {
    /* If not all cores have left the previous use of this barrier
       wait for it. */
    while ((p_bar->value & exit_mask) != 0U) {
8000848e:	4c f0       	ld.w %d15,[%a15]0
80008490:	8f 7f c0 f1 	andn %d15,%d15,7
80008494:	ee fa       	jnz %d15,80008488 <osEE_hal_sync_barrier+0x18>
        p_synch_cb();
      }
    }

    /* Set current CPU as entered */
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
80008496:	80 f8       	mov.d %d8,%a15
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008498:	4d c0 e1 2f 	mfcr %d2,$core_id
8000849c:	8f f2 0f 21 	and %d2,%d2,255
/** Insert LDMST instruction. Note that all operands must be word-aligned. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_imask_ldmst(OsEE_reg volatile * const p_var, OsEE_reg value,
    OsEE_reg offset, OsEE_reg width)
{
  __builtin_tricore_ldmst((volatile void *)p_var, value, offset, width);
800084a0:	d7 10 21 22 	imask %e2,1,%d2,1
800084a4:	49 f2 40 08 	ldmst [%a15]0,%e2
      (OsEE_reg)osEE_get_curr_core_id(), 1U);

    /* Snapshot of the wait mask */
    wait_mask = (*p_wait_mask);
800084a8:	54 d2       	ld.w %d2,[%a13]
    while ((p_bar->value & wait_mask) != wait_mask) {
800084aa:	4c f0       	ld.w %d15,[%a15]0
800084ac:	26 2f       	and %d15,%d2
800084ae:	5f f2 0a 00 	jeq %d2,%d15,800084c2 <osEE_hal_sync_barrier+0x52>
      /* Wait for all other cores/CPUs */
      if (p_synch_cb != NULL) {
800084b2:	bc c3       	jz.a %a12,800084b8 <osEE_hal_sync_barrier+0x48>
        p_synch_cb();
800084b4:	2d 0c 00 00 	calli %a12
      }
      /* Refresh the snapshot of the wait mask */
      wait_mask = (*p_wait_mask);
800084b8:	4c d0       	ld.w %d15,[%a13]0
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
      (OsEE_reg)osEE_get_curr_core_id(), 1U);

    /* Snapshot of the wait mask */
    wait_mask = (*p_wait_mask);
    while ((p_bar->value & wait_mask) != wait_mask) {
800084ba:	48 02       	ld.w %d2,[%a15]0
800084bc:	26 f2       	and %d2,%d15
800084be:	5f f2 fa ff 	jne %d2,%d15,800084b2 <osEE_hal_sync_barrier+0x42>
800084c2:	4d c0 e1 2f 	mfcr %d2,$core_id

    all_exited = (wait_mask << OS_CORE_ID_ARR_SIZE) | wait_mask;

    /* Set current CPU as exited */
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
      ((OsEE_reg)osEE_get_curr_core_id() + (OsEE_reg)OS_CORE_ID_ARR_SIZE), 1U);
800084c6:	8f f2 0f 21 	and %d2,%d2,255
    } 

    all_exited = (wait_mask << OS_CORE_ID_ARR_SIZE) | wait_mask;

    /* Set current CPU as exited */
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
800084ca:	c2 32       	add %d2,3
800084cc:	d7 10 21 22 	imask %e2,1,%d2,1
800084d0:	60 8f       	mov.a %a15,%d8
800084d2:	49 f2 40 08 	ldmst [%a15]0,%e2
      }
      /* Refresh the snapshot of the wait mask */
      wait_mask = (*p_wait_mask);
    } 

    all_exited = (wait_mask << OS_CORE_ID_ARR_SIZE) | wait_mask;
800084d6:	8f 3f 00 40 	sh %d4,%d15,3
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
800084da:	d2 02       	mov %e2,0
800084dc:	0f f4 a0 30 	or %d3,%d4,%d15
800084e0:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
800084e4:	00 90       	ret 

800084e6 <osEE_get_core>:
    /* Try to reset the barrier */
    (void)osEE_tc_cmpswapw(&p_bar->value, 0U, all_exited);
  }
}

OsEE_CDB * osEE_get_core(CoreIdType core_id) {
800084e6:	40 ae       	mov.aa %a14,%sp
    case OS_CORE_ID_0:
      p_cdb = &osEE_cdb_var_core0;
    break;
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x02U)
    case OS_CORE_ID_1:
      p_cdb = &osEE_cdb_var_core1;
800084e8:	91 00 00 28 	movh.a %a2,32768
800084ec:	d9 22 04 20 	lea %a2,[%a2]132 <80000084 <osEE_cdb_var_core1>>
  }
}

OsEE_CDB * osEE_get_core(CoreIdType core_id) {
  OsEE_CDB * p_cdb;
  switch (core_id) {
800084f0:	df 14 10 00 	jeq %d4,1,80008510 <osEE_get_core+0x2a>
    case OS_CORE_ID_0:
      p_cdb = &osEE_cdb_var_core0;
800084f4:	91 00 00 28 	movh.a %a2,32768
800084f8:	d9 22 34 20 	lea %a2,[%a2]180 <800000b4 <osEE_cdb_var_core0>>
  }
}

OsEE_CDB * osEE_get_core(CoreIdType core_id) {
  OsEE_CDB * p_cdb;
  switch (core_id) {
800084fc:	76 4a       	jz %d4,80008510 <osEE_get_core+0x2a>
      p_cdb = &osEE_cdb_var_core1;
    break;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x02U */
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x04U)
    case OS_CORE_ID_2:
      p_cdb = &osEE_cdb_var_core2;
800084fe:	7b 00 00 f8 	movh %d15,32768
      p_cdb = &osEE_cdb_var_core6;
    break;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
    default:
      /* This can happen when we cycle on cores */
      p_cdb = NULL;
80008502:	1b 4f 05 f0 	addi %d15,%d15,84
80008506:	8b 24 00 42 	eq %d4,%d4,2
8000850a:	ab 0f 80 44 	sel %d4,%d4,%d15,0
8000850e:	60 42       	mov.a %a2,%d4
    break;
  }

  return p_cdb;
}
80008510:	00 90       	ret 

80008512 <osEE_hal_start_core>:

void osEE_hal_start_core(CoreIdType core_id) {
80008512:	40 ae       	mov.aa %a14,%sp
  switch (core_id) {
80008514:	df 14 05 00 	jeq %d4,1,8000851e <osEE_hal_start_core+0xc>
80008518:	df 24 0d 00 	jeq %d4,2,80008532 <osEE_hal_start_core+0x20>
8000851c:	3c 15       	j 80008546 <osEE_hal_start_core+0x34>
    case OS_CORE_ID_0:
    /* Nothing to do in this case */
    break;
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x02U)
    case OS_CORE_ID_1:
      OSEE_TC_CORE_PC(OS_CORE_ID_1).reg = (uint32_t)OSEE_CORE1_START_ADDR;
8000851e:	91 40 88 ff 	movh.a %a15,63620
80008522:	d9 ff c8 8f 	lea %a15,[%a15]-504 <f883fe08 <_SMALL_DATA4_+0x48837e08>>
80008526:	7b 00 00 f8 	movh %d15,32768
8000852a:	1b 0f b3 f4 	addi %d15,%d15,19248
8000852e:	68 0f       	st.w [%a15]0,%d15
    break;
80008530:	3c 0c       	j 80008548 <osEE_hal_start_core+0x36>
#endif /* OSEE_CORE_ID_VALID_MASK & 0x02U */
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x04U)
    case OS_CORE_ID_2:
      OSEE_TC_CORE_PC(OS_CORE_ID_2).reg = (uint32_t)OSEE_CORE2_START_ADDR;
80008532:	91 60 88 ff 	movh.a %a15,63622
80008536:	d9 ff c8 8f 	lea %a15,[%a15]-504 <f885fe08 <_SMALL_DATA4_+0x48857e08>>
8000853a:	7b 00 00 f8 	movh %d15,32768
8000853e:	1b 0f e6 f4 	addi %d15,%d15,20064
80008542:	68 0f       	st.w [%a15]0,%d15
    break;
80008544:	3c 02       	j 80008548 <osEE_hal_start_core+0x36>
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
    default:
      /* All possible masks have been handled above */
    break;
  }
  if (core_id != OS_CORE_ID_0) {
80008546:	76 4c       	jz %d4,8000855e <osEE_hal_start_core+0x4c>
#if (!defined(OSEE_TC_2G))
    OSEE_TC_CORE_DBGSR(core_id).bits.halt = OSEE_TC_DBGSR_RESET_HALT;
80008548:	8f 14 01 40 	sh %d4,%d4,17
8000854c:	60 42       	mov.a %a2,%d4
8000854e:	d9 2f c0 4f 	lea %a15,[%a2]-768
80008552:	11 2f 88 ff 	addih.a %a15,%a15,63618
80008556:	4c f0       	ld.w %d15,[%a15]0
80008558:	b7 2f 82 f0 	insert %d15,%d15,2,1,2
8000855c:	68 0f       	st.w [%a15]0,%d15
8000855e:	00 90       	ret 

80008560 <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80008560:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
80008564:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80008566:	0c 22       	ld.bu %d15,[%a2]2
80008568:	1e 27       	jeq %d15,2,80008576 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000856a:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000856c:	c8 1f       	ld.a %a15,[%a15]4
8000856e:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
80008570:	1d 00 3a 00 	j 800085e4 <osEE_hal_ready2stacked>
80008574:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
80008576:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
80008578:	c8 1f       	ld.a %a15,[%a15]4
8000857a:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000857c:	1d 00 15 00 	j 800085a6 <osEE_hal_restore_ctx>
80008580:	00 90       	ret 

80008582 <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
80008582:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
80008584:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80008588:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000858a:	4c 60       	ld.w %d15,[%a6]0
8000858c:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80008590:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
80008594:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
80008598:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000859a:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000859e:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
800085a0:	1d 00 03 00 	j 800085a6 <osEE_hal_restore_ctx>
800085a4:	00 90       	ret 

800085a6 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
800085a6:	cc 50       	ld.a %a15,[%a5]0
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
800085a8:	4c f2       	ld.w %d15,[%a15]8
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
800085aa:	c8 32       	ld.a %a2,[%a15]12
800085ac:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
800085ae:	cd 0f e0 0f 	mtcr $pcxi,%d15
800085b2:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
800085b6:	4c f0       	ld.w %d15,[%a15]0
800085b8:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
800085ba:	1d ff 19 f7 	j 800073ec <osEE_scheduler_task_wrapper_restore>
800085be:	00 90       	ret 

800085c0 <osEE_hal_save_ctx_and_ready2stacked>:
800085c0:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
800085c2:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
800085c6:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
800085c8:	4c 60       	ld.w %d15,[%a6]0
800085ca:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
800085ce:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
800085d2:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
800085d6:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
800085d8:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
800085dc:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
800085de:	1d 00 03 00 	j 800085e4 <osEE_hal_ready2stacked>
800085e2:	00 90       	ret 

800085e4 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
800085e4:	cc 50       	ld.a %a15,[%a5]0
800085e6:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
800085e8:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
800085ec:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
800085ee:	d9 f2 f0 ff 	lea %a2,[%a15]-16
800085f2:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
800085f4:	4c 50       	ld.w %d15,[%a5]0
800085f6:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
800085fa:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
800085fe:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
80008602:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
80008604:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
80008608:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000860a:	1d ff 15 f7 	j 80007434 <osEE_scheduler_task_wrapper_run>
8000860e:	00 90       	ret 

80008610 <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
80008610:	4d 40 e0 ff 	mfcr %d15,$psw
80008614:	8f ff c7 f1 	andn %d15,%d15,127
80008618:	cd 4f e0 0f 	mtcr $psw,%d15
8000861c:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
80008620:	91 10 00 f8 	movh.a %a15,32769
80008624:	d9 ff 60 58 	lea %a15,[%a15]-31392 <80008560 <osEE_tc_change_context_from_task_end>>
80008628:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000862a:	00 80       	rfe 
8000862c:	00 90       	ret 

8000862e <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000862e:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
80008630:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80008634:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
80008638:	cc 40       	ld.a %a15,[%a4]0
8000863a:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000863c:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
80008640:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
80008644:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
80008646:	8f c3 01 30 	sh %d3,%d3,28
8000864a:	a6 43       	or %d3,%d4
8000864c:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000864e:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
80008650:	bc f3       	jz.a %a15,80008656 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
80008652:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
80008654:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
80008656:	cd 8f e3 0f 	mtcr $fcx,%d15
8000865a:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000865e:	cd 03 e0 0f 	mtcr $pcxi,%d3
80008662:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
80008666:	cc 40       	ld.a %a15,[%a4]0
80008668:	4c f0       	ld.w %d15,[%a15]0
8000866a:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000866c:	91 00 00 48 	movh.a %a4,32768
80008670:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <osEE_kdb_var>>
80008674:	d9 a5 04 00 	lea %a5,[%sp]4 <80000028 <osEE_kdb_var>>
80008678:	6d ff 7b f9 	call 8000796e <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000867c:	d8 01       	ld.a %a15,[%sp]4
8000867e:	39 ff 14 00 	ld.bu %d15,[%a15]20
80008682:	1e 25       	jeq %d15,2,8000868c <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
80008684:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
80008686:	1d ff 6d ff 	j 80008560 <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000868a:	3c 00       	j 8000868a <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000868c:	40 24       	mov.aa %a4,%a2
8000868e:	6d ff c1 ff 	call 80008610 <osEE_tc_change_context_from_isr2_end>
80008692:	3c fc       	j 8000868a <osEE_hal_terminate_ctx+0x5c>

80008694 <_exit>:
80008694:	76 43       	jz %d4,8000869a <_exit+0x6>
80008696:	60 4e       	mov.a %a14,%d4
80008698:	3c 04       	j 800086a0 <_exit+0xc>
8000869a:	bb d0 00 f9 	mov.u %d15,36877
8000869e:	60 fe       	mov.a %a14,%d15
800086a0:	00 a0       	debug 
800086a2:	3c 00       	j 800086a2 <_exit+0xe>
800086a4:	00 00       	nop 
	...

Disassembly of section .inttab_cpu1:

8000a000 <__INTTAB1>:
	...

8000a020 <osEE_tc_core1_isr2_entry_1>:
8000a020:	0d 00 00 02 	svlcx 
8000a024:	82 f4       	mov %d4,-1
8000a026:	1d ff 54 db 	j 800056ce <osEE_tc_isr2_wrapper>
	...

8000a040 <osEE_tc_core1_isr2_entry_2>:
8000a040:	0d 00 00 02 	svlcx 
8000a044:	82 34       	mov %d4,3
8000a046:	1d ff 44 db 	j 800056ce <osEE_tc_isr2_wrapper>
	...

8000a060 <osEE_tc_core1_isr_dummy_entry_3>:
8000a060:	3c 00       	j 8000a060 <osEE_tc_core1_isr_dummy_entry_3>
	...

8000a080 <osEE_tc_core1_isr_dummy_entry_4>:
8000a080:	3c 00       	j 8000a080 <osEE_tc_core1_isr_dummy_entry_4>
	...

8000a0a0 <osEE_tc_core1_isr_dummy_entry_5>:
8000a0a0:	3c 00       	j 8000a0a0 <osEE_tc_core1_isr_dummy_entry_5>
	...

8000a0c0 <osEE_tc_core1_isr_dummy_entry_6>:
8000a0c0:	3c 00       	j 8000a0c0 <osEE_tc_core1_isr_dummy_entry_6>
	...

8000a0e0 <osEE_tc_core1_isr_dummy_entry_7>:
8000a0e0:	3c 00       	j 8000a0e0 <osEE_tc_core1_isr_dummy_entry_7>
	...

8000a100 <osEE_tc_core1_isr_dummy_entry_8>:
8000a100:	3c 00       	j 8000a100 <osEE_tc_core1_isr_dummy_entry_8>
	...

8000a120 <osEE_tc_core1_isr_dummy_entry_9>:
8000a120:	3c 00       	j 8000a120 <osEE_tc_core1_isr_dummy_entry_9>
	...

8000a140 <osEE_tc_core1_isr_dummy_entry_10>:
8000a140:	3c 00       	j 8000a140 <osEE_tc_core1_isr_dummy_entry_10>
	...

8000a160 <osEE_tc_core1_isr_dummy_entry_11>:
8000a160:	3c 00       	j 8000a160 <osEE_tc_core1_isr_dummy_entry_11>
	...

8000a180 <osEE_tc_core1_isr_dummy_entry_12>:
8000a180:	3c 00       	j 8000a180 <osEE_tc_core1_isr_dummy_entry_12>
	...

8000a1a0 <osEE_tc_core1_isr_dummy_entry_13>:
8000a1a0:	3c 00       	j 8000a1a0 <osEE_tc_core1_isr_dummy_entry_13>
	...

8000a1c0 <osEE_tc_core1_isr_dummy_entry_14>:
8000a1c0:	3c 00       	j 8000a1c0 <osEE_tc_core1_isr_dummy_entry_14>
	...

8000a1e0 <osEE_tc_core1_isr_dummy_entry_15>:
8000a1e0:	3c 00       	j 8000a1e0 <osEE_tc_core1_isr_dummy_entry_15>
	...

8000a200 <osEE_tc_core1_isr_dummy_entry_16>:
8000a200:	3c 00       	j 8000a200 <osEE_tc_core1_isr_dummy_entry_16>
	...

8000a220 <osEE_tc_core1_isr_dummy_entry_17>:
8000a220:	3c 00       	j 8000a220 <osEE_tc_core1_isr_dummy_entry_17>
	...

8000a240 <osEE_tc_core1_isr_dummy_entry_18>:
8000a240:	3c 00       	j 8000a240 <osEE_tc_core1_isr_dummy_entry_18>
	...

8000a260 <osEE_tc_core1_isr_dummy_entry_19>:
8000a260:	3c 00       	j 8000a260 <osEE_tc_core1_isr_dummy_entry_19>
	...

8000a280 <osEE_tc_core1_isr_dummy_entry_20>:
8000a280:	3c 00       	j 8000a280 <osEE_tc_core1_isr_dummy_entry_20>
	...

8000a2a0 <osEE_tc_core1_isr_dummy_entry_21>:
8000a2a0:	3c 00       	j 8000a2a0 <osEE_tc_core1_isr_dummy_entry_21>
	...

8000a2c0 <osEE_tc_core1_isr_dummy_entry_22>:
8000a2c0:	3c 00       	j 8000a2c0 <osEE_tc_core1_isr_dummy_entry_22>
	...

8000a2e0 <osEE_tc_core1_isr_dummy_entry_23>:
8000a2e0:	3c 00       	j 8000a2e0 <osEE_tc_core1_isr_dummy_entry_23>
	...

8000a300 <osEE_tc_core1_isr_dummy_entry_24>:
8000a300:	3c 00       	j 8000a300 <osEE_tc_core1_isr_dummy_entry_24>
	...

8000a320 <osEE_tc_core1_isr_dummy_entry_25>:
8000a320:	3c 00       	j 8000a320 <osEE_tc_core1_isr_dummy_entry_25>
	...

8000a340 <osEE_tc_core1_isr_dummy_entry_26>:
8000a340:	3c 00       	j 8000a340 <osEE_tc_core1_isr_dummy_entry_26>
	...

8000a360 <osEE_tc_core1_isr_dummy_entry_27>:
8000a360:	3c 00       	j 8000a360 <osEE_tc_core1_isr_dummy_entry_27>
	...

8000a380 <osEE_tc_core1_isr_dummy_entry_28>:
8000a380:	3c 00       	j 8000a380 <osEE_tc_core1_isr_dummy_entry_28>
	...

8000a3a0 <osEE_tc_core1_isr_dummy_entry_29>:
8000a3a0:	3c 00       	j 8000a3a0 <osEE_tc_core1_isr_dummy_entry_29>
	...

8000a3c0 <osEE_tc_core1_isr_dummy_entry_30>:
8000a3c0:	3c 00       	j 8000a3c0 <osEE_tc_core1_isr_dummy_entry_30>
	...

8000a3e0 <osEE_tc_core1_isr_dummy_entry_31>:
8000a3e0:	3c 00       	j 8000a3e0 <osEE_tc_core1_isr_dummy_entry_31>
	...

8000a400 <osEE_tc_core1_isr_dummy_entry_32>:
8000a400:	3c 00       	j 8000a400 <osEE_tc_core1_isr_dummy_entry_32>
	...

8000a420 <osEE_tc_core1_isr_dummy_entry_33>:
8000a420:	3c 00       	j 8000a420 <osEE_tc_core1_isr_dummy_entry_33>
	...

8000a440 <osEE_tc_core1_isr_dummy_entry_34>:
8000a440:	3c 00       	j 8000a440 <osEE_tc_core1_isr_dummy_entry_34>
	...

8000a460 <osEE_tc_core1_isr_dummy_entry_35>:
8000a460:	3c 00       	j 8000a460 <osEE_tc_core1_isr_dummy_entry_35>
	...

8000a480 <osEE_tc_core1_isr_dummy_entry_36>:
8000a480:	3c 00       	j 8000a480 <osEE_tc_core1_isr_dummy_entry_36>
	...

8000a4a0 <osEE_tc_core1_isr_dummy_entry_37>:
8000a4a0:	3c 00       	j 8000a4a0 <osEE_tc_core1_isr_dummy_entry_37>
	...

8000a4c0 <osEE_tc_core1_isr_dummy_entry_38>:
8000a4c0:	3c 00       	j 8000a4c0 <osEE_tc_core1_isr_dummy_entry_38>
	...

8000a4e0 <osEE_tc_core1_isr_dummy_entry_39>:
8000a4e0:	3c 00       	j 8000a4e0 <osEE_tc_core1_isr_dummy_entry_39>
	...

8000a500 <osEE_tc_core1_isr_dummy_entry_40>:
8000a500:	3c 00       	j 8000a500 <osEE_tc_core1_isr_dummy_entry_40>
	...

8000a520 <osEE_tc_core1_isr_dummy_entry_41>:
8000a520:	3c 00       	j 8000a520 <osEE_tc_core1_isr_dummy_entry_41>
	...

8000a540 <osEE_tc_core1_isr_dummy_entry_42>:
8000a540:	3c 00       	j 8000a540 <osEE_tc_core1_isr_dummy_entry_42>
	...

8000a560 <osEE_tc_core1_isr_dummy_entry_43>:
8000a560:	3c 00       	j 8000a560 <osEE_tc_core1_isr_dummy_entry_43>
	...

8000a580 <osEE_tc_core1_isr_dummy_entry_44>:
8000a580:	3c 00       	j 8000a580 <osEE_tc_core1_isr_dummy_entry_44>
	...

8000a5a0 <osEE_tc_core1_isr_dummy_entry_45>:
8000a5a0:	3c 00       	j 8000a5a0 <osEE_tc_core1_isr_dummy_entry_45>
	...

8000a5c0 <osEE_tc_core1_isr_dummy_entry_46>:
8000a5c0:	3c 00       	j 8000a5c0 <osEE_tc_core1_isr_dummy_entry_46>
	...

8000a5e0 <osEE_tc_core1_isr_dummy_entry_47>:
8000a5e0:	3c 00       	j 8000a5e0 <osEE_tc_core1_isr_dummy_entry_47>
	...

8000a600 <osEE_tc_core1_isr_dummy_entry_48>:
8000a600:	3c 00       	j 8000a600 <osEE_tc_core1_isr_dummy_entry_48>
	...

8000a620 <osEE_tc_core1_isr_dummy_entry_49>:
8000a620:	3c 00       	j 8000a620 <osEE_tc_core1_isr_dummy_entry_49>
	...

8000a640 <osEE_tc_core1_isr_dummy_entry_50>:
8000a640:	3c 00       	j 8000a640 <osEE_tc_core1_isr_dummy_entry_50>
	...

8000a660 <osEE_tc_core1_isr_dummy_entry_51>:
8000a660:	3c 00       	j 8000a660 <osEE_tc_core1_isr_dummy_entry_51>
	...

8000a680 <osEE_tc_core1_isr_dummy_entry_52>:
8000a680:	3c 00       	j 8000a680 <osEE_tc_core1_isr_dummy_entry_52>
	...

8000a6a0 <osEE_tc_core1_isr_dummy_entry_53>:
8000a6a0:	3c 00       	j 8000a6a0 <osEE_tc_core1_isr_dummy_entry_53>
	...

8000a6c0 <osEE_tc_core1_isr_dummy_entry_54>:
8000a6c0:	3c 00       	j 8000a6c0 <osEE_tc_core1_isr_dummy_entry_54>
	...

8000a6e0 <osEE_tc_core1_isr_dummy_entry_55>:
8000a6e0:	3c 00       	j 8000a6e0 <osEE_tc_core1_isr_dummy_entry_55>
	...

8000a700 <osEE_tc_core1_isr_dummy_entry_56>:
8000a700:	3c 00       	j 8000a700 <osEE_tc_core1_isr_dummy_entry_56>
	...

8000a720 <osEE_tc_core1_isr_dummy_entry_57>:
8000a720:	3c 00       	j 8000a720 <osEE_tc_core1_isr_dummy_entry_57>
	...

8000a740 <osEE_tc_core1_isr_dummy_entry_58>:
8000a740:	3c 00       	j 8000a740 <osEE_tc_core1_isr_dummy_entry_58>
	...

8000a760 <osEE_tc_core1_isr_dummy_entry_59>:
8000a760:	3c 00       	j 8000a760 <osEE_tc_core1_isr_dummy_entry_59>
	...

8000a780 <osEE_tc_core1_isr_dummy_entry_60>:
8000a780:	3c 00       	j 8000a780 <osEE_tc_core1_isr_dummy_entry_60>
	...

8000a7a0 <osEE_tc_core1_isr_dummy_entry_61>:
8000a7a0:	3c 00       	j 8000a7a0 <osEE_tc_core1_isr_dummy_entry_61>
	...

8000a7c0 <osEE_tc_core1_isr_dummy_entry_62>:
8000a7c0:	3c 00       	j 8000a7c0 <osEE_tc_core1_isr_dummy_entry_62>
	...

8000a7e0 <osEE_tc_core1_isr_dummy_entry_63>:
8000a7e0:	3c 00       	j 8000a7e0 <osEE_tc_core1_isr_dummy_entry_63>
	...

8000a800 <osEE_tc_core1_isr_dummy_entry_64>:
8000a800:	3c 00       	j 8000a800 <osEE_tc_core1_isr_dummy_entry_64>
	...

8000a820 <osEE_tc_core1_isr_dummy_entry_65>:
8000a820:	3c 00       	j 8000a820 <osEE_tc_core1_isr_dummy_entry_65>
	...

8000a840 <osEE_tc_core1_isr_dummy_entry_66>:
8000a840:	3c 00       	j 8000a840 <osEE_tc_core1_isr_dummy_entry_66>
	...

8000a860 <osEE_tc_core1_isr_dummy_entry_67>:
8000a860:	3c 00       	j 8000a860 <osEE_tc_core1_isr_dummy_entry_67>
	...

8000a880 <osEE_tc_core1_isr_dummy_entry_68>:
8000a880:	3c 00       	j 8000a880 <osEE_tc_core1_isr_dummy_entry_68>
	...

8000a8a0 <osEE_tc_core1_isr_dummy_entry_69>:
8000a8a0:	3c 00       	j 8000a8a0 <osEE_tc_core1_isr_dummy_entry_69>
	...

8000a8c0 <osEE_tc_core1_isr_dummy_entry_70>:
8000a8c0:	3c 00       	j 8000a8c0 <osEE_tc_core1_isr_dummy_entry_70>
	...

8000a8e0 <osEE_tc_core1_isr_dummy_entry_71>:
8000a8e0:	3c 00       	j 8000a8e0 <osEE_tc_core1_isr_dummy_entry_71>
	...

8000a900 <osEE_tc_core1_isr_dummy_entry_72>:
8000a900:	3c 00       	j 8000a900 <osEE_tc_core1_isr_dummy_entry_72>
	...

8000a920 <osEE_tc_core1_isr_dummy_entry_73>:
8000a920:	3c 00       	j 8000a920 <osEE_tc_core1_isr_dummy_entry_73>
	...

8000a940 <osEE_tc_core1_isr_dummy_entry_74>:
8000a940:	3c 00       	j 8000a940 <osEE_tc_core1_isr_dummy_entry_74>
	...

8000a960 <osEE_tc_core1_isr_dummy_entry_75>:
8000a960:	3c 00       	j 8000a960 <osEE_tc_core1_isr_dummy_entry_75>
	...

8000a980 <osEE_tc_core1_isr_dummy_entry_76>:
8000a980:	3c 00       	j 8000a980 <osEE_tc_core1_isr_dummy_entry_76>
	...

8000a9a0 <osEE_tc_core1_isr_dummy_entry_77>:
8000a9a0:	3c 00       	j 8000a9a0 <osEE_tc_core1_isr_dummy_entry_77>
	...

8000a9c0 <osEE_tc_core1_isr_dummy_entry_78>:
8000a9c0:	3c 00       	j 8000a9c0 <osEE_tc_core1_isr_dummy_entry_78>
	...

8000a9e0 <osEE_tc_core1_isr_dummy_entry_79>:
8000a9e0:	3c 00       	j 8000a9e0 <osEE_tc_core1_isr_dummy_entry_79>
	...

8000aa00 <osEE_tc_core1_isr_dummy_entry_80>:
8000aa00:	3c 00       	j 8000aa00 <osEE_tc_core1_isr_dummy_entry_80>
	...

8000aa20 <osEE_tc_core1_isr_dummy_entry_81>:
8000aa20:	3c 00       	j 8000aa20 <osEE_tc_core1_isr_dummy_entry_81>
	...

8000aa40 <osEE_tc_core1_isr_dummy_entry_82>:
8000aa40:	3c 00       	j 8000aa40 <osEE_tc_core1_isr_dummy_entry_82>
	...

8000aa60 <osEE_tc_core1_isr_dummy_entry_83>:
8000aa60:	3c 00       	j 8000aa60 <osEE_tc_core1_isr_dummy_entry_83>
	...

8000aa80 <osEE_tc_core1_isr_dummy_entry_84>:
8000aa80:	3c 00       	j 8000aa80 <osEE_tc_core1_isr_dummy_entry_84>
	...

8000aaa0 <osEE_tc_core1_isr_dummy_entry_85>:
8000aaa0:	3c 00       	j 8000aaa0 <osEE_tc_core1_isr_dummy_entry_85>
	...

8000aac0 <osEE_tc_core1_isr_dummy_entry_86>:
8000aac0:	3c 00       	j 8000aac0 <osEE_tc_core1_isr_dummy_entry_86>
	...

8000aae0 <osEE_tc_core1_isr_dummy_entry_87>:
8000aae0:	3c 00       	j 8000aae0 <osEE_tc_core1_isr_dummy_entry_87>
	...

8000ab00 <osEE_tc_core1_isr_dummy_entry_88>:
8000ab00:	3c 00       	j 8000ab00 <osEE_tc_core1_isr_dummy_entry_88>
	...

8000ab20 <osEE_tc_core1_isr_dummy_entry_89>:
8000ab20:	3c 00       	j 8000ab20 <osEE_tc_core1_isr_dummy_entry_89>
	...

8000ab40 <osEE_tc_core1_isr_dummy_entry_90>:
8000ab40:	3c 00       	j 8000ab40 <osEE_tc_core1_isr_dummy_entry_90>
	...

8000ab60 <osEE_tc_core1_isr_dummy_entry_91>:
8000ab60:	3c 00       	j 8000ab60 <osEE_tc_core1_isr_dummy_entry_91>
	...

8000ab80 <osEE_tc_core1_isr_dummy_entry_92>:
8000ab80:	3c 00       	j 8000ab80 <osEE_tc_core1_isr_dummy_entry_92>
	...

8000aba0 <osEE_tc_core1_isr_dummy_entry_93>:
8000aba0:	3c 00       	j 8000aba0 <osEE_tc_core1_isr_dummy_entry_93>
	...

8000abc0 <osEE_tc_core1_isr_dummy_entry_94>:
8000abc0:	3c 00       	j 8000abc0 <osEE_tc_core1_isr_dummy_entry_94>
	...

8000abe0 <osEE_tc_core1_isr_dummy_entry_95>:
8000abe0:	3c 00       	j 8000abe0 <osEE_tc_core1_isr_dummy_entry_95>
	...

8000ac00 <osEE_tc_core1_isr_dummy_entry_96>:
8000ac00:	3c 00       	j 8000ac00 <osEE_tc_core1_isr_dummy_entry_96>
	...

8000ac20 <osEE_tc_core1_isr_dummy_entry_97>:
8000ac20:	3c 00       	j 8000ac20 <osEE_tc_core1_isr_dummy_entry_97>
	...

8000ac40 <osEE_tc_core1_isr_dummy_entry_98>:
8000ac40:	3c 00       	j 8000ac40 <osEE_tc_core1_isr_dummy_entry_98>
	...

8000ac60 <osEE_tc_core1_isr_dummy_entry_99>:
8000ac60:	3c 00       	j 8000ac60 <osEE_tc_core1_isr_dummy_entry_99>
	...

8000ac80 <osEE_tc_core1_isr_dummy_entry_100>:
8000ac80:	3c 00       	j 8000ac80 <osEE_tc_core1_isr_dummy_entry_100>
	...

8000aca0 <osEE_tc_core1_isr_dummy_entry_101>:
8000aca0:	3c 00       	j 8000aca0 <osEE_tc_core1_isr_dummy_entry_101>
	...

8000acc0 <osEE_tc_core1_isr_dummy_entry_102>:
8000acc0:	3c 00       	j 8000acc0 <osEE_tc_core1_isr_dummy_entry_102>
	...

8000ace0 <osEE_tc_core1_isr_dummy_entry_103>:
8000ace0:	3c 00       	j 8000ace0 <osEE_tc_core1_isr_dummy_entry_103>
	...

8000ad00 <osEE_tc_core1_isr_dummy_entry_104>:
8000ad00:	3c 00       	j 8000ad00 <osEE_tc_core1_isr_dummy_entry_104>
	...

8000ad20 <osEE_tc_core1_isr_dummy_entry_105>:
8000ad20:	3c 00       	j 8000ad20 <osEE_tc_core1_isr_dummy_entry_105>
	...

8000ad40 <osEE_tc_core1_isr_dummy_entry_106>:
8000ad40:	3c 00       	j 8000ad40 <osEE_tc_core1_isr_dummy_entry_106>
	...

8000ad60 <osEE_tc_core1_isr_dummy_entry_107>:
8000ad60:	3c 00       	j 8000ad60 <osEE_tc_core1_isr_dummy_entry_107>
	...

8000ad80 <osEE_tc_core1_isr_dummy_entry_108>:
8000ad80:	3c 00       	j 8000ad80 <osEE_tc_core1_isr_dummy_entry_108>
	...

8000ada0 <osEE_tc_core1_isr_dummy_entry_109>:
8000ada0:	3c 00       	j 8000ada0 <osEE_tc_core1_isr_dummy_entry_109>
	...

8000adc0 <osEE_tc_core1_isr_dummy_entry_110>:
8000adc0:	3c 00       	j 8000adc0 <osEE_tc_core1_isr_dummy_entry_110>
	...

8000ade0 <osEE_tc_core1_isr_dummy_entry_111>:
8000ade0:	3c 00       	j 8000ade0 <osEE_tc_core1_isr_dummy_entry_111>
	...

8000ae00 <osEE_tc_core1_isr_dummy_entry_112>:
8000ae00:	3c 00       	j 8000ae00 <osEE_tc_core1_isr_dummy_entry_112>
	...

8000ae20 <osEE_tc_core1_isr_dummy_entry_113>:
8000ae20:	3c 00       	j 8000ae20 <osEE_tc_core1_isr_dummy_entry_113>
	...

8000ae40 <osEE_tc_core1_isr_dummy_entry_114>:
8000ae40:	3c 00       	j 8000ae40 <osEE_tc_core1_isr_dummy_entry_114>
	...

8000ae60 <osEE_tc_core1_isr_dummy_entry_115>:
8000ae60:	3c 00       	j 8000ae60 <osEE_tc_core1_isr_dummy_entry_115>
	...

8000ae80 <osEE_tc_core1_isr_dummy_entry_116>:
8000ae80:	3c 00       	j 8000ae80 <osEE_tc_core1_isr_dummy_entry_116>
	...

8000aea0 <osEE_tc_core1_isr_dummy_entry_117>:
8000aea0:	3c 00       	j 8000aea0 <osEE_tc_core1_isr_dummy_entry_117>
	...

8000aec0 <osEE_tc_core1_isr_dummy_entry_118>:
8000aec0:	3c 00       	j 8000aec0 <osEE_tc_core1_isr_dummy_entry_118>
	...

8000aee0 <osEE_tc_core1_isr_dummy_entry_119>:
8000aee0:	3c 00       	j 8000aee0 <osEE_tc_core1_isr_dummy_entry_119>
	...

8000af00 <osEE_tc_core1_isr_dummy_entry_120>:
8000af00:	3c 00       	j 8000af00 <osEE_tc_core1_isr_dummy_entry_120>
	...

8000af20 <osEE_tc_core1_isr_dummy_entry_121>:
8000af20:	3c 00       	j 8000af20 <osEE_tc_core1_isr_dummy_entry_121>
	...

8000af40 <osEE_tc_core1_isr_dummy_entry_122>:
8000af40:	3c 00       	j 8000af40 <osEE_tc_core1_isr_dummy_entry_122>
	...

8000af60 <osEE_tc_core1_isr_dummy_entry_123>:
8000af60:	3c 00       	j 8000af60 <osEE_tc_core1_isr_dummy_entry_123>
	...

8000af80 <osEE_tc_core1_isr_dummy_entry_124>:
8000af80:	3c 00       	j 8000af80 <osEE_tc_core1_isr_dummy_entry_124>
	...

8000afa0 <osEE_tc_core1_isr_dummy_entry_125>:
8000afa0:	3c 00       	j 8000afa0 <osEE_tc_core1_isr_dummy_entry_125>
	...

8000afc0 <osEE_tc_core1_isr_dummy_entry_126>:
8000afc0:	3c 00       	j 8000afc0 <osEE_tc_core1_isr_dummy_entry_126>
	...

8000afe0 <osEE_tc_core1_isr_dummy_entry_127>:
8000afe0:	3c 00       	j 8000afe0 <osEE_tc_core1_isr_dummy_entry_127>
	...

8000b000 <osEE_tc_core1_isr_dummy_entry_128>:
8000b000:	3c 00       	j 8000b000 <osEE_tc_core1_isr_dummy_entry_128>
	...

8000b020 <osEE_tc_core1_isr_dummy_entry_129>:
8000b020:	3c 00       	j 8000b020 <osEE_tc_core1_isr_dummy_entry_129>
	...

8000b040 <osEE_tc_core1_isr_dummy_entry_130>:
8000b040:	3c 00       	j 8000b040 <osEE_tc_core1_isr_dummy_entry_130>
	...

8000b060 <osEE_tc_core1_isr_dummy_entry_131>:
8000b060:	3c 00       	j 8000b060 <osEE_tc_core1_isr_dummy_entry_131>
	...

8000b080 <osEE_tc_core1_isr_dummy_entry_132>:
8000b080:	3c 00       	j 8000b080 <osEE_tc_core1_isr_dummy_entry_132>
	...

8000b0a0 <osEE_tc_core1_isr_dummy_entry_133>:
8000b0a0:	3c 00       	j 8000b0a0 <osEE_tc_core1_isr_dummy_entry_133>
	...

8000b0c0 <osEE_tc_core1_isr_dummy_entry_134>:
8000b0c0:	3c 00       	j 8000b0c0 <osEE_tc_core1_isr_dummy_entry_134>
	...

8000b0e0 <osEE_tc_core1_isr_dummy_entry_135>:
8000b0e0:	3c 00       	j 8000b0e0 <osEE_tc_core1_isr_dummy_entry_135>
	...

8000b100 <osEE_tc_core1_isr_dummy_entry_136>:
8000b100:	3c 00       	j 8000b100 <osEE_tc_core1_isr_dummy_entry_136>
	...

8000b120 <osEE_tc_core1_isr_dummy_entry_137>:
8000b120:	3c 00       	j 8000b120 <osEE_tc_core1_isr_dummy_entry_137>
	...

8000b140 <osEE_tc_core1_isr_dummy_entry_138>:
8000b140:	3c 00       	j 8000b140 <osEE_tc_core1_isr_dummy_entry_138>
	...

8000b160 <osEE_tc_core1_isr_dummy_entry_139>:
8000b160:	3c 00       	j 8000b160 <osEE_tc_core1_isr_dummy_entry_139>
	...

8000b180 <osEE_tc_core1_isr_dummy_entry_140>:
8000b180:	3c 00       	j 8000b180 <osEE_tc_core1_isr_dummy_entry_140>
	...

8000b1a0 <osEE_tc_core1_isr_dummy_entry_141>:
8000b1a0:	3c 00       	j 8000b1a0 <osEE_tc_core1_isr_dummy_entry_141>
	...

8000b1c0 <osEE_tc_core1_isr_dummy_entry_142>:
8000b1c0:	3c 00       	j 8000b1c0 <osEE_tc_core1_isr_dummy_entry_142>
	...

8000b1e0 <osEE_tc_core1_isr_dummy_entry_143>:
8000b1e0:	3c 00       	j 8000b1e0 <osEE_tc_core1_isr_dummy_entry_143>
	...

8000b200 <osEE_tc_core1_isr_dummy_entry_144>:
8000b200:	3c 00       	j 8000b200 <osEE_tc_core1_isr_dummy_entry_144>
	...

8000b220 <osEE_tc_core1_isr_dummy_entry_145>:
8000b220:	3c 00       	j 8000b220 <osEE_tc_core1_isr_dummy_entry_145>
	...

8000b240 <osEE_tc_core1_isr_dummy_entry_146>:
8000b240:	3c 00       	j 8000b240 <osEE_tc_core1_isr_dummy_entry_146>
	...

8000b260 <osEE_tc_core1_isr_dummy_entry_147>:
8000b260:	3c 00       	j 8000b260 <osEE_tc_core1_isr_dummy_entry_147>
	...

8000b280 <osEE_tc_core1_isr_dummy_entry_148>:
8000b280:	3c 00       	j 8000b280 <osEE_tc_core1_isr_dummy_entry_148>
	...

8000b2a0 <osEE_tc_core1_isr_dummy_entry_149>:
8000b2a0:	3c 00       	j 8000b2a0 <osEE_tc_core1_isr_dummy_entry_149>
	...

8000b2c0 <osEE_tc_core1_isr_dummy_entry_150>:
8000b2c0:	3c 00       	j 8000b2c0 <osEE_tc_core1_isr_dummy_entry_150>
	...

8000b2e0 <osEE_tc_core1_isr_dummy_entry_151>:
8000b2e0:	3c 00       	j 8000b2e0 <osEE_tc_core1_isr_dummy_entry_151>
	...

8000b300 <osEE_tc_core1_isr_dummy_entry_152>:
8000b300:	3c 00       	j 8000b300 <osEE_tc_core1_isr_dummy_entry_152>
	...

8000b320 <osEE_tc_core1_isr_dummy_entry_153>:
8000b320:	3c 00       	j 8000b320 <osEE_tc_core1_isr_dummy_entry_153>
	...

8000b340 <osEE_tc_core1_isr_dummy_entry_154>:
8000b340:	3c 00       	j 8000b340 <osEE_tc_core1_isr_dummy_entry_154>
	...

8000b360 <osEE_tc_core1_isr_dummy_entry_155>:
8000b360:	3c 00       	j 8000b360 <osEE_tc_core1_isr_dummy_entry_155>
	...

8000b380 <osEE_tc_core1_isr_dummy_entry_156>:
8000b380:	3c 00       	j 8000b380 <osEE_tc_core1_isr_dummy_entry_156>
	...

8000b3a0 <osEE_tc_core1_isr_dummy_entry_157>:
8000b3a0:	3c 00       	j 8000b3a0 <osEE_tc_core1_isr_dummy_entry_157>
	...

8000b3c0 <osEE_tc_core1_isr_dummy_entry_158>:
8000b3c0:	3c 00       	j 8000b3c0 <osEE_tc_core1_isr_dummy_entry_158>
	...

8000b3e0 <osEE_tc_core1_isr_dummy_entry_159>:
8000b3e0:	3c 00       	j 8000b3e0 <osEE_tc_core1_isr_dummy_entry_159>
	...

8000b400 <osEE_tc_core1_isr_dummy_entry_160>:
8000b400:	3c 00       	j 8000b400 <osEE_tc_core1_isr_dummy_entry_160>
	...

8000b420 <osEE_tc_core1_isr_dummy_entry_161>:
8000b420:	3c 00       	j 8000b420 <osEE_tc_core1_isr_dummy_entry_161>
	...

8000b440 <osEE_tc_core1_isr_dummy_entry_162>:
8000b440:	3c 00       	j 8000b440 <osEE_tc_core1_isr_dummy_entry_162>
	...

8000b460 <osEE_tc_core1_isr_dummy_entry_163>:
8000b460:	3c 00       	j 8000b460 <osEE_tc_core1_isr_dummy_entry_163>
	...

8000b480 <osEE_tc_core1_isr_dummy_entry_164>:
8000b480:	3c 00       	j 8000b480 <osEE_tc_core1_isr_dummy_entry_164>
	...

8000b4a0 <osEE_tc_core1_isr_dummy_entry_165>:
8000b4a0:	3c 00       	j 8000b4a0 <osEE_tc_core1_isr_dummy_entry_165>
	...

8000b4c0 <osEE_tc_core1_isr_dummy_entry_166>:
8000b4c0:	3c 00       	j 8000b4c0 <osEE_tc_core1_isr_dummy_entry_166>
	...

8000b4e0 <osEE_tc_core1_isr_dummy_entry_167>:
8000b4e0:	3c 00       	j 8000b4e0 <osEE_tc_core1_isr_dummy_entry_167>
	...

8000b500 <osEE_tc_core1_isr_dummy_entry_168>:
8000b500:	3c 00       	j 8000b500 <osEE_tc_core1_isr_dummy_entry_168>
	...

8000b520 <osEE_tc_core1_isr_dummy_entry_169>:
8000b520:	3c 00       	j 8000b520 <osEE_tc_core1_isr_dummy_entry_169>
	...

8000b540 <osEE_tc_core1_isr_dummy_entry_170>:
8000b540:	3c 00       	j 8000b540 <osEE_tc_core1_isr_dummy_entry_170>
	...

8000b560 <osEE_tc_core1_isr_dummy_entry_171>:
8000b560:	3c 00       	j 8000b560 <osEE_tc_core1_isr_dummy_entry_171>
	...

8000b580 <osEE_tc_core1_isr_dummy_entry_172>:
8000b580:	3c 00       	j 8000b580 <osEE_tc_core1_isr_dummy_entry_172>
	...

8000b5a0 <osEE_tc_core1_isr_dummy_entry_173>:
8000b5a0:	3c 00       	j 8000b5a0 <osEE_tc_core1_isr_dummy_entry_173>
	...

8000b5c0 <osEE_tc_core1_isr_dummy_entry_174>:
8000b5c0:	3c 00       	j 8000b5c0 <osEE_tc_core1_isr_dummy_entry_174>
	...

8000b5e0 <osEE_tc_core1_isr_dummy_entry_175>:
8000b5e0:	3c 00       	j 8000b5e0 <osEE_tc_core1_isr_dummy_entry_175>
	...

8000b600 <osEE_tc_core1_isr_dummy_entry_176>:
8000b600:	3c 00       	j 8000b600 <osEE_tc_core1_isr_dummy_entry_176>
	...

8000b620 <osEE_tc_core1_isr_dummy_entry_177>:
8000b620:	3c 00       	j 8000b620 <osEE_tc_core1_isr_dummy_entry_177>
	...

8000b640 <osEE_tc_core1_isr_dummy_entry_178>:
8000b640:	3c 00       	j 8000b640 <osEE_tc_core1_isr_dummy_entry_178>
	...

8000b660 <osEE_tc_core1_isr_dummy_entry_179>:
8000b660:	3c 00       	j 8000b660 <osEE_tc_core1_isr_dummy_entry_179>
	...

8000b680 <osEE_tc_core1_isr_dummy_entry_180>:
8000b680:	3c 00       	j 8000b680 <osEE_tc_core1_isr_dummy_entry_180>
	...

8000b6a0 <osEE_tc_core1_isr_dummy_entry_181>:
8000b6a0:	3c 00       	j 8000b6a0 <osEE_tc_core1_isr_dummy_entry_181>
	...

8000b6c0 <osEE_tc_core1_isr_dummy_entry_182>:
8000b6c0:	3c 00       	j 8000b6c0 <osEE_tc_core1_isr_dummy_entry_182>
	...

8000b6e0 <osEE_tc_core1_isr_dummy_entry_183>:
8000b6e0:	3c 00       	j 8000b6e0 <osEE_tc_core1_isr_dummy_entry_183>
	...

8000b700 <osEE_tc_core1_isr_dummy_entry_184>:
8000b700:	3c 00       	j 8000b700 <osEE_tc_core1_isr_dummy_entry_184>
	...

8000b720 <osEE_tc_core1_isr_dummy_entry_185>:
8000b720:	3c 00       	j 8000b720 <osEE_tc_core1_isr_dummy_entry_185>
	...

8000b740 <osEE_tc_core1_isr_dummy_entry_186>:
8000b740:	3c 00       	j 8000b740 <osEE_tc_core1_isr_dummy_entry_186>
	...

8000b760 <osEE_tc_core1_isr_dummy_entry_187>:
8000b760:	3c 00       	j 8000b760 <osEE_tc_core1_isr_dummy_entry_187>
	...

8000b780 <osEE_tc_core1_isr_dummy_entry_188>:
8000b780:	3c 00       	j 8000b780 <osEE_tc_core1_isr_dummy_entry_188>
	...

8000b7a0 <osEE_tc_core1_isr_dummy_entry_189>:
8000b7a0:	3c 00       	j 8000b7a0 <osEE_tc_core1_isr_dummy_entry_189>
	...

8000b7c0 <osEE_tc_core1_isr_dummy_entry_190>:
8000b7c0:	3c 00       	j 8000b7c0 <osEE_tc_core1_isr_dummy_entry_190>
	...

8000b7e0 <osEE_tc_core1_isr_dummy_entry_191>:
8000b7e0:	3c 00       	j 8000b7e0 <osEE_tc_core1_isr_dummy_entry_191>
	...

8000b800 <osEE_tc_core1_isr_dummy_entry_192>:
8000b800:	3c 00       	j 8000b800 <osEE_tc_core1_isr_dummy_entry_192>
	...

8000b820 <osEE_tc_core1_isr_dummy_entry_193>:
8000b820:	3c 00       	j 8000b820 <osEE_tc_core1_isr_dummy_entry_193>
	...

8000b840 <osEE_tc_core1_isr_dummy_entry_194>:
8000b840:	3c 00       	j 8000b840 <osEE_tc_core1_isr_dummy_entry_194>
	...

8000b860 <osEE_tc_core1_isr_dummy_entry_195>:
8000b860:	3c 00       	j 8000b860 <osEE_tc_core1_isr_dummy_entry_195>
	...

8000b880 <osEE_tc_core1_isr_dummy_entry_196>:
8000b880:	3c 00       	j 8000b880 <osEE_tc_core1_isr_dummy_entry_196>
	...

8000b8a0 <osEE_tc_core1_isr_dummy_entry_197>:
8000b8a0:	3c 00       	j 8000b8a0 <osEE_tc_core1_isr_dummy_entry_197>
	...

8000b8c0 <osEE_tc_core1_isr_dummy_entry_198>:
8000b8c0:	3c 00       	j 8000b8c0 <osEE_tc_core1_isr_dummy_entry_198>
	...

8000b8e0 <osEE_tc_core1_isr_dummy_entry_199>:
8000b8e0:	3c 00       	j 8000b8e0 <osEE_tc_core1_isr_dummy_entry_199>
	...

8000b900 <osEE_tc_core1_isr_dummy_entry_200>:
8000b900:	3c 00       	j 8000b900 <osEE_tc_core1_isr_dummy_entry_200>
	...

8000b920 <osEE_tc_core1_isr_dummy_entry_201>:
8000b920:	3c 00       	j 8000b920 <osEE_tc_core1_isr_dummy_entry_201>
	...

8000b940 <osEE_tc_core1_isr_dummy_entry_202>:
8000b940:	3c 00       	j 8000b940 <osEE_tc_core1_isr_dummy_entry_202>
	...

8000b960 <osEE_tc_core1_isr_dummy_entry_203>:
8000b960:	3c 00       	j 8000b960 <osEE_tc_core1_isr_dummy_entry_203>
	...

8000b980 <osEE_tc_core1_isr_dummy_entry_204>:
8000b980:	3c 00       	j 8000b980 <osEE_tc_core1_isr_dummy_entry_204>
	...

8000b9a0 <osEE_tc_core1_isr_dummy_entry_205>:
8000b9a0:	3c 00       	j 8000b9a0 <osEE_tc_core1_isr_dummy_entry_205>
	...

8000b9c0 <osEE_tc_core1_isr_dummy_entry_206>:
8000b9c0:	3c 00       	j 8000b9c0 <osEE_tc_core1_isr_dummy_entry_206>
	...

8000b9e0 <osEE_tc_core1_isr_dummy_entry_207>:
8000b9e0:	3c 00       	j 8000b9e0 <osEE_tc_core1_isr_dummy_entry_207>
	...

8000ba00 <osEE_tc_core1_isr_dummy_entry_208>:
8000ba00:	3c 00       	j 8000ba00 <osEE_tc_core1_isr_dummy_entry_208>
	...

8000ba20 <osEE_tc_core1_isr_dummy_entry_209>:
8000ba20:	3c 00       	j 8000ba20 <osEE_tc_core1_isr_dummy_entry_209>
	...

8000ba40 <osEE_tc_core1_isr_dummy_entry_210>:
8000ba40:	3c 00       	j 8000ba40 <osEE_tc_core1_isr_dummy_entry_210>
	...

8000ba60 <osEE_tc_core1_isr_dummy_entry_211>:
8000ba60:	3c 00       	j 8000ba60 <osEE_tc_core1_isr_dummy_entry_211>
	...

8000ba80 <osEE_tc_core1_isr_dummy_entry_212>:
8000ba80:	3c 00       	j 8000ba80 <osEE_tc_core1_isr_dummy_entry_212>
	...

8000baa0 <osEE_tc_core1_isr_dummy_entry_213>:
8000baa0:	3c 00       	j 8000baa0 <osEE_tc_core1_isr_dummy_entry_213>
	...

8000bac0 <osEE_tc_core1_isr_dummy_entry_214>:
8000bac0:	3c 00       	j 8000bac0 <osEE_tc_core1_isr_dummy_entry_214>
	...

8000bae0 <osEE_tc_core1_isr_dummy_entry_215>:
8000bae0:	3c 00       	j 8000bae0 <osEE_tc_core1_isr_dummy_entry_215>
	...

8000bb00 <osEE_tc_core1_isr_dummy_entry_216>:
8000bb00:	3c 00       	j 8000bb00 <osEE_tc_core1_isr_dummy_entry_216>
	...

8000bb20 <osEE_tc_core1_isr_dummy_entry_217>:
8000bb20:	3c 00       	j 8000bb20 <osEE_tc_core1_isr_dummy_entry_217>
	...

8000bb40 <osEE_tc_core1_isr_dummy_entry_218>:
8000bb40:	3c 00       	j 8000bb40 <osEE_tc_core1_isr_dummy_entry_218>
	...

8000bb60 <osEE_tc_core1_isr_dummy_entry_219>:
8000bb60:	3c 00       	j 8000bb60 <osEE_tc_core1_isr_dummy_entry_219>
	...

8000bb80 <osEE_tc_core1_isr_dummy_entry_220>:
8000bb80:	3c 00       	j 8000bb80 <osEE_tc_core1_isr_dummy_entry_220>
	...

8000bba0 <osEE_tc_core1_isr_dummy_entry_221>:
8000bba0:	3c 00       	j 8000bba0 <osEE_tc_core1_isr_dummy_entry_221>
	...

8000bbc0 <osEE_tc_core1_isr_dummy_entry_222>:
8000bbc0:	3c 00       	j 8000bbc0 <osEE_tc_core1_isr_dummy_entry_222>
	...

8000bbe0 <osEE_tc_core1_isr_dummy_entry_223>:
8000bbe0:	3c 00       	j 8000bbe0 <osEE_tc_core1_isr_dummy_entry_223>
	...

8000bc00 <osEE_tc_core1_isr_dummy_entry_224>:
8000bc00:	3c 00       	j 8000bc00 <osEE_tc_core1_isr_dummy_entry_224>
	...

8000bc20 <osEE_tc_core1_isr_dummy_entry_225>:
8000bc20:	3c 00       	j 8000bc20 <osEE_tc_core1_isr_dummy_entry_225>
	...

8000bc40 <osEE_tc_core1_isr_dummy_entry_226>:
8000bc40:	3c 00       	j 8000bc40 <osEE_tc_core1_isr_dummy_entry_226>
	...

8000bc60 <osEE_tc_core1_isr_dummy_entry_227>:
8000bc60:	3c 00       	j 8000bc60 <osEE_tc_core1_isr_dummy_entry_227>
	...

8000bc80 <osEE_tc_core1_isr_dummy_entry_228>:
8000bc80:	3c 00       	j 8000bc80 <osEE_tc_core1_isr_dummy_entry_228>
	...

8000bca0 <osEE_tc_core1_isr_dummy_entry_229>:
8000bca0:	3c 00       	j 8000bca0 <osEE_tc_core1_isr_dummy_entry_229>
	...

8000bcc0 <osEE_tc_core1_isr_dummy_entry_230>:
8000bcc0:	3c 00       	j 8000bcc0 <osEE_tc_core1_isr_dummy_entry_230>
	...

8000bce0 <osEE_tc_core1_isr_dummy_entry_231>:
8000bce0:	3c 00       	j 8000bce0 <osEE_tc_core1_isr_dummy_entry_231>
	...

8000bd00 <osEE_tc_core1_isr_dummy_entry_232>:
8000bd00:	3c 00       	j 8000bd00 <osEE_tc_core1_isr_dummy_entry_232>
	...

8000bd20 <osEE_tc_core1_isr_dummy_entry_233>:
8000bd20:	3c 00       	j 8000bd20 <osEE_tc_core1_isr_dummy_entry_233>
	...

8000bd40 <osEE_tc_core1_isr_dummy_entry_234>:
8000bd40:	3c 00       	j 8000bd40 <osEE_tc_core1_isr_dummy_entry_234>
	...

8000bd60 <osEE_tc_core1_isr_dummy_entry_235>:
8000bd60:	3c 00       	j 8000bd60 <osEE_tc_core1_isr_dummy_entry_235>
	...

8000bd80 <osEE_tc_core1_isr_dummy_entry_236>:
8000bd80:	3c 00       	j 8000bd80 <osEE_tc_core1_isr_dummy_entry_236>
	...

8000bda0 <osEE_tc_core1_isr_dummy_entry_237>:
8000bda0:	3c 00       	j 8000bda0 <osEE_tc_core1_isr_dummy_entry_237>
	...

8000bdc0 <osEE_tc_core1_isr_dummy_entry_238>:
8000bdc0:	3c 00       	j 8000bdc0 <osEE_tc_core1_isr_dummy_entry_238>
	...

8000bde0 <osEE_tc_core1_isr_dummy_entry_239>:
8000bde0:	3c 00       	j 8000bde0 <osEE_tc_core1_isr_dummy_entry_239>
	...

8000be00 <osEE_tc_core1_isr_dummy_entry_240>:
8000be00:	3c 00       	j 8000be00 <osEE_tc_core1_isr_dummy_entry_240>
	...

8000be20 <osEE_tc_core1_isr_dummy_entry_241>:
8000be20:	3c 00       	j 8000be20 <osEE_tc_core1_isr_dummy_entry_241>
	...

8000be40 <osEE_tc_core1_isr_dummy_entry_242>:
8000be40:	3c 00       	j 8000be40 <osEE_tc_core1_isr_dummy_entry_242>
	...

8000be60 <osEE_tc_core1_isr_dummy_entry_243>:
8000be60:	3c 00       	j 8000be60 <osEE_tc_core1_isr_dummy_entry_243>
	...

8000be80 <osEE_tc_core1_isr_dummy_entry_244>:
8000be80:	3c 00       	j 8000be80 <osEE_tc_core1_isr_dummy_entry_244>
	...

8000bea0 <osEE_tc_core1_isr_dummy_entry_245>:
8000bea0:	3c 00       	j 8000bea0 <osEE_tc_core1_isr_dummy_entry_245>
	...

8000bec0 <osEE_tc_core1_isr_dummy_entry_246>:
8000bec0:	3c 00       	j 8000bec0 <osEE_tc_core1_isr_dummy_entry_246>
	...

8000bee0 <osEE_tc_core1_isr_dummy_entry_247>:
8000bee0:	3c 00       	j 8000bee0 <osEE_tc_core1_isr_dummy_entry_247>
	...

8000bf00 <osEE_tc_core1_isr_dummy_entry_248>:
8000bf00:	3c 00       	j 8000bf00 <osEE_tc_core1_isr_dummy_entry_248>
	...

8000bf20 <osEE_tc_core1_isr_dummy_entry_249>:
8000bf20:	3c 00       	j 8000bf20 <osEE_tc_core1_isr_dummy_entry_249>
	...

8000bf40 <osEE_tc_core1_isr_dummy_entry_250>:
8000bf40:	3c 00       	j 8000bf40 <osEE_tc_core1_isr_dummy_entry_250>
	...

8000bf60 <osEE_tc_core1_isr_dummy_entry_251>:
8000bf60:	3c 00       	j 8000bf60 <osEE_tc_core1_isr_dummy_entry_251>
	...

8000bf80 <osEE_tc_core1_isr_dummy_entry_252>:
8000bf80:	3c 00       	j 8000bf80 <osEE_tc_core1_isr_dummy_entry_252>
	...

8000bfa0 <osEE_tc_core1_isr_dummy_entry_253>:
8000bfa0:	3c 00       	j 8000bfa0 <osEE_tc_core1_isr_dummy_entry_253>
	...

8000bfc0 <osEE_tc_core1_isr_dummy_entry_254>:
8000bfc0:	3c 00       	j 8000bfc0 <osEE_tc_core1_isr_dummy_entry_254>
	...

8000bfe0 <osEE_tc_core1_isr_dummy_entry_255>:
8000bfe0:	3c 00       	j 8000bfe0 <osEE_tc_core1_isr_dummy_entry_255>
	...

Disassembly of section .inttab_cpu2:

8000c000 <__INTTAB2>:
	...

8000c020 <osEE_tc_core2_isr2_entry_1>:
8000c020:	0d 00 00 02 	svlcx 
8000c024:	82 f4       	mov %d4,-1
8000c026:	1d ff 54 cb 	j 800056ce <osEE_tc_isr2_wrapper>
	...

8000c040 <osEE_tc_core2_isr2_entry_2>:
8000c040:	0d 00 00 02 	svlcx 
8000c044:	82 64       	mov %d4,6
8000c046:	1d ff 44 cb 	j 800056ce <osEE_tc_isr2_wrapper>
	...

8000c060 <osEE_tc_core2_isr_dummy_entry_3>:
8000c060:	3c 00       	j 8000c060 <osEE_tc_core2_isr_dummy_entry_3>
	...

8000c080 <osEE_tc_core2_isr_dummy_entry_4>:
8000c080:	3c 00       	j 8000c080 <osEE_tc_core2_isr_dummy_entry_4>
	...

8000c0a0 <osEE_tc_core2_isr_dummy_entry_5>:
8000c0a0:	3c 00       	j 8000c0a0 <osEE_tc_core2_isr_dummy_entry_5>
	...

8000c0c0 <osEE_tc_core2_isr_dummy_entry_6>:
8000c0c0:	3c 00       	j 8000c0c0 <osEE_tc_core2_isr_dummy_entry_6>
	...

8000c0e0 <osEE_tc_core2_isr_dummy_entry_7>:
8000c0e0:	3c 00       	j 8000c0e0 <osEE_tc_core2_isr_dummy_entry_7>
	...

8000c100 <osEE_tc_core2_isr_dummy_entry_8>:
8000c100:	3c 00       	j 8000c100 <osEE_tc_core2_isr_dummy_entry_8>
	...

8000c120 <osEE_tc_core2_isr_dummy_entry_9>:
8000c120:	3c 00       	j 8000c120 <osEE_tc_core2_isr_dummy_entry_9>
	...

8000c140 <osEE_tc_core2_isr_dummy_entry_10>:
8000c140:	3c 00       	j 8000c140 <osEE_tc_core2_isr_dummy_entry_10>
	...

8000c160 <osEE_tc_core2_isr_dummy_entry_11>:
8000c160:	3c 00       	j 8000c160 <osEE_tc_core2_isr_dummy_entry_11>
	...

8000c180 <osEE_tc_core2_isr_dummy_entry_12>:
8000c180:	3c 00       	j 8000c180 <osEE_tc_core2_isr_dummy_entry_12>
	...

8000c1a0 <osEE_tc_core2_isr_dummy_entry_13>:
8000c1a0:	3c 00       	j 8000c1a0 <osEE_tc_core2_isr_dummy_entry_13>
	...

8000c1c0 <osEE_tc_core2_isr_dummy_entry_14>:
8000c1c0:	3c 00       	j 8000c1c0 <osEE_tc_core2_isr_dummy_entry_14>
	...

8000c1e0 <osEE_tc_core2_isr_dummy_entry_15>:
8000c1e0:	3c 00       	j 8000c1e0 <osEE_tc_core2_isr_dummy_entry_15>
	...

8000c200 <osEE_tc_core2_isr_dummy_entry_16>:
8000c200:	3c 00       	j 8000c200 <osEE_tc_core2_isr_dummy_entry_16>
	...

8000c220 <osEE_tc_core2_isr_dummy_entry_17>:
8000c220:	3c 00       	j 8000c220 <osEE_tc_core2_isr_dummy_entry_17>
	...

8000c240 <osEE_tc_core2_isr_dummy_entry_18>:
8000c240:	3c 00       	j 8000c240 <osEE_tc_core2_isr_dummy_entry_18>
	...

8000c260 <osEE_tc_core2_isr_dummy_entry_19>:
8000c260:	3c 00       	j 8000c260 <osEE_tc_core2_isr_dummy_entry_19>
	...

8000c280 <osEE_tc_core2_isr_dummy_entry_20>:
8000c280:	3c 00       	j 8000c280 <osEE_tc_core2_isr_dummy_entry_20>
	...

8000c2a0 <osEE_tc_core2_isr_dummy_entry_21>:
8000c2a0:	3c 00       	j 8000c2a0 <osEE_tc_core2_isr_dummy_entry_21>
	...

8000c2c0 <osEE_tc_core2_isr_dummy_entry_22>:
8000c2c0:	3c 00       	j 8000c2c0 <osEE_tc_core2_isr_dummy_entry_22>
	...

8000c2e0 <osEE_tc_core2_isr_dummy_entry_23>:
8000c2e0:	3c 00       	j 8000c2e0 <osEE_tc_core2_isr_dummy_entry_23>
	...

8000c300 <osEE_tc_core2_isr_dummy_entry_24>:
8000c300:	3c 00       	j 8000c300 <osEE_tc_core2_isr_dummy_entry_24>
	...

8000c320 <osEE_tc_core2_isr_dummy_entry_25>:
8000c320:	3c 00       	j 8000c320 <osEE_tc_core2_isr_dummy_entry_25>
	...

8000c340 <osEE_tc_core2_isr_dummy_entry_26>:
8000c340:	3c 00       	j 8000c340 <osEE_tc_core2_isr_dummy_entry_26>
	...

8000c360 <osEE_tc_core2_isr_dummy_entry_27>:
8000c360:	3c 00       	j 8000c360 <osEE_tc_core2_isr_dummy_entry_27>
	...

8000c380 <osEE_tc_core2_isr_dummy_entry_28>:
8000c380:	3c 00       	j 8000c380 <osEE_tc_core2_isr_dummy_entry_28>
	...

8000c3a0 <osEE_tc_core2_isr_dummy_entry_29>:
8000c3a0:	3c 00       	j 8000c3a0 <osEE_tc_core2_isr_dummy_entry_29>
	...

8000c3c0 <osEE_tc_core2_isr_dummy_entry_30>:
8000c3c0:	3c 00       	j 8000c3c0 <osEE_tc_core2_isr_dummy_entry_30>
	...

8000c3e0 <osEE_tc_core2_isr_dummy_entry_31>:
8000c3e0:	3c 00       	j 8000c3e0 <osEE_tc_core2_isr_dummy_entry_31>
	...

8000c400 <osEE_tc_core2_isr_dummy_entry_32>:
8000c400:	3c 00       	j 8000c400 <osEE_tc_core2_isr_dummy_entry_32>
	...

8000c420 <osEE_tc_core2_isr_dummy_entry_33>:
8000c420:	3c 00       	j 8000c420 <osEE_tc_core2_isr_dummy_entry_33>
	...

8000c440 <osEE_tc_core2_isr_dummy_entry_34>:
8000c440:	3c 00       	j 8000c440 <osEE_tc_core2_isr_dummy_entry_34>
	...

8000c460 <osEE_tc_core2_isr_dummy_entry_35>:
8000c460:	3c 00       	j 8000c460 <osEE_tc_core2_isr_dummy_entry_35>
	...

8000c480 <osEE_tc_core2_isr_dummy_entry_36>:
8000c480:	3c 00       	j 8000c480 <osEE_tc_core2_isr_dummy_entry_36>
	...

8000c4a0 <osEE_tc_core2_isr_dummy_entry_37>:
8000c4a0:	3c 00       	j 8000c4a0 <osEE_tc_core2_isr_dummy_entry_37>
	...

8000c4c0 <osEE_tc_core2_isr_dummy_entry_38>:
8000c4c0:	3c 00       	j 8000c4c0 <osEE_tc_core2_isr_dummy_entry_38>
	...

8000c4e0 <osEE_tc_core2_isr_dummy_entry_39>:
8000c4e0:	3c 00       	j 8000c4e0 <osEE_tc_core2_isr_dummy_entry_39>
	...

8000c500 <osEE_tc_core2_isr_dummy_entry_40>:
8000c500:	3c 00       	j 8000c500 <osEE_tc_core2_isr_dummy_entry_40>
	...

8000c520 <osEE_tc_core2_isr_dummy_entry_41>:
8000c520:	3c 00       	j 8000c520 <osEE_tc_core2_isr_dummy_entry_41>
	...

8000c540 <osEE_tc_core2_isr_dummy_entry_42>:
8000c540:	3c 00       	j 8000c540 <osEE_tc_core2_isr_dummy_entry_42>
	...

8000c560 <osEE_tc_core2_isr_dummy_entry_43>:
8000c560:	3c 00       	j 8000c560 <osEE_tc_core2_isr_dummy_entry_43>
	...

8000c580 <osEE_tc_core2_isr_dummy_entry_44>:
8000c580:	3c 00       	j 8000c580 <osEE_tc_core2_isr_dummy_entry_44>
	...

8000c5a0 <osEE_tc_core2_isr_dummy_entry_45>:
8000c5a0:	3c 00       	j 8000c5a0 <osEE_tc_core2_isr_dummy_entry_45>
	...

8000c5c0 <osEE_tc_core2_isr_dummy_entry_46>:
8000c5c0:	3c 00       	j 8000c5c0 <osEE_tc_core2_isr_dummy_entry_46>
	...

8000c5e0 <osEE_tc_core2_isr_dummy_entry_47>:
8000c5e0:	3c 00       	j 8000c5e0 <osEE_tc_core2_isr_dummy_entry_47>
	...

8000c600 <osEE_tc_core2_isr_dummy_entry_48>:
8000c600:	3c 00       	j 8000c600 <osEE_tc_core2_isr_dummy_entry_48>
	...

8000c620 <osEE_tc_core2_isr_dummy_entry_49>:
8000c620:	3c 00       	j 8000c620 <osEE_tc_core2_isr_dummy_entry_49>
	...

8000c640 <osEE_tc_core2_isr_dummy_entry_50>:
8000c640:	3c 00       	j 8000c640 <osEE_tc_core2_isr_dummy_entry_50>
	...

8000c660 <osEE_tc_core2_isr_dummy_entry_51>:
8000c660:	3c 00       	j 8000c660 <osEE_tc_core2_isr_dummy_entry_51>
	...

8000c680 <osEE_tc_core2_isr_dummy_entry_52>:
8000c680:	3c 00       	j 8000c680 <osEE_tc_core2_isr_dummy_entry_52>
	...

8000c6a0 <osEE_tc_core2_isr_dummy_entry_53>:
8000c6a0:	3c 00       	j 8000c6a0 <osEE_tc_core2_isr_dummy_entry_53>
	...

8000c6c0 <osEE_tc_core2_isr_dummy_entry_54>:
8000c6c0:	3c 00       	j 8000c6c0 <osEE_tc_core2_isr_dummy_entry_54>
	...

8000c6e0 <osEE_tc_core2_isr_dummy_entry_55>:
8000c6e0:	3c 00       	j 8000c6e0 <osEE_tc_core2_isr_dummy_entry_55>
	...

8000c700 <osEE_tc_core2_isr_dummy_entry_56>:
8000c700:	3c 00       	j 8000c700 <osEE_tc_core2_isr_dummy_entry_56>
	...

8000c720 <osEE_tc_core2_isr_dummy_entry_57>:
8000c720:	3c 00       	j 8000c720 <osEE_tc_core2_isr_dummy_entry_57>
	...

8000c740 <osEE_tc_core2_isr_dummy_entry_58>:
8000c740:	3c 00       	j 8000c740 <osEE_tc_core2_isr_dummy_entry_58>
	...

8000c760 <osEE_tc_core2_isr_dummy_entry_59>:
8000c760:	3c 00       	j 8000c760 <osEE_tc_core2_isr_dummy_entry_59>
	...

8000c780 <osEE_tc_core2_isr_dummy_entry_60>:
8000c780:	3c 00       	j 8000c780 <osEE_tc_core2_isr_dummy_entry_60>
	...

8000c7a0 <osEE_tc_core2_isr_dummy_entry_61>:
8000c7a0:	3c 00       	j 8000c7a0 <osEE_tc_core2_isr_dummy_entry_61>
	...

8000c7c0 <osEE_tc_core2_isr_dummy_entry_62>:
8000c7c0:	3c 00       	j 8000c7c0 <osEE_tc_core2_isr_dummy_entry_62>
	...

8000c7e0 <osEE_tc_core2_isr_dummy_entry_63>:
8000c7e0:	3c 00       	j 8000c7e0 <osEE_tc_core2_isr_dummy_entry_63>
	...

8000c800 <osEE_tc_core2_isr_dummy_entry_64>:
8000c800:	3c 00       	j 8000c800 <osEE_tc_core2_isr_dummy_entry_64>
	...

8000c820 <osEE_tc_core2_isr_dummy_entry_65>:
8000c820:	3c 00       	j 8000c820 <osEE_tc_core2_isr_dummy_entry_65>
	...

8000c840 <osEE_tc_core2_isr_dummy_entry_66>:
8000c840:	3c 00       	j 8000c840 <osEE_tc_core2_isr_dummy_entry_66>
	...

8000c860 <osEE_tc_core2_isr_dummy_entry_67>:
8000c860:	3c 00       	j 8000c860 <osEE_tc_core2_isr_dummy_entry_67>
	...

8000c880 <osEE_tc_core2_isr_dummy_entry_68>:
8000c880:	3c 00       	j 8000c880 <osEE_tc_core2_isr_dummy_entry_68>
	...

8000c8a0 <osEE_tc_core2_isr_dummy_entry_69>:
8000c8a0:	3c 00       	j 8000c8a0 <osEE_tc_core2_isr_dummy_entry_69>
	...

8000c8c0 <osEE_tc_core2_isr_dummy_entry_70>:
8000c8c0:	3c 00       	j 8000c8c0 <osEE_tc_core2_isr_dummy_entry_70>
	...

8000c8e0 <osEE_tc_core2_isr_dummy_entry_71>:
8000c8e0:	3c 00       	j 8000c8e0 <osEE_tc_core2_isr_dummy_entry_71>
	...

8000c900 <osEE_tc_core2_isr_dummy_entry_72>:
8000c900:	3c 00       	j 8000c900 <osEE_tc_core2_isr_dummy_entry_72>
	...

8000c920 <osEE_tc_core2_isr_dummy_entry_73>:
8000c920:	3c 00       	j 8000c920 <osEE_tc_core2_isr_dummy_entry_73>
	...

8000c940 <osEE_tc_core2_isr_dummy_entry_74>:
8000c940:	3c 00       	j 8000c940 <osEE_tc_core2_isr_dummy_entry_74>
	...

8000c960 <osEE_tc_core2_isr_dummy_entry_75>:
8000c960:	3c 00       	j 8000c960 <osEE_tc_core2_isr_dummy_entry_75>
	...

8000c980 <osEE_tc_core2_isr_dummy_entry_76>:
8000c980:	3c 00       	j 8000c980 <osEE_tc_core2_isr_dummy_entry_76>
	...

8000c9a0 <osEE_tc_core2_isr_dummy_entry_77>:
8000c9a0:	3c 00       	j 8000c9a0 <osEE_tc_core2_isr_dummy_entry_77>
	...

8000c9c0 <osEE_tc_core2_isr_dummy_entry_78>:
8000c9c0:	3c 00       	j 8000c9c0 <osEE_tc_core2_isr_dummy_entry_78>
	...

8000c9e0 <osEE_tc_core2_isr_dummy_entry_79>:
8000c9e0:	3c 00       	j 8000c9e0 <osEE_tc_core2_isr_dummy_entry_79>
	...

8000ca00 <osEE_tc_core2_isr_dummy_entry_80>:
8000ca00:	3c 00       	j 8000ca00 <osEE_tc_core2_isr_dummy_entry_80>
	...

8000ca20 <osEE_tc_core2_isr_dummy_entry_81>:
8000ca20:	3c 00       	j 8000ca20 <osEE_tc_core2_isr_dummy_entry_81>
	...

8000ca40 <osEE_tc_core2_isr_dummy_entry_82>:
8000ca40:	3c 00       	j 8000ca40 <osEE_tc_core2_isr_dummy_entry_82>
	...

8000ca60 <osEE_tc_core2_isr_dummy_entry_83>:
8000ca60:	3c 00       	j 8000ca60 <osEE_tc_core2_isr_dummy_entry_83>
	...

8000ca80 <osEE_tc_core2_isr_dummy_entry_84>:
8000ca80:	3c 00       	j 8000ca80 <osEE_tc_core2_isr_dummy_entry_84>
	...

8000caa0 <osEE_tc_core2_isr_dummy_entry_85>:
8000caa0:	3c 00       	j 8000caa0 <osEE_tc_core2_isr_dummy_entry_85>
	...

8000cac0 <osEE_tc_core2_isr_dummy_entry_86>:
8000cac0:	3c 00       	j 8000cac0 <osEE_tc_core2_isr_dummy_entry_86>
	...

8000cae0 <osEE_tc_core2_isr_dummy_entry_87>:
8000cae0:	3c 00       	j 8000cae0 <osEE_tc_core2_isr_dummy_entry_87>
	...

8000cb00 <osEE_tc_core2_isr_dummy_entry_88>:
8000cb00:	3c 00       	j 8000cb00 <osEE_tc_core2_isr_dummy_entry_88>
	...

8000cb20 <osEE_tc_core2_isr_dummy_entry_89>:
8000cb20:	3c 00       	j 8000cb20 <osEE_tc_core2_isr_dummy_entry_89>
	...

8000cb40 <osEE_tc_core2_isr_dummy_entry_90>:
8000cb40:	3c 00       	j 8000cb40 <osEE_tc_core2_isr_dummy_entry_90>
	...

8000cb60 <osEE_tc_core2_isr_dummy_entry_91>:
8000cb60:	3c 00       	j 8000cb60 <osEE_tc_core2_isr_dummy_entry_91>
	...

8000cb80 <osEE_tc_core2_isr_dummy_entry_92>:
8000cb80:	3c 00       	j 8000cb80 <osEE_tc_core2_isr_dummy_entry_92>
	...

8000cba0 <osEE_tc_core2_isr_dummy_entry_93>:
8000cba0:	3c 00       	j 8000cba0 <osEE_tc_core2_isr_dummy_entry_93>
	...

8000cbc0 <osEE_tc_core2_isr_dummy_entry_94>:
8000cbc0:	3c 00       	j 8000cbc0 <osEE_tc_core2_isr_dummy_entry_94>
	...

8000cbe0 <osEE_tc_core2_isr_dummy_entry_95>:
8000cbe0:	3c 00       	j 8000cbe0 <osEE_tc_core2_isr_dummy_entry_95>
	...

8000cc00 <osEE_tc_core2_isr_dummy_entry_96>:
8000cc00:	3c 00       	j 8000cc00 <osEE_tc_core2_isr_dummy_entry_96>
	...

8000cc20 <osEE_tc_core2_isr_dummy_entry_97>:
8000cc20:	3c 00       	j 8000cc20 <osEE_tc_core2_isr_dummy_entry_97>
	...

8000cc40 <osEE_tc_core2_isr_dummy_entry_98>:
8000cc40:	3c 00       	j 8000cc40 <osEE_tc_core2_isr_dummy_entry_98>
	...

8000cc60 <osEE_tc_core2_isr_dummy_entry_99>:
8000cc60:	3c 00       	j 8000cc60 <osEE_tc_core2_isr_dummy_entry_99>
	...

8000cc80 <osEE_tc_core2_isr_dummy_entry_100>:
8000cc80:	3c 00       	j 8000cc80 <osEE_tc_core2_isr_dummy_entry_100>
	...

8000cca0 <osEE_tc_core2_isr_dummy_entry_101>:
8000cca0:	3c 00       	j 8000cca0 <osEE_tc_core2_isr_dummy_entry_101>
	...

8000ccc0 <osEE_tc_core2_isr_dummy_entry_102>:
8000ccc0:	3c 00       	j 8000ccc0 <osEE_tc_core2_isr_dummy_entry_102>
	...

8000cce0 <osEE_tc_core2_isr_dummy_entry_103>:
8000cce0:	3c 00       	j 8000cce0 <osEE_tc_core2_isr_dummy_entry_103>
	...

8000cd00 <osEE_tc_core2_isr_dummy_entry_104>:
8000cd00:	3c 00       	j 8000cd00 <osEE_tc_core2_isr_dummy_entry_104>
	...

8000cd20 <osEE_tc_core2_isr_dummy_entry_105>:
8000cd20:	3c 00       	j 8000cd20 <osEE_tc_core2_isr_dummy_entry_105>
	...

8000cd40 <osEE_tc_core2_isr_dummy_entry_106>:
8000cd40:	3c 00       	j 8000cd40 <osEE_tc_core2_isr_dummy_entry_106>
	...

8000cd60 <osEE_tc_core2_isr_dummy_entry_107>:
8000cd60:	3c 00       	j 8000cd60 <osEE_tc_core2_isr_dummy_entry_107>
	...

8000cd80 <osEE_tc_core2_isr_dummy_entry_108>:
8000cd80:	3c 00       	j 8000cd80 <osEE_tc_core2_isr_dummy_entry_108>
	...

8000cda0 <osEE_tc_core2_isr_dummy_entry_109>:
8000cda0:	3c 00       	j 8000cda0 <osEE_tc_core2_isr_dummy_entry_109>
	...

8000cdc0 <osEE_tc_core2_isr_dummy_entry_110>:
8000cdc0:	3c 00       	j 8000cdc0 <osEE_tc_core2_isr_dummy_entry_110>
	...

8000cde0 <osEE_tc_core2_isr_dummy_entry_111>:
8000cde0:	3c 00       	j 8000cde0 <osEE_tc_core2_isr_dummy_entry_111>
	...

8000ce00 <osEE_tc_core2_isr_dummy_entry_112>:
8000ce00:	3c 00       	j 8000ce00 <osEE_tc_core2_isr_dummy_entry_112>
	...

8000ce20 <osEE_tc_core2_isr_dummy_entry_113>:
8000ce20:	3c 00       	j 8000ce20 <osEE_tc_core2_isr_dummy_entry_113>
	...

8000ce40 <osEE_tc_core2_isr_dummy_entry_114>:
8000ce40:	3c 00       	j 8000ce40 <osEE_tc_core2_isr_dummy_entry_114>
	...

8000ce60 <osEE_tc_core2_isr_dummy_entry_115>:
8000ce60:	3c 00       	j 8000ce60 <osEE_tc_core2_isr_dummy_entry_115>
	...

8000ce80 <osEE_tc_core2_isr_dummy_entry_116>:
8000ce80:	3c 00       	j 8000ce80 <osEE_tc_core2_isr_dummy_entry_116>
	...

8000cea0 <osEE_tc_core2_isr_dummy_entry_117>:
8000cea0:	3c 00       	j 8000cea0 <osEE_tc_core2_isr_dummy_entry_117>
	...

8000cec0 <osEE_tc_core2_isr_dummy_entry_118>:
8000cec0:	3c 00       	j 8000cec0 <osEE_tc_core2_isr_dummy_entry_118>
	...

8000cee0 <osEE_tc_core2_isr_dummy_entry_119>:
8000cee0:	3c 00       	j 8000cee0 <osEE_tc_core2_isr_dummy_entry_119>
	...

8000cf00 <osEE_tc_core2_isr_dummy_entry_120>:
8000cf00:	3c 00       	j 8000cf00 <osEE_tc_core2_isr_dummy_entry_120>
	...

8000cf20 <osEE_tc_core2_isr_dummy_entry_121>:
8000cf20:	3c 00       	j 8000cf20 <osEE_tc_core2_isr_dummy_entry_121>
	...

8000cf40 <osEE_tc_core2_isr_dummy_entry_122>:
8000cf40:	3c 00       	j 8000cf40 <osEE_tc_core2_isr_dummy_entry_122>
	...

8000cf60 <osEE_tc_core2_isr_dummy_entry_123>:
8000cf60:	3c 00       	j 8000cf60 <osEE_tc_core2_isr_dummy_entry_123>
	...

8000cf80 <osEE_tc_core2_isr_dummy_entry_124>:
8000cf80:	3c 00       	j 8000cf80 <osEE_tc_core2_isr_dummy_entry_124>
	...

8000cfa0 <osEE_tc_core2_isr_dummy_entry_125>:
8000cfa0:	3c 00       	j 8000cfa0 <osEE_tc_core2_isr_dummy_entry_125>
	...

8000cfc0 <osEE_tc_core2_isr_dummy_entry_126>:
8000cfc0:	3c 00       	j 8000cfc0 <osEE_tc_core2_isr_dummy_entry_126>
	...

8000cfe0 <osEE_tc_core2_isr_dummy_entry_127>:
8000cfe0:	3c 00       	j 8000cfe0 <osEE_tc_core2_isr_dummy_entry_127>
	...

8000d000 <osEE_tc_core2_isr_dummy_entry_128>:
8000d000:	3c 00       	j 8000d000 <osEE_tc_core2_isr_dummy_entry_128>
	...

8000d020 <osEE_tc_core2_isr_dummy_entry_129>:
8000d020:	3c 00       	j 8000d020 <osEE_tc_core2_isr_dummy_entry_129>
	...

8000d040 <osEE_tc_core2_isr_dummy_entry_130>:
8000d040:	3c 00       	j 8000d040 <osEE_tc_core2_isr_dummy_entry_130>
	...

8000d060 <osEE_tc_core2_isr_dummy_entry_131>:
8000d060:	3c 00       	j 8000d060 <osEE_tc_core2_isr_dummy_entry_131>
	...

8000d080 <osEE_tc_core2_isr_dummy_entry_132>:
8000d080:	3c 00       	j 8000d080 <osEE_tc_core2_isr_dummy_entry_132>
	...

8000d0a0 <osEE_tc_core2_isr_dummy_entry_133>:
8000d0a0:	3c 00       	j 8000d0a0 <osEE_tc_core2_isr_dummy_entry_133>
	...

8000d0c0 <osEE_tc_core2_isr_dummy_entry_134>:
8000d0c0:	3c 00       	j 8000d0c0 <osEE_tc_core2_isr_dummy_entry_134>
	...

8000d0e0 <osEE_tc_core2_isr_dummy_entry_135>:
8000d0e0:	3c 00       	j 8000d0e0 <osEE_tc_core2_isr_dummy_entry_135>
	...

8000d100 <osEE_tc_core2_isr_dummy_entry_136>:
8000d100:	3c 00       	j 8000d100 <osEE_tc_core2_isr_dummy_entry_136>
	...

8000d120 <osEE_tc_core2_isr_dummy_entry_137>:
8000d120:	3c 00       	j 8000d120 <osEE_tc_core2_isr_dummy_entry_137>
	...

8000d140 <osEE_tc_core2_isr_dummy_entry_138>:
8000d140:	3c 00       	j 8000d140 <osEE_tc_core2_isr_dummy_entry_138>
	...

8000d160 <osEE_tc_core2_isr_dummy_entry_139>:
8000d160:	3c 00       	j 8000d160 <osEE_tc_core2_isr_dummy_entry_139>
	...

8000d180 <osEE_tc_core2_isr_dummy_entry_140>:
8000d180:	3c 00       	j 8000d180 <osEE_tc_core2_isr_dummy_entry_140>
	...

8000d1a0 <osEE_tc_core2_isr_dummy_entry_141>:
8000d1a0:	3c 00       	j 8000d1a0 <osEE_tc_core2_isr_dummy_entry_141>
	...

8000d1c0 <osEE_tc_core2_isr_dummy_entry_142>:
8000d1c0:	3c 00       	j 8000d1c0 <osEE_tc_core2_isr_dummy_entry_142>
	...

8000d1e0 <osEE_tc_core2_isr_dummy_entry_143>:
8000d1e0:	3c 00       	j 8000d1e0 <osEE_tc_core2_isr_dummy_entry_143>
	...

8000d200 <osEE_tc_core2_isr_dummy_entry_144>:
8000d200:	3c 00       	j 8000d200 <osEE_tc_core2_isr_dummy_entry_144>
	...

8000d220 <osEE_tc_core2_isr_dummy_entry_145>:
8000d220:	3c 00       	j 8000d220 <osEE_tc_core2_isr_dummy_entry_145>
	...

8000d240 <osEE_tc_core2_isr_dummy_entry_146>:
8000d240:	3c 00       	j 8000d240 <osEE_tc_core2_isr_dummy_entry_146>
	...

8000d260 <osEE_tc_core2_isr_dummy_entry_147>:
8000d260:	3c 00       	j 8000d260 <osEE_tc_core2_isr_dummy_entry_147>
	...

8000d280 <osEE_tc_core2_isr_dummy_entry_148>:
8000d280:	3c 00       	j 8000d280 <osEE_tc_core2_isr_dummy_entry_148>
	...

8000d2a0 <osEE_tc_core2_isr_dummy_entry_149>:
8000d2a0:	3c 00       	j 8000d2a0 <osEE_tc_core2_isr_dummy_entry_149>
	...

8000d2c0 <osEE_tc_core2_isr_dummy_entry_150>:
8000d2c0:	3c 00       	j 8000d2c0 <osEE_tc_core2_isr_dummy_entry_150>
	...

8000d2e0 <osEE_tc_core2_isr_dummy_entry_151>:
8000d2e0:	3c 00       	j 8000d2e0 <osEE_tc_core2_isr_dummy_entry_151>
	...

8000d300 <osEE_tc_core2_isr_dummy_entry_152>:
8000d300:	3c 00       	j 8000d300 <osEE_tc_core2_isr_dummy_entry_152>
	...

8000d320 <osEE_tc_core2_isr_dummy_entry_153>:
8000d320:	3c 00       	j 8000d320 <osEE_tc_core2_isr_dummy_entry_153>
	...

8000d340 <osEE_tc_core2_isr_dummy_entry_154>:
8000d340:	3c 00       	j 8000d340 <osEE_tc_core2_isr_dummy_entry_154>
	...

8000d360 <osEE_tc_core2_isr_dummy_entry_155>:
8000d360:	3c 00       	j 8000d360 <osEE_tc_core2_isr_dummy_entry_155>
	...

8000d380 <osEE_tc_core2_isr_dummy_entry_156>:
8000d380:	3c 00       	j 8000d380 <osEE_tc_core2_isr_dummy_entry_156>
	...

8000d3a0 <osEE_tc_core2_isr_dummy_entry_157>:
8000d3a0:	3c 00       	j 8000d3a0 <osEE_tc_core2_isr_dummy_entry_157>
	...

8000d3c0 <osEE_tc_core2_isr_dummy_entry_158>:
8000d3c0:	3c 00       	j 8000d3c0 <osEE_tc_core2_isr_dummy_entry_158>
	...

8000d3e0 <osEE_tc_core2_isr_dummy_entry_159>:
8000d3e0:	3c 00       	j 8000d3e0 <osEE_tc_core2_isr_dummy_entry_159>
	...

8000d400 <osEE_tc_core2_isr_dummy_entry_160>:
8000d400:	3c 00       	j 8000d400 <osEE_tc_core2_isr_dummy_entry_160>
	...

8000d420 <osEE_tc_core2_isr_dummy_entry_161>:
8000d420:	3c 00       	j 8000d420 <osEE_tc_core2_isr_dummy_entry_161>
	...

8000d440 <osEE_tc_core2_isr_dummy_entry_162>:
8000d440:	3c 00       	j 8000d440 <osEE_tc_core2_isr_dummy_entry_162>
	...

8000d460 <osEE_tc_core2_isr_dummy_entry_163>:
8000d460:	3c 00       	j 8000d460 <osEE_tc_core2_isr_dummy_entry_163>
	...

8000d480 <osEE_tc_core2_isr_dummy_entry_164>:
8000d480:	3c 00       	j 8000d480 <osEE_tc_core2_isr_dummy_entry_164>
	...

8000d4a0 <osEE_tc_core2_isr_dummy_entry_165>:
8000d4a0:	3c 00       	j 8000d4a0 <osEE_tc_core2_isr_dummy_entry_165>
	...

8000d4c0 <osEE_tc_core2_isr_dummy_entry_166>:
8000d4c0:	3c 00       	j 8000d4c0 <osEE_tc_core2_isr_dummy_entry_166>
	...

8000d4e0 <osEE_tc_core2_isr_dummy_entry_167>:
8000d4e0:	3c 00       	j 8000d4e0 <osEE_tc_core2_isr_dummy_entry_167>
	...

8000d500 <osEE_tc_core2_isr_dummy_entry_168>:
8000d500:	3c 00       	j 8000d500 <osEE_tc_core2_isr_dummy_entry_168>
	...

8000d520 <osEE_tc_core2_isr_dummy_entry_169>:
8000d520:	3c 00       	j 8000d520 <osEE_tc_core2_isr_dummy_entry_169>
	...

8000d540 <osEE_tc_core2_isr_dummy_entry_170>:
8000d540:	3c 00       	j 8000d540 <osEE_tc_core2_isr_dummy_entry_170>
	...

8000d560 <osEE_tc_core2_isr_dummy_entry_171>:
8000d560:	3c 00       	j 8000d560 <osEE_tc_core2_isr_dummy_entry_171>
	...

8000d580 <osEE_tc_core2_isr_dummy_entry_172>:
8000d580:	3c 00       	j 8000d580 <osEE_tc_core2_isr_dummy_entry_172>
	...

8000d5a0 <osEE_tc_core2_isr_dummy_entry_173>:
8000d5a0:	3c 00       	j 8000d5a0 <osEE_tc_core2_isr_dummy_entry_173>
	...

8000d5c0 <osEE_tc_core2_isr_dummy_entry_174>:
8000d5c0:	3c 00       	j 8000d5c0 <osEE_tc_core2_isr_dummy_entry_174>
	...

8000d5e0 <osEE_tc_core2_isr_dummy_entry_175>:
8000d5e0:	3c 00       	j 8000d5e0 <osEE_tc_core2_isr_dummy_entry_175>
	...

8000d600 <osEE_tc_core2_isr_dummy_entry_176>:
8000d600:	3c 00       	j 8000d600 <osEE_tc_core2_isr_dummy_entry_176>
	...

8000d620 <osEE_tc_core2_isr_dummy_entry_177>:
8000d620:	3c 00       	j 8000d620 <osEE_tc_core2_isr_dummy_entry_177>
	...

8000d640 <osEE_tc_core2_isr_dummy_entry_178>:
8000d640:	3c 00       	j 8000d640 <osEE_tc_core2_isr_dummy_entry_178>
	...

8000d660 <osEE_tc_core2_isr_dummy_entry_179>:
8000d660:	3c 00       	j 8000d660 <osEE_tc_core2_isr_dummy_entry_179>
	...

8000d680 <osEE_tc_core2_isr_dummy_entry_180>:
8000d680:	3c 00       	j 8000d680 <osEE_tc_core2_isr_dummy_entry_180>
	...

8000d6a0 <osEE_tc_core2_isr_dummy_entry_181>:
8000d6a0:	3c 00       	j 8000d6a0 <osEE_tc_core2_isr_dummy_entry_181>
	...

8000d6c0 <osEE_tc_core2_isr_dummy_entry_182>:
8000d6c0:	3c 00       	j 8000d6c0 <osEE_tc_core2_isr_dummy_entry_182>
	...

8000d6e0 <osEE_tc_core2_isr_dummy_entry_183>:
8000d6e0:	3c 00       	j 8000d6e0 <osEE_tc_core2_isr_dummy_entry_183>
	...

8000d700 <osEE_tc_core2_isr_dummy_entry_184>:
8000d700:	3c 00       	j 8000d700 <osEE_tc_core2_isr_dummy_entry_184>
	...

8000d720 <osEE_tc_core2_isr_dummy_entry_185>:
8000d720:	3c 00       	j 8000d720 <osEE_tc_core2_isr_dummy_entry_185>
	...

8000d740 <osEE_tc_core2_isr_dummy_entry_186>:
8000d740:	3c 00       	j 8000d740 <osEE_tc_core2_isr_dummy_entry_186>
	...

8000d760 <osEE_tc_core2_isr_dummy_entry_187>:
8000d760:	3c 00       	j 8000d760 <osEE_tc_core2_isr_dummy_entry_187>
	...

8000d780 <osEE_tc_core2_isr_dummy_entry_188>:
8000d780:	3c 00       	j 8000d780 <osEE_tc_core2_isr_dummy_entry_188>
	...

8000d7a0 <osEE_tc_core2_isr_dummy_entry_189>:
8000d7a0:	3c 00       	j 8000d7a0 <osEE_tc_core2_isr_dummy_entry_189>
	...

8000d7c0 <osEE_tc_core2_isr_dummy_entry_190>:
8000d7c0:	3c 00       	j 8000d7c0 <osEE_tc_core2_isr_dummy_entry_190>
	...

8000d7e0 <osEE_tc_core2_isr_dummy_entry_191>:
8000d7e0:	3c 00       	j 8000d7e0 <osEE_tc_core2_isr_dummy_entry_191>
	...

8000d800 <osEE_tc_core2_isr_dummy_entry_192>:
8000d800:	3c 00       	j 8000d800 <osEE_tc_core2_isr_dummy_entry_192>
	...

8000d820 <osEE_tc_core2_isr_dummy_entry_193>:
8000d820:	3c 00       	j 8000d820 <osEE_tc_core2_isr_dummy_entry_193>
	...

8000d840 <osEE_tc_core2_isr_dummy_entry_194>:
8000d840:	3c 00       	j 8000d840 <osEE_tc_core2_isr_dummy_entry_194>
	...

8000d860 <osEE_tc_core2_isr_dummy_entry_195>:
8000d860:	3c 00       	j 8000d860 <osEE_tc_core2_isr_dummy_entry_195>
	...

8000d880 <osEE_tc_core2_isr_dummy_entry_196>:
8000d880:	3c 00       	j 8000d880 <osEE_tc_core2_isr_dummy_entry_196>
	...

8000d8a0 <osEE_tc_core2_isr_dummy_entry_197>:
8000d8a0:	3c 00       	j 8000d8a0 <osEE_tc_core2_isr_dummy_entry_197>
	...

8000d8c0 <osEE_tc_core2_isr_dummy_entry_198>:
8000d8c0:	3c 00       	j 8000d8c0 <osEE_tc_core2_isr_dummy_entry_198>
	...

8000d8e0 <osEE_tc_core2_isr_dummy_entry_199>:
8000d8e0:	3c 00       	j 8000d8e0 <osEE_tc_core2_isr_dummy_entry_199>
	...

8000d900 <osEE_tc_core2_isr_dummy_entry_200>:
8000d900:	3c 00       	j 8000d900 <osEE_tc_core2_isr_dummy_entry_200>
	...

8000d920 <osEE_tc_core2_isr_dummy_entry_201>:
8000d920:	3c 00       	j 8000d920 <osEE_tc_core2_isr_dummy_entry_201>
	...

8000d940 <osEE_tc_core2_isr_dummy_entry_202>:
8000d940:	3c 00       	j 8000d940 <osEE_tc_core2_isr_dummy_entry_202>
	...

8000d960 <osEE_tc_core2_isr_dummy_entry_203>:
8000d960:	3c 00       	j 8000d960 <osEE_tc_core2_isr_dummy_entry_203>
	...

8000d980 <osEE_tc_core2_isr_dummy_entry_204>:
8000d980:	3c 00       	j 8000d980 <osEE_tc_core2_isr_dummy_entry_204>
	...

8000d9a0 <osEE_tc_core2_isr_dummy_entry_205>:
8000d9a0:	3c 00       	j 8000d9a0 <osEE_tc_core2_isr_dummy_entry_205>
	...

8000d9c0 <osEE_tc_core2_isr_dummy_entry_206>:
8000d9c0:	3c 00       	j 8000d9c0 <osEE_tc_core2_isr_dummy_entry_206>
	...

8000d9e0 <osEE_tc_core2_isr_dummy_entry_207>:
8000d9e0:	3c 00       	j 8000d9e0 <osEE_tc_core2_isr_dummy_entry_207>
	...

8000da00 <osEE_tc_core2_isr_dummy_entry_208>:
8000da00:	3c 00       	j 8000da00 <osEE_tc_core2_isr_dummy_entry_208>
	...

8000da20 <osEE_tc_core2_isr_dummy_entry_209>:
8000da20:	3c 00       	j 8000da20 <osEE_tc_core2_isr_dummy_entry_209>
	...

8000da40 <osEE_tc_core2_isr_dummy_entry_210>:
8000da40:	3c 00       	j 8000da40 <osEE_tc_core2_isr_dummy_entry_210>
	...

8000da60 <osEE_tc_core2_isr_dummy_entry_211>:
8000da60:	3c 00       	j 8000da60 <osEE_tc_core2_isr_dummy_entry_211>
	...

8000da80 <osEE_tc_core2_isr_dummy_entry_212>:
8000da80:	3c 00       	j 8000da80 <osEE_tc_core2_isr_dummy_entry_212>
	...

8000daa0 <osEE_tc_core2_isr_dummy_entry_213>:
8000daa0:	3c 00       	j 8000daa0 <osEE_tc_core2_isr_dummy_entry_213>
	...

8000dac0 <osEE_tc_core2_isr_dummy_entry_214>:
8000dac0:	3c 00       	j 8000dac0 <osEE_tc_core2_isr_dummy_entry_214>
	...

8000dae0 <osEE_tc_core2_isr_dummy_entry_215>:
8000dae0:	3c 00       	j 8000dae0 <osEE_tc_core2_isr_dummy_entry_215>
	...

8000db00 <osEE_tc_core2_isr_dummy_entry_216>:
8000db00:	3c 00       	j 8000db00 <osEE_tc_core2_isr_dummy_entry_216>
	...

8000db20 <osEE_tc_core2_isr_dummy_entry_217>:
8000db20:	3c 00       	j 8000db20 <osEE_tc_core2_isr_dummy_entry_217>
	...

8000db40 <osEE_tc_core2_isr_dummy_entry_218>:
8000db40:	3c 00       	j 8000db40 <osEE_tc_core2_isr_dummy_entry_218>
	...

8000db60 <osEE_tc_core2_isr_dummy_entry_219>:
8000db60:	3c 00       	j 8000db60 <osEE_tc_core2_isr_dummy_entry_219>
	...

8000db80 <osEE_tc_core2_isr_dummy_entry_220>:
8000db80:	3c 00       	j 8000db80 <osEE_tc_core2_isr_dummy_entry_220>
	...

8000dba0 <osEE_tc_core2_isr_dummy_entry_221>:
8000dba0:	3c 00       	j 8000dba0 <osEE_tc_core2_isr_dummy_entry_221>
	...

8000dbc0 <osEE_tc_core2_isr_dummy_entry_222>:
8000dbc0:	3c 00       	j 8000dbc0 <osEE_tc_core2_isr_dummy_entry_222>
	...

8000dbe0 <osEE_tc_core2_isr_dummy_entry_223>:
8000dbe0:	3c 00       	j 8000dbe0 <osEE_tc_core2_isr_dummy_entry_223>
	...

8000dc00 <osEE_tc_core2_isr_dummy_entry_224>:
8000dc00:	3c 00       	j 8000dc00 <osEE_tc_core2_isr_dummy_entry_224>
	...

8000dc20 <osEE_tc_core2_isr_dummy_entry_225>:
8000dc20:	3c 00       	j 8000dc20 <osEE_tc_core2_isr_dummy_entry_225>
	...

8000dc40 <osEE_tc_core2_isr_dummy_entry_226>:
8000dc40:	3c 00       	j 8000dc40 <osEE_tc_core2_isr_dummy_entry_226>
	...

8000dc60 <osEE_tc_core2_isr_dummy_entry_227>:
8000dc60:	3c 00       	j 8000dc60 <osEE_tc_core2_isr_dummy_entry_227>
	...

8000dc80 <osEE_tc_core2_isr_dummy_entry_228>:
8000dc80:	3c 00       	j 8000dc80 <osEE_tc_core2_isr_dummy_entry_228>
	...

8000dca0 <osEE_tc_core2_isr_dummy_entry_229>:
8000dca0:	3c 00       	j 8000dca0 <osEE_tc_core2_isr_dummy_entry_229>
	...

8000dcc0 <osEE_tc_core2_isr_dummy_entry_230>:
8000dcc0:	3c 00       	j 8000dcc0 <osEE_tc_core2_isr_dummy_entry_230>
	...

8000dce0 <osEE_tc_core2_isr_dummy_entry_231>:
8000dce0:	3c 00       	j 8000dce0 <osEE_tc_core2_isr_dummy_entry_231>
	...

8000dd00 <osEE_tc_core2_isr_dummy_entry_232>:
8000dd00:	3c 00       	j 8000dd00 <osEE_tc_core2_isr_dummy_entry_232>
	...

8000dd20 <osEE_tc_core2_isr_dummy_entry_233>:
8000dd20:	3c 00       	j 8000dd20 <osEE_tc_core2_isr_dummy_entry_233>
	...

8000dd40 <osEE_tc_core2_isr_dummy_entry_234>:
8000dd40:	3c 00       	j 8000dd40 <osEE_tc_core2_isr_dummy_entry_234>
	...

8000dd60 <osEE_tc_core2_isr_dummy_entry_235>:
8000dd60:	3c 00       	j 8000dd60 <osEE_tc_core2_isr_dummy_entry_235>
	...

8000dd80 <osEE_tc_core2_isr_dummy_entry_236>:
8000dd80:	3c 00       	j 8000dd80 <osEE_tc_core2_isr_dummy_entry_236>
	...

8000dda0 <osEE_tc_core2_isr_dummy_entry_237>:
8000dda0:	3c 00       	j 8000dda0 <osEE_tc_core2_isr_dummy_entry_237>
	...

8000ddc0 <osEE_tc_core2_isr_dummy_entry_238>:
8000ddc0:	3c 00       	j 8000ddc0 <osEE_tc_core2_isr_dummy_entry_238>
	...

8000dde0 <osEE_tc_core2_isr_dummy_entry_239>:
8000dde0:	3c 00       	j 8000dde0 <osEE_tc_core2_isr_dummy_entry_239>
	...

8000de00 <osEE_tc_core2_isr_dummy_entry_240>:
8000de00:	3c 00       	j 8000de00 <osEE_tc_core2_isr_dummy_entry_240>
	...

8000de20 <osEE_tc_core2_isr_dummy_entry_241>:
8000de20:	3c 00       	j 8000de20 <osEE_tc_core2_isr_dummy_entry_241>
	...

8000de40 <osEE_tc_core2_isr_dummy_entry_242>:
8000de40:	3c 00       	j 8000de40 <osEE_tc_core2_isr_dummy_entry_242>
	...

8000de60 <osEE_tc_core2_isr_dummy_entry_243>:
8000de60:	3c 00       	j 8000de60 <osEE_tc_core2_isr_dummy_entry_243>
	...

8000de80 <osEE_tc_core2_isr_dummy_entry_244>:
8000de80:	3c 00       	j 8000de80 <osEE_tc_core2_isr_dummy_entry_244>
	...

8000dea0 <osEE_tc_core2_isr_dummy_entry_245>:
8000dea0:	3c 00       	j 8000dea0 <osEE_tc_core2_isr_dummy_entry_245>
	...

8000dec0 <osEE_tc_core2_isr_dummy_entry_246>:
8000dec0:	3c 00       	j 8000dec0 <osEE_tc_core2_isr_dummy_entry_246>
	...

8000dee0 <osEE_tc_core2_isr_dummy_entry_247>:
8000dee0:	3c 00       	j 8000dee0 <osEE_tc_core2_isr_dummy_entry_247>
	...

8000df00 <osEE_tc_core2_isr_dummy_entry_248>:
8000df00:	3c 00       	j 8000df00 <osEE_tc_core2_isr_dummy_entry_248>
	...

8000df20 <osEE_tc_core2_isr_dummy_entry_249>:
8000df20:	3c 00       	j 8000df20 <osEE_tc_core2_isr_dummy_entry_249>
	...

8000df40 <osEE_tc_core2_isr_dummy_entry_250>:
8000df40:	3c 00       	j 8000df40 <osEE_tc_core2_isr_dummy_entry_250>
	...

8000df60 <osEE_tc_core2_isr_dummy_entry_251>:
8000df60:	3c 00       	j 8000df60 <osEE_tc_core2_isr_dummy_entry_251>
	...

8000df80 <osEE_tc_core2_isr_dummy_entry_252>:
8000df80:	3c 00       	j 8000df80 <osEE_tc_core2_isr_dummy_entry_252>
	...

8000dfa0 <osEE_tc_core2_isr_dummy_entry_253>:
8000dfa0:	3c 00       	j 8000dfa0 <osEE_tc_core2_isr_dummy_entry_253>
	...

8000dfc0 <osEE_tc_core2_isr_dummy_entry_254>:
8000dfc0:	3c 00       	j 8000dfc0 <osEE_tc_core2_isr_dummy_entry_254>
	...

8000dfe0 <osEE_tc_core2_isr_dummy_entry_255>:
8000dfe0:	3c 00       	j 8000dfe0 <osEE_tc_core2_isr_dummy_entry_255>
	...
